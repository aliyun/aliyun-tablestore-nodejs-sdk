/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.main = (function() {

    /**
     * Namespace main.
     * @exports main
     * @namespace
     */
    var main = {};

    main.proto = (function() {

        /**
         * Namespace proto.
         * @memberof main
         * @namespace
         */
        var proto = {};

        proto.Error = (function() {

            /**
             * Properties of an Error.
             * @memberof main.proto
             * @interface IError
             * @property {string} code Error code
             * @property {string|null} [message] Error message
             */

            /**
             * Constructs a new Error.
             * @memberof main.proto
             * @classdesc Represents an Error.
             * @implements IError
             * @constructor
             * @param {main.proto.IError=} [properties] Properties to set
             */
            function Error(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Error code.
             * @member {string} code
             * @memberof main.proto.Error
             * @instance
             */
            Error.prototype.code = "";

            /**
             * Error message.
             * @member {string} message
             * @memberof main.proto.Error
             * @instance
             */
            Error.prototype.message = "";

            /**
             * Creates a new Error instance using the specified properties.
             * @function create
             * @memberof main.proto.Error
             * @static
             * @param {main.proto.IError=} [properties] Properties to set
             * @returns {main.proto.Error} Error instance
             */
            Error.create = function create(properties) {
                return new Error(properties);
            };

            /**
             * Encodes the specified Error message. Does not implicitly {@link main.proto.Error.verify|verify} messages.
             * @function encode
             * @memberof main.proto.Error
             * @static
             * @param {main.proto.IError} message Error message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Error.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.code);
                if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
                return writer;
            };

            /**
             * Encodes the specified Error message, length delimited. Does not implicitly {@link main.proto.Error.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.Error
             * @static
             * @param {main.proto.IError} message Error message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Error.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Error message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.Error
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.Error} Error
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Error.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.Error();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.code = reader.string();
                        break;
                    case 2:
                        message.message = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("code"))
                    throw $util.ProtocolError("missing required 'code'", { instance: message });
                return message;
            };

            /**
             * Decodes an Error message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.Error
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.Error} Error
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Error.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Error message.
             * @function verify
             * @memberof main.proto.Error
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Error.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.code))
                    return "code: string expected";
                if (message.message != null && message.hasOwnProperty("message"))
                    if (!$util.isString(message.message))
                        return "message: string expected";
                return null;
            };

            /**
             * Creates an Error message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.Error
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.Error} Error
             */
            Error.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.Error)
                    return object;
                var message = new $root.main.proto.Error();
                if (object.code != null)
                    message.code = String(object.code);
                if (object.message != null)
                    message.message = String(object.message);
                return message;
            };

            /**
             * Creates a plain object from an Error message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.Error
             * @static
             * @param {main.proto.Error} message Error
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Error.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.code = "";
                    object.message = "";
                }
                if (message.code != null && message.hasOwnProperty("code"))
                    object.code = message.code;
                if (message.message != null && message.hasOwnProperty("message"))
                    object.message = message.message;
                return object;
            };

            /**
             * Converts this Error to JSON.
             * @function toJSON
             * @memberof main.proto.Error
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Error.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Error;
        })();

        /**
         * PrimaryKeyType enum.
         * @name main.proto.PrimaryKeyType
         * @enum {number}
         * @property {number} INTEGER=1 INTEGER value
         * @property {number} STRING=2 STRING value
         * @property {number} BINARY=3 BINARY value
         */
        proto.PrimaryKeyType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "INTEGER"] = 1;
            values[valuesById[2] = "STRING"] = 2;
            values[valuesById[3] = "BINARY"] = 3;
            return values;
        })();

        /**
         * DefinedColumnType enum.
         * @name main.proto.DefinedColumnType
         * @enum {number}
         * @property {number} DCT_INTEGER=1 DCT_INTEGER value
         * @property {number} DCT_DOUBLE=2 DCT_DOUBLE value
         * @property {number} DCT_BOOLEAN=3 DCT_BOOLEAN value
         * @property {number} DCT_STRING=4 DCT_STRING value
         * @property {number} DCT_BLOB=7 DCT_BLOB value
         */
        proto.DefinedColumnType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "DCT_INTEGER"] = 1;
            values[valuesById[2] = "DCT_DOUBLE"] = 2;
            values[valuesById[3] = "DCT_BOOLEAN"] = 3;
            values[valuesById[4] = "DCT_STRING"] = 4;
            values[valuesById[7] = "DCT_BLOB"] = 7;
            return values;
        })();

        /**
         * PrimaryKeyOption enum.
         * @name main.proto.PrimaryKeyOption
         * @enum {number}
         * @property {number} AUTO_INCREMENT=1 AUTO_INCREMENT value
         */
        proto.PrimaryKeyOption = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "AUTO_INCREMENT"] = 1;
            return values;
        })();

        proto.PrimaryKeySchema = (function() {

            /**
             * Properties of a PrimaryKeySchema.
             * @memberof main.proto
             * @interface IPrimaryKeySchema
             * @property {string} name PrimaryKeySchema name
             * @property {main.proto.PrimaryKeyType} type PrimaryKeySchema type
             * @property {main.proto.PrimaryKeyOption|null} [option] PrimaryKeySchema option
             */

            /**
             * Constructs a new PrimaryKeySchema.
             * @memberof main.proto
             * @classdesc Represents a PrimaryKeySchema.
             * @implements IPrimaryKeySchema
             * @constructor
             * @param {main.proto.IPrimaryKeySchema=} [properties] Properties to set
             */
            function PrimaryKeySchema(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PrimaryKeySchema name.
             * @member {string} name
             * @memberof main.proto.PrimaryKeySchema
             * @instance
             */
            PrimaryKeySchema.prototype.name = "";

            /**
             * PrimaryKeySchema type.
             * @member {main.proto.PrimaryKeyType} type
             * @memberof main.proto.PrimaryKeySchema
             * @instance
             */
            PrimaryKeySchema.prototype.type = 1;

            /**
             * PrimaryKeySchema option.
             * @member {main.proto.PrimaryKeyOption} option
             * @memberof main.proto.PrimaryKeySchema
             * @instance
             */
            PrimaryKeySchema.prototype.option = 1;

            /**
             * Creates a new PrimaryKeySchema instance using the specified properties.
             * @function create
             * @memberof main.proto.PrimaryKeySchema
             * @static
             * @param {main.proto.IPrimaryKeySchema=} [properties] Properties to set
             * @returns {main.proto.PrimaryKeySchema} PrimaryKeySchema instance
             */
            PrimaryKeySchema.create = function create(properties) {
                return new PrimaryKeySchema(properties);
            };

            /**
             * Encodes the specified PrimaryKeySchema message. Does not implicitly {@link main.proto.PrimaryKeySchema.verify|verify} messages.
             * @function encode
             * @memberof main.proto.PrimaryKeySchema
             * @static
             * @param {main.proto.IPrimaryKeySchema} message PrimaryKeySchema message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PrimaryKeySchema.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                if (message.option != null && Object.hasOwnProperty.call(message, "option"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.option);
                return writer;
            };

            /**
             * Encodes the specified PrimaryKeySchema message, length delimited. Does not implicitly {@link main.proto.PrimaryKeySchema.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.PrimaryKeySchema
             * @static
             * @param {main.proto.IPrimaryKeySchema} message PrimaryKeySchema message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PrimaryKeySchema.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PrimaryKeySchema message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.PrimaryKeySchema
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.PrimaryKeySchema} PrimaryKeySchema
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PrimaryKeySchema.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.PrimaryKeySchema();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.type = reader.int32();
                        break;
                    case 3:
                        message.option = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("name"))
                    throw $util.ProtocolError("missing required 'name'", { instance: message });
                if (!message.hasOwnProperty("type"))
                    throw $util.ProtocolError("missing required 'type'", { instance: message });
                return message;
            };

            /**
             * Decodes a PrimaryKeySchema message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.PrimaryKeySchema
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.PrimaryKeySchema} PrimaryKeySchema
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PrimaryKeySchema.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PrimaryKeySchema message.
             * @function verify
             * @memberof main.proto.PrimaryKeySchema
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PrimaryKeySchema.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.name))
                    return "name: string expected";
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 1:
                case 2:
                case 3:
                    break;
                }
                if (message.option != null && message.hasOwnProperty("option"))
                    switch (message.option) {
                    default:
                        return "option: enum value expected";
                    case 1:
                        break;
                    }
                return null;
            };

            /**
             * Creates a PrimaryKeySchema message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.PrimaryKeySchema
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.PrimaryKeySchema} PrimaryKeySchema
             */
            PrimaryKeySchema.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.PrimaryKeySchema)
                    return object;
                var message = new $root.main.proto.PrimaryKeySchema();
                if (object.name != null)
                    message.name = String(object.name);
                switch (object.type) {
                case "INTEGER":
                case 1:
                    message.type = 1;
                    break;
                case "STRING":
                case 2:
                    message.type = 2;
                    break;
                case "BINARY":
                case 3:
                    message.type = 3;
                    break;
                }
                switch (object.option) {
                case "AUTO_INCREMENT":
                case 1:
                    message.option = 1;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a PrimaryKeySchema message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.PrimaryKeySchema
             * @static
             * @param {main.proto.PrimaryKeySchema} message PrimaryKeySchema
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PrimaryKeySchema.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.type = options.enums === String ? "INTEGER" : 1;
                    object.option = options.enums === String ? "AUTO_INCREMENT" : 1;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.main.proto.PrimaryKeyType[message.type] : message.type;
                if (message.option != null && message.hasOwnProperty("option"))
                    object.option = options.enums === String ? $root.main.proto.PrimaryKeyOption[message.option] : message.option;
                return object;
            };

            /**
             * Converts this PrimaryKeySchema to JSON.
             * @function toJSON
             * @memberof main.proto.PrimaryKeySchema
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PrimaryKeySchema.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PrimaryKeySchema;
        })();

        proto.DefinedColumnSchema = (function() {

            /**
             * Properties of a DefinedColumnSchema.
             * @memberof main.proto
             * @interface IDefinedColumnSchema
             * @property {string} name DefinedColumnSchema name
             * @property {main.proto.DefinedColumnType} type DefinedColumnSchema type
             */

            /**
             * Constructs a new DefinedColumnSchema.
             * @memberof main.proto
             * @classdesc Represents a DefinedColumnSchema.
             * @implements IDefinedColumnSchema
             * @constructor
             * @param {main.proto.IDefinedColumnSchema=} [properties] Properties to set
             */
            function DefinedColumnSchema(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DefinedColumnSchema name.
             * @member {string} name
             * @memberof main.proto.DefinedColumnSchema
             * @instance
             */
            DefinedColumnSchema.prototype.name = "";

            /**
             * DefinedColumnSchema type.
             * @member {main.proto.DefinedColumnType} type
             * @memberof main.proto.DefinedColumnSchema
             * @instance
             */
            DefinedColumnSchema.prototype.type = 1;

            /**
             * Creates a new DefinedColumnSchema instance using the specified properties.
             * @function create
             * @memberof main.proto.DefinedColumnSchema
             * @static
             * @param {main.proto.IDefinedColumnSchema=} [properties] Properties to set
             * @returns {main.proto.DefinedColumnSchema} DefinedColumnSchema instance
             */
            DefinedColumnSchema.create = function create(properties) {
                return new DefinedColumnSchema(properties);
            };

            /**
             * Encodes the specified DefinedColumnSchema message. Does not implicitly {@link main.proto.DefinedColumnSchema.verify|verify} messages.
             * @function encode
             * @memberof main.proto.DefinedColumnSchema
             * @static
             * @param {main.proto.IDefinedColumnSchema} message DefinedColumnSchema message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DefinedColumnSchema.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                return writer;
            };

            /**
             * Encodes the specified DefinedColumnSchema message, length delimited. Does not implicitly {@link main.proto.DefinedColumnSchema.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.DefinedColumnSchema
             * @static
             * @param {main.proto.IDefinedColumnSchema} message DefinedColumnSchema message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DefinedColumnSchema.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DefinedColumnSchema message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.DefinedColumnSchema
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.DefinedColumnSchema} DefinedColumnSchema
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DefinedColumnSchema.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.DefinedColumnSchema();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.type = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("name"))
                    throw $util.ProtocolError("missing required 'name'", { instance: message });
                if (!message.hasOwnProperty("type"))
                    throw $util.ProtocolError("missing required 'type'", { instance: message });
                return message;
            };

            /**
             * Decodes a DefinedColumnSchema message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.DefinedColumnSchema
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.DefinedColumnSchema} DefinedColumnSchema
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DefinedColumnSchema.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DefinedColumnSchema message.
             * @function verify
             * @memberof main.proto.DefinedColumnSchema
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DefinedColumnSchema.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.name))
                    return "name: string expected";
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 1:
                case 2:
                case 3:
                case 4:
                case 7:
                    break;
                }
                return null;
            };

            /**
             * Creates a DefinedColumnSchema message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.DefinedColumnSchema
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.DefinedColumnSchema} DefinedColumnSchema
             */
            DefinedColumnSchema.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.DefinedColumnSchema)
                    return object;
                var message = new $root.main.proto.DefinedColumnSchema();
                if (object.name != null)
                    message.name = String(object.name);
                switch (object.type) {
                case "DCT_INTEGER":
                case 1:
                    message.type = 1;
                    break;
                case "DCT_DOUBLE":
                case 2:
                    message.type = 2;
                    break;
                case "DCT_BOOLEAN":
                case 3:
                    message.type = 3;
                    break;
                case "DCT_STRING":
                case 4:
                    message.type = 4;
                    break;
                case "DCT_BLOB":
                case 7:
                    message.type = 7;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a DefinedColumnSchema message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.DefinedColumnSchema
             * @static
             * @param {main.proto.DefinedColumnSchema} message DefinedColumnSchema
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DefinedColumnSchema.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.type = options.enums === String ? "DCT_INTEGER" : 1;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.main.proto.DefinedColumnType[message.type] : message.type;
                return object;
            };

            /**
             * Converts this DefinedColumnSchema to JSON.
             * @function toJSON
             * @memberof main.proto.DefinedColumnSchema
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DefinedColumnSchema.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DefinedColumnSchema;
        })();

        proto.PartitionRange = (function() {

            /**
             * Properties of a PartitionRange.
             * @memberof main.proto
             * @interface IPartitionRange
             * @property {Uint8Array} begin PartitionRange begin
             * @property {Uint8Array} end PartitionRange end
             */

            /**
             * Constructs a new PartitionRange.
             * @memberof main.proto
             * @classdesc Represents a PartitionRange.
             * @implements IPartitionRange
             * @constructor
             * @param {main.proto.IPartitionRange=} [properties] Properties to set
             */
            function PartitionRange(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PartitionRange begin.
             * @member {Uint8Array} begin
             * @memberof main.proto.PartitionRange
             * @instance
             */
            PartitionRange.prototype.begin = $util.newBuffer([]);

            /**
             * PartitionRange end.
             * @member {Uint8Array} end
             * @memberof main.proto.PartitionRange
             * @instance
             */
            PartitionRange.prototype.end = $util.newBuffer([]);

            /**
             * Creates a new PartitionRange instance using the specified properties.
             * @function create
             * @memberof main.proto.PartitionRange
             * @static
             * @param {main.proto.IPartitionRange=} [properties] Properties to set
             * @returns {main.proto.PartitionRange} PartitionRange instance
             */
            PartitionRange.create = function create(properties) {
                return new PartitionRange(properties);
            };

            /**
             * Encodes the specified PartitionRange message. Does not implicitly {@link main.proto.PartitionRange.verify|verify} messages.
             * @function encode
             * @memberof main.proto.PartitionRange
             * @static
             * @param {main.proto.IPartitionRange} message PartitionRange message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PartitionRange.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.begin);
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.end);
                return writer;
            };

            /**
             * Encodes the specified PartitionRange message, length delimited. Does not implicitly {@link main.proto.PartitionRange.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.PartitionRange
             * @static
             * @param {main.proto.IPartitionRange} message PartitionRange message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PartitionRange.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PartitionRange message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.PartitionRange
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.PartitionRange} PartitionRange
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PartitionRange.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.PartitionRange();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.begin = reader.bytes();
                        break;
                    case 2:
                        message.end = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("begin"))
                    throw $util.ProtocolError("missing required 'begin'", { instance: message });
                if (!message.hasOwnProperty("end"))
                    throw $util.ProtocolError("missing required 'end'", { instance: message });
                return message;
            };

            /**
             * Decodes a PartitionRange message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.PartitionRange
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.PartitionRange} PartitionRange
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PartitionRange.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PartitionRange message.
             * @function verify
             * @memberof main.proto.PartitionRange
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PartitionRange.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!(message.begin && typeof message.begin.length === "number" || $util.isString(message.begin)))
                    return "begin: buffer expected";
                if (!(message.end && typeof message.end.length === "number" || $util.isString(message.end)))
                    return "end: buffer expected";
                return null;
            };

            /**
             * Creates a PartitionRange message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.PartitionRange
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.PartitionRange} PartitionRange
             */
            PartitionRange.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.PartitionRange)
                    return object;
                var message = new $root.main.proto.PartitionRange();
                if (object.begin != null)
                    if (typeof object.begin === "string")
                        $util.base64.decode(object.begin, message.begin = $util.newBuffer($util.base64.length(object.begin)), 0);
                    else if (object.begin.length)
                        message.begin = object.begin;
                if (object.end != null)
                    if (typeof object.end === "string")
                        $util.base64.decode(object.end, message.end = $util.newBuffer($util.base64.length(object.end)), 0);
                    else if (object.end.length)
                        message.end = object.end;
                return message;
            };

            /**
             * Creates a plain object from a PartitionRange message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.PartitionRange
             * @static
             * @param {main.proto.PartitionRange} message PartitionRange
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PartitionRange.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.begin = "";
                    else {
                        object.begin = [];
                        if (options.bytes !== Array)
                            object.begin = $util.newBuffer(object.begin);
                    }
                    if (options.bytes === String)
                        object.end = "";
                    else {
                        object.end = [];
                        if (options.bytes !== Array)
                            object.end = $util.newBuffer(object.end);
                    }
                }
                if (message.begin != null && message.hasOwnProperty("begin"))
                    object.begin = options.bytes === String ? $util.base64.encode(message.begin, 0, message.begin.length) : options.bytes === Array ? Array.prototype.slice.call(message.begin) : message.begin;
                if (message.end != null && message.hasOwnProperty("end"))
                    object.end = options.bytes === String ? $util.base64.encode(message.end, 0, message.end.length) : options.bytes === Array ? Array.prototype.slice.call(message.end) : message.end;
                return object;
            };

            /**
             * Converts this PartitionRange to JSON.
             * @function toJSON
             * @memberof main.proto.PartitionRange
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PartitionRange.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PartitionRange;
        })();

        /**
         * BloomFilterType enum.
         * @name main.proto.BloomFilterType
         * @enum {number}
         * @property {number} NONE=1 NONE value
         * @property {number} CELL=2 CELL value
         * @property {number} ROW=3 ROW value
         */
        proto.BloomFilterType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "NONE"] = 1;
            values[valuesById[2] = "CELL"] = 2;
            values[valuesById[3] = "ROW"] = 3;
            return values;
        })();

        /**
         * DataBlockType enum.
         * @name main.proto.DataBlockType
         * @enum {number}
         * @property {number} DBT_PLAIN_BUFFER=0 DBT_PLAIN_BUFFER value
         * @property {number} DBT_SIMPLE_ROW_MATRIX=1 DBT_SIMPLE_ROW_MATRIX value
         */
        proto.DataBlockType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "DBT_PLAIN_BUFFER"] = 0;
            values[valuesById[1] = "DBT_SIMPLE_ROW_MATRIX"] = 1;
            return values;
        })();

        /**
         * CompressType enum.
         * @name main.proto.CompressType
         * @enum {number}
         * @property {number} CPT_NONE=0 CPT_NONE value
         */
        proto.CompressType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "CPT_NONE"] = 0;
            return values;
        })();

        proto.TableOptions = (function() {

            /**
             * Properties of a TableOptions.
             * @memberof main.proto
             * @interface ITableOptions
             * @property {number|null} [timeToLive] TableOptions timeToLive
             * @property {number|null} [maxVersions] TableOptions maxVersions
             * @property {main.proto.BloomFilterType|null} [bloomFilterType] TableOptions bloomFilterType
             * @property {number|null} [blockSize] TableOptions blockSize
             * @property {number|Long|null} [deviationCellVersionInSec] TableOptions deviationCellVersionInSec
             * @property {boolean|null} [allowUpdate] TableOptions allowUpdate
             */

            /**
             * Constructs a new TableOptions.
             * @memberof main.proto
             * @classdesc Represents a TableOptions.
             * @implements ITableOptions
             * @constructor
             * @param {main.proto.ITableOptions=} [properties] Properties to set
             */
            function TableOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TableOptions timeToLive.
             * @member {number} timeToLive
             * @memberof main.proto.TableOptions
             * @instance
             */
            TableOptions.prototype.timeToLive = 0;

            /**
             * TableOptions maxVersions.
             * @member {number} maxVersions
             * @memberof main.proto.TableOptions
             * @instance
             */
            TableOptions.prototype.maxVersions = 0;

            /**
             * TableOptions bloomFilterType.
             * @member {main.proto.BloomFilterType} bloomFilterType
             * @memberof main.proto.TableOptions
             * @instance
             */
            TableOptions.prototype.bloomFilterType = 1;

            /**
             * TableOptions blockSize.
             * @member {number} blockSize
             * @memberof main.proto.TableOptions
             * @instance
             */
            TableOptions.prototype.blockSize = 0;

            /**
             * TableOptions deviationCellVersionInSec.
             * @member {number|Long} deviationCellVersionInSec
             * @memberof main.proto.TableOptions
             * @instance
             */
            TableOptions.prototype.deviationCellVersionInSec = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * TableOptions allowUpdate.
             * @member {boolean} allowUpdate
             * @memberof main.proto.TableOptions
             * @instance
             */
            TableOptions.prototype.allowUpdate = false;

            /**
             * Creates a new TableOptions instance using the specified properties.
             * @function create
             * @memberof main.proto.TableOptions
             * @static
             * @param {main.proto.ITableOptions=} [properties] Properties to set
             * @returns {main.proto.TableOptions} TableOptions instance
             */
            TableOptions.create = function create(properties) {
                return new TableOptions(properties);
            };

            /**
             * Encodes the specified TableOptions message. Does not implicitly {@link main.proto.TableOptions.verify|verify} messages.
             * @function encode
             * @memberof main.proto.TableOptions
             * @static
             * @param {main.proto.ITableOptions} message TableOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TableOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.timeToLive != null && Object.hasOwnProperty.call(message, "timeToLive"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.timeToLive);
                if (message.maxVersions != null && Object.hasOwnProperty.call(message, "maxVersions"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.maxVersions);
                if (message.bloomFilterType != null && Object.hasOwnProperty.call(message, "bloomFilterType"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.bloomFilterType);
                if (message.blockSize != null && Object.hasOwnProperty.call(message, "blockSize"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.blockSize);
                if (message.deviationCellVersionInSec != null && Object.hasOwnProperty.call(message, "deviationCellVersionInSec"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.deviationCellVersionInSec);
                if (message.allowUpdate != null && Object.hasOwnProperty.call(message, "allowUpdate"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.allowUpdate);
                return writer;
            };

            /**
             * Encodes the specified TableOptions message, length delimited. Does not implicitly {@link main.proto.TableOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.TableOptions
             * @static
             * @param {main.proto.ITableOptions} message TableOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TableOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TableOptions message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.TableOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.TableOptions} TableOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TableOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.TableOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.timeToLive = reader.int32();
                        break;
                    case 2:
                        message.maxVersions = reader.int32();
                        break;
                    case 3:
                        message.bloomFilterType = reader.int32();
                        break;
                    case 4:
                        message.blockSize = reader.int32();
                        break;
                    case 5:
                        message.deviationCellVersionInSec = reader.int64();
                        break;
                    case 6:
                        message.allowUpdate = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TableOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.TableOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.TableOptions} TableOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TableOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TableOptions message.
             * @function verify
             * @memberof main.proto.TableOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TableOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.timeToLive != null && message.hasOwnProperty("timeToLive"))
                    if (!$util.isInteger(message.timeToLive))
                        return "timeToLive: integer expected";
                if (message.maxVersions != null && message.hasOwnProperty("maxVersions"))
                    if (!$util.isInteger(message.maxVersions))
                        return "maxVersions: integer expected";
                if (message.bloomFilterType != null && message.hasOwnProperty("bloomFilterType"))
                    switch (message.bloomFilterType) {
                    default:
                        return "bloomFilterType: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.blockSize != null && message.hasOwnProperty("blockSize"))
                    if (!$util.isInteger(message.blockSize))
                        return "blockSize: integer expected";
                if (message.deviationCellVersionInSec != null && message.hasOwnProperty("deviationCellVersionInSec"))
                    if (!$util.isInteger(message.deviationCellVersionInSec) && !(message.deviationCellVersionInSec && $util.isInteger(message.deviationCellVersionInSec.low) && $util.isInteger(message.deviationCellVersionInSec.high)))
                        return "deviationCellVersionInSec: integer|Long expected";
                if (message.allowUpdate != null && message.hasOwnProperty("allowUpdate"))
                    if (typeof message.allowUpdate !== "boolean")
                        return "allowUpdate: boolean expected";
                return null;
            };

            /**
             * Creates a TableOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.TableOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.TableOptions} TableOptions
             */
            TableOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.TableOptions)
                    return object;
                var message = new $root.main.proto.TableOptions();
                if (object.timeToLive != null)
                    message.timeToLive = object.timeToLive | 0;
                if (object.maxVersions != null)
                    message.maxVersions = object.maxVersions | 0;
                switch (object.bloomFilterType) {
                case "NONE":
                case 1:
                    message.bloomFilterType = 1;
                    break;
                case "CELL":
                case 2:
                    message.bloomFilterType = 2;
                    break;
                case "ROW":
                case 3:
                    message.bloomFilterType = 3;
                    break;
                }
                if (object.blockSize != null)
                    message.blockSize = object.blockSize | 0;
                if (object.deviationCellVersionInSec != null)
                    if ($util.Long)
                        (message.deviationCellVersionInSec = $util.Long.fromValue(object.deviationCellVersionInSec)).unsigned = false;
                    else if (typeof object.deviationCellVersionInSec === "string")
                        message.deviationCellVersionInSec = parseInt(object.deviationCellVersionInSec, 10);
                    else if (typeof object.deviationCellVersionInSec === "number")
                        message.deviationCellVersionInSec = object.deviationCellVersionInSec;
                    else if (typeof object.deviationCellVersionInSec === "object")
                        message.deviationCellVersionInSec = new $util.LongBits(object.deviationCellVersionInSec.low >>> 0, object.deviationCellVersionInSec.high >>> 0).toNumber();
                if (object.allowUpdate != null)
                    message.allowUpdate = Boolean(object.allowUpdate);
                return message;
            };

            /**
             * Creates a plain object from a TableOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.TableOptions
             * @static
             * @param {main.proto.TableOptions} message TableOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TableOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.timeToLive = 0;
                    object.maxVersions = 0;
                    object.bloomFilterType = options.enums === String ? "NONE" : 1;
                    object.blockSize = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.deviationCellVersionInSec = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.deviationCellVersionInSec = options.longs === String ? "0" : 0;
                    object.allowUpdate = false;
                }
                if (message.timeToLive != null && message.hasOwnProperty("timeToLive"))
                    object.timeToLive = message.timeToLive;
                if (message.maxVersions != null && message.hasOwnProperty("maxVersions"))
                    object.maxVersions = message.maxVersions;
                if (message.bloomFilterType != null && message.hasOwnProperty("bloomFilterType"))
                    object.bloomFilterType = options.enums === String ? $root.main.proto.BloomFilterType[message.bloomFilterType] : message.bloomFilterType;
                if (message.blockSize != null && message.hasOwnProperty("blockSize"))
                    object.blockSize = message.blockSize;
                if (message.deviationCellVersionInSec != null && message.hasOwnProperty("deviationCellVersionInSec"))
                    if (typeof message.deviationCellVersionInSec === "number")
                        object.deviationCellVersionInSec = options.longs === String ? String(message.deviationCellVersionInSec) : message.deviationCellVersionInSec;
                    else
                        object.deviationCellVersionInSec = options.longs === String ? $util.Long.prototype.toString.call(message.deviationCellVersionInSec) : options.longs === Number ? new $util.LongBits(message.deviationCellVersionInSec.low >>> 0, message.deviationCellVersionInSec.high >>> 0).toNumber() : message.deviationCellVersionInSec;
                if (message.allowUpdate != null && message.hasOwnProperty("allowUpdate"))
                    object.allowUpdate = message.allowUpdate;
                return object;
            };

            /**
             * Converts this TableOptions to JSON.
             * @function toJSON
             * @memberof main.proto.TableOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TableOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TableOptions;
        })();

        /**
         * IndexUpdateMode enum.
         * @name main.proto.IndexUpdateMode
         * @enum {number}
         * @property {number} IUM_ASYNC_INDEX=0 IUM_ASYNC_INDEX value
         * @property {number} IUM_SYNC_INDEX=1 IUM_SYNC_INDEX value
         */
        proto.IndexUpdateMode = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "IUM_ASYNC_INDEX"] = 0;
            values[valuesById[1] = "IUM_SYNC_INDEX"] = 1;
            return values;
        })();

        /**
         * IndexType enum.
         * @name main.proto.IndexType
         * @enum {number}
         * @property {number} IT_GLOBAL_INDEX=0 IT_GLOBAL_INDEX value
         * @property {number} IT_LOCAL_INDEX=1 IT_LOCAL_INDEX value
         */
        proto.IndexType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "IT_GLOBAL_INDEX"] = 0;
            values[valuesById[1] = "IT_LOCAL_INDEX"] = 1;
            return values;
        })();

        /**
         * IndexSyncPhase enum.
         * @name main.proto.IndexSyncPhase
         * @enum {number}
         * @property {number} ISP_INVALID=0 ISP_INVALID value
         * @property {number} ISP_FULL=1 ISP_FULL value
         * @property {number} ISP_INCR=2 ISP_INCR value
         */
        proto.IndexSyncPhase = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ISP_INVALID"] = 0;
            values[valuesById[1] = "ISP_FULL"] = 1;
            values[valuesById[2] = "ISP_INCR"] = 2;
            return values;
        })();

        proto.IndexMeta = (function() {

            /**
             * Properties of an IndexMeta.
             * @memberof main.proto
             * @interface IIndexMeta
             * @property {string} name IndexMeta name
             * @property {Array.<string>|null} [primaryKey] IndexMeta primaryKey
             * @property {Array.<string>|null} [definedColumn] IndexMeta definedColumn
             * @property {main.proto.IndexUpdateMode} indexUpdateMode IndexMeta indexUpdateMode
             * @property {main.proto.IndexType} indexType IndexMeta indexType
             * @property {main.proto.IndexSyncPhase|null} [indexSyncPhase] IndexMeta indexSyncPhase
             */

            /**
             * Constructs a new IndexMeta.
             * @memberof main.proto
             * @classdesc Represents an IndexMeta.
             * @implements IIndexMeta
             * @constructor
             * @param {main.proto.IIndexMeta=} [properties] Properties to set
             */
            function IndexMeta(properties) {
                this.primaryKey = [];
                this.definedColumn = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * IndexMeta name.
             * @member {string} name
             * @memberof main.proto.IndexMeta
             * @instance
             */
            IndexMeta.prototype.name = "";

            /**
             * IndexMeta primaryKey.
             * @member {Array.<string>} primaryKey
             * @memberof main.proto.IndexMeta
             * @instance
             */
            IndexMeta.prototype.primaryKey = $util.emptyArray;

            /**
             * IndexMeta definedColumn.
             * @member {Array.<string>} definedColumn
             * @memberof main.proto.IndexMeta
             * @instance
             */
            IndexMeta.prototype.definedColumn = $util.emptyArray;

            /**
             * IndexMeta indexUpdateMode.
             * @member {main.proto.IndexUpdateMode} indexUpdateMode
             * @memberof main.proto.IndexMeta
             * @instance
             */
            IndexMeta.prototype.indexUpdateMode = 0;

            /**
             * IndexMeta indexType.
             * @member {main.proto.IndexType} indexType
             * @memberof main.proto.IndexMeta
             * @instance
             */
            IndexMeta.prototype.indexType = 0;

            /**
             * IndexMeta indexSyncPhase.
             * @member {main.proto.IndexSyncPhase} indexSyncPhase
             * @memberof main.proto.IndexMeta
             * @instance
             */
            IndexMeta.prototype.indexSyncPhase = 0;

            /**
             * Creates a new IndexMeta instance using the specified properties.
             * @function create
             * @memberof main.proto.IndexMeta
             * @static
             * @param {main.proto.IIndexMeta=} [properties] Properties to set
             * @returns {main.proto.IndexMeta} IndexMeta instance
             */
            IndexMeta.create = function create(properties) {
                return new IndexMeta(properties);
            };

            /**
             * Encodes the specified IndexMeta message. Does not implicitly {@link main.proto.IndexMeta.verify|verify} messages.
             * @function encode
             * @memberof main.proto.IndexMeta
             * @static
             * @param {main.proto.IIndexMeta} message IndexMeta message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IndexMeta.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.primaryKey != null && message.primaryKey.length)
                    for (var i = 0; i < message.primaryKey.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.primaryKey[i]);
                if (message.definedColumn != null && message.definedColumn.length)
                    for (var i = 0; i < message.definedColumn.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.definedColumn[i]);
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.indexUpdateMode);
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.indexType);
                if (message.indexSyncPhase != null && Object.hasOwnProperty.call(message, "indexSyncPhase"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.indexSyncPhase);
                return writer;
            };

            /**
             * Encodes the specified IndexMeta message, length delimited. Does not implicitly {@link main.proto.IndexMeta.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.IndexMeta
             * @static
             * @param {main.proto.IIndexMeta} message IndexMeta message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IndexMeta.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an IndexMeta message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.IndexMeta
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.IndexMeta} IndexMeta
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IndexMeta.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.IndexMeta();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (!(message.primaryKey && message.primaryKey.length))
                            message.primaryKey = [];
                        message.primaryKey.push(reader.string());
                        break;
                    case 3:
                        if (!(message.definedColumn && message.definedColumn.length))
                            message.definedColumn = [];
                        message.definedColumn.push(reader.string());
                        break;
                    case 4:
                        message.indexUpdateMode = reader.int32();
                        break;
                    case 5:
                        message.indexType = reader.int32();
                        break;
                    case 6:
                        message.indexSyncPhase = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("name"))
                    throw $util.ProtocolError("missing required 'name'", { instance: message });
                if (!message.hasOwnProperty("indexUpdateMode"))
                    throw $util.ProtocolError("missing required 'indexUpdateMode'", { instance: message });
                if (!message.hasOwnProperty("indexType"))
                    throw $util.ProtocolError("missing required 'indexType'", { instance: message });
                return message;
            };

            /**
             * Decodes an IndexMeta message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.IndexMeta
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.IndexMeta} IndexMeta
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IndexMeta.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an IndexMeta message.
             * @function verify
             * @memberof main.proto.IndexMeta
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            IndexMeta.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.name))
                    return "name: string expected";
                if (message.primaryKey != null && message.hasOwnProperty("primaryKey")) {
                    if (!Array.isArray(message.primaryKey))
                        return "primaryKey: array expected";
                    for (var i = 0; i < message.primaryKey.length; ++i)
                        if (!$util.isString(message.primaryKey[i]))
                            return "primaryKey: string[] expected";
                }
                if (message.definedColumn != null && message.hasOwnProperty("definedColumn")) {
                    if (!Array.isArray(message.definedColumn))
                        return "definedColumn: array expected";
                    for (var i = 0; i < message.definedColumn.length; ++i)
                        if (!$util.isString(message.definedColumn[i]))
                            return "definedColumn: string[] expected";
                }
                switch (message.indexUpdateMode) {
                default:
                    return "indexUpdateMode: enum value expected";
                case 0:
                case 1:
                    break;
                }
                switch (message.indexType) {
                default:
                    return "indexType: enum value expected";
                case 0:
                case 1:
                    break;
                }
                if (message.indexSyncPhase != null && message.hasOwnProperty("indexSyncPhase"))
                    switch (message.indexSyncPhase) {
                    default:
                        return "indexSyncPhase: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };

            /**
             * Creates an IndexMeta message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.IndexMeta
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.IndexMeta} IndexMeta
             */
            IndexMeta.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.IndexMeta)
                    return object;
                var message = new $root.main.proto.IndexMeta();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.primaryKey) {
                    if (!Array.isArray(object.primaryKey))
                        throw TypeError(".main.proto.IndexMeta.primaryKey: array expected");
                    message.primaryKey = [];
                    for (var i = 0; i < object.primaryKey.length; ++i)
                        message.primaryKey[i] = String(object.primaryKey[i]);
                }
                if (object.definedColumn) {
                    if (!Array.isArray(object.definedColumn))
                        throw TypeError(".main.proto.IndexMeta.definedColumn: array expected");
                    message.definedColumn = [];
                    for (var i = 0; i < object.definedColumn.length; ++i)
                        message.definedColumn[i] = String(object.definedColumn[i]);
                }
                switch (object.indexUpdateMode) {
                case "IUM_ASYNC_INDEX":
                case 0:
                    message.indexUpdateMode = 0;
                    break;
                case "IUM_SYNC_INDEX":
                case 1:
                    message.indexUpdateMode = 1;
                    break;
                }
                switch (object.indexType) {
                case "IT_GLOBAL_INDEX":
                case 0:
                    message.indexType = 0;
                    break;
                case "IT_LOCAL_INDEX":
                case 1:
                    message.indexType = 1;
                    break;
                }
                switch (object.indexSyncPhase) {
                case "ISP_INVALID":
                case 0:
                    message.indexSyncPhase = 0;
                    break;
                case "ISP_FULL":
                case 1:
                    message.indexSyncPhase = 1;
                    break;
                case "ISP_INCR":
                case 2:
                    message.indexSyncPhase = 2;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from an IndexMeta message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.IndexMeta
             * @static
             * @param {main.proto.IndexMeta} message IndexMeta
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            IndexMeta.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.primaryKey = [];
                    object.definedColumn = [];
                }
                if (options.defaults) {
                    object.name = "";
                    object.indexUpdateMode = options.enums === String ? "IUM_ASYNC_INDEX" : 0;
                    object.indexType = options.enums === String ? "IT_GLOBAL_INDEX" : 0;
                    object.indexSyncPhase = options.enums === String ? "ISP_INVALID" : 0;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.primaryKey && message.primaryKey.length) {
                    object.primaryKey = [];
                    for (var j = 0; j < message.primaryKey.length; ++j)
                        object.primaryKey[j] = message.primaryKey[j];
                }
                if (message.definedColumn && message.definedColumn.length) {
                    object.definedColumn = [];
                    for (var j = 0; j < message.definedColumn.length; ++j)
                        object.definedColumn[j] = message.definedColumn[j];
                }
                if (message.indexUpdateMode != null && message.hasOwnProperty("indexUpdateMode"))
                    object.indexUpdateMode = options.enums === String ? $root.main.proto.IndexUpdateMode[message.indexUpdateMode] : message.indexUpdateMode;
                if (message.indexType != null && message.hasOwnProperty("indexType"))
                    object.indexType = options.enums === String ? $root.main.proto.IndexType[message.indexType] : message.indexType;
                if (message.indexSyncPhase != null && message.hasOwnProperty("indexSyncPhase"))
                    object.indexSyncPhase = options.enums === String ? $root.main.proto.IndexSyncPhase[message.indexSyncPhase] : message.indexSyncPhase;
                return object;
            };

            /**
             * Converts this IndexMeta to JSON.
             * @function toJSON
             * @memberof main.proto.IndexMeta
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            IndexMeta.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return IndexMeta;
        })();

        proto.TableMeta = (function() {

            /**
             * Properties of a TableMeta.
             * @memberof main.proto
             * @interface ITableMeta
             * @property {string} tableName TableMeta tableName
             * @property {Array.<main.proto.IPrimaryKeySchema>|null} [primaryKey] TableMeta primaryKey
             * @property {Array.<main.proto.IDefinedColumnSchema>|null} [definedColumn] TableMeta definedColumn
             * @property {Array.<main.proto.IIndexMeta>|null} [indexMeta] TableMeta indexMeta
             */

            /**
             * Constructs a new TableMeta.
             * @memberof main.proto
             * @classdesc Represents a TableMeta.
             * @implements ITableMeta
             * @constructor
             * @param {main.proto.ITableMeta=} [properties] Properties to set
             */
            function TableMeta(properties) {
                this.primaryKey = [];
                this.definedColumn = [];
                this.indexMeta = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TableMeta tableName.
             * @member {string} tableName
             * @memberof main.proto.TableMeta
             * @instance
             */
            TableMeta.prototype.tableName = "";

            /**
             * TableMeta primaryKey.
             * @member {Array.<main.proto.IPrimaryKeySchema>} primaryKey
             * @memberof main.proto.TableMeta
             * @instance
             */
            TableMeta.prototype.primaryKey = $util.emptyArray;

            /**
             * TableMeta definedColumn.
             * @member {Array.<main.proto.IDefinedColumnSchema>} definedColumn
             * @memberof main.proto.TableMeta
             * @instance
             */
            TableMeta.prototype.definedColumn = $util.emptyArray;

            /**
             * TableMeta indexMeta.
             * @member {Array.<main.proto.IIndexMeta>} indexMeta
             * @memberof main.proto.TableMeta
             * @instance
             */
            TableMeta.prototype.indexMeta = $util.emptyArray;

            /**
             * Creates a new TableMeta instance using the specified properties.
             * @function create
             * @memberof main.proto.TableMeta
             * @static
             * @param {main.proto.ITableMeta=} [properties] Properties to set
             * @returns {main.proto.TableMeta} TableMeta instance
             */
            TableMeta.create = function create(properties) {
                return new TableMeta(properties);
            };

            /**
             * Encodes the specified TableMeta message. Does not implicitly {@link main.proto.TableMeta.verify|verify} messages.
             * @function encode
             * @memberof main.proto.TableMeta
             * @static
             * @param {main.proto.ITableMeta} message TableMeta message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TableMeta.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.tableName);
                if (message.primaryKey != null && message.primaryKey.length)
                    for (var i = 0; i < message.primaryKey.length; ++i)
                        $root.main.proto.PrimaryKeySchema.encode(message.primaryKey[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.definedColumn != null && message.definedColumn.length)
                    for (var i = 0; i < message.definedColumn.length; ++i)
                        $root.main.proto.DefinedColumnSchema.encode(message.definedColumn[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.indexMeta != null && message.indexMeta.length)
                    for (var i = 0; i < message.indexMeta.length; ++i)
                        $root.main.proto.IndexMeta.encode(message.indexMeta[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified TableMeta message, length delimited. Does not implicitly {@link main.proto.TableMeta.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.TableMeta
             * @static
             * @param {main.proto.ITableMeta} message TableMeta message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TableMeta.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TableMeta message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.TableMeta
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.TableMeta} TableMeta
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TableMeta.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.TableMeta();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tableName = reader.string();
                        break;
                    case 2:
                        if (!(message.primaryKey && message.primaryKey.length))
                            message.primaryKey = [];
                        message.primaryKey.push($root.main.proto.PrimaryKeySchema.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.definedColumn && message.definedColumn.length))
                            message.definedColumn = [];
                        message.definedColumn.push($root.main.proto.DefinedColumnSchema.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.indexMeta && message.indexMeta.length))
                            message.indexMeta = [];
                        message.indexMeta.push($root.main.proto.IndexMeta.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("tableName"))
                    throw $util.ProtocolError("missing required 'tableName'", { instance: message });
                return message;
            };

            /**
             * Decodes a TableMeta message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.TableMeta
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.TableMeta} TableMeta
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TableMeta.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TableMeta message.
             * @function verify
             * @memberof main.proto.TableMeta
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TableMeta.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.tableName))
                    return "tableName: string expected";
                if (message.primaryKey != null && message.hasOwnProperty("primaryKey")) {
                    if (!Array.isArray(message.primaryKey))
                        return "primaryKey: array expected";
                    for (var i = 0; i < message.primaryKey.length; ++i) {
                        var error = $root.main.proto.PrimaryKeySchema.verify(message.primaryKey[i]);
                        if (error)
                            return "primaryKey." + error;
                    }
                }
                if (message.definedColumn != null && message.hasOwnProperty("definedColumn")) {
                    if (!Array.isArray(message.definedColumn))
                        return "definedColumn: array expected";
                    for (var i = 0; i < message.definedColumn.length; ++i) {
                        var error = $root.main.proto.DefinedColumnSchema.verify(message.definedColumn[i]);
                        if (error)
                            return "definedColumn." + error;
                    }
                }
                if (message.indexMeta != null && message.hasOwnProperty("indexMeta")) {
                    if (!Array.isArray(message.indexMeta))
                        return "indexMeta: array expected";
                    for (var i = 0; i < message.indexMeta.length; ++i) {
                        var error = $root.main.proto.IndexMeta.verify(message.indexMeta[i]);
                        if (error)
                            return "indexMeta." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a TableMeta message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.TableMeta
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.TableMeta} TableMeta
             */
            TableMeta.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.TableMeta)
                    return object;
                var message = new $root.main.proto.TableMeta();
                if (object.tableName != null)
                    message.tableName = String(object.tableName);
                if (object.primaryKey) {
                    if (!Array.isArray(object.primaryKey))
                        throw TypeError(".main.proto.TableMeta.primaryKey: array expected");
                    message.primaryKey = [];
                    for (var i = 0; i < object.primaryKey.length; ++i) {
                        if (typeof object.primaryKey[i] !== "object")
                            throw TypeError(".main.proto.TableMeta.primaryKey: object expected");
                        message.primaryKey[i] = $root.main.proto.PrimaryKeySchema.fromObject(object.primaryKey[i]);
                    }
                }
                if (object.definedColumn) {
                    if (!Array.isArray(object.definedColumn))
                        throw TypeError(".main.proto.TableMeta.definedColumn: array expected");
                    message.definedColumn = [];
                    for (var i = 0; i < object.definedColumn.length; ++i) {
                        if (typeof object.definedColumn[i] !== "object")
                            throw TypeError(".main.proto.TableMeta.definedColumn: object expected");
                        message.definedColumn[i] = $root.main.proto.DefinedColumnSchema.fromObject(object.definedColumn[i]);
                    }
                }
                if (object.indexMeta) {
                    if (!Array.isArray(object.indexMeta))
                        throw TypeError(".main.proto.TableMeta.indexMeta: array expected");
                    message.indexMeta = [];
                    for (var i = 0; i < object.indexMeta.length; ++i) {
                        if (typeof object.indexMeta[i] !== "object")
                            throw TypeError(".main.proto.TableMeta.indexMeta: object expected");
                        message.indexMeta[i] = $root.main.proto.IndexMeta.fromObject(object.indexMeta[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a TableMeta message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.TableMeta
             * @static
             * @param {main.proto.TableMeta} message TableMeta
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TableMeta.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.primaryKey = [];
                    object.definedColumn = [];
                    object.indexMeta = [];
                }
                if (options.defaults)
                    object.tableName = "";
                if (message.tableName != null && message.hasOwnProperty("tableName"))
                    object.tableName = message.tableName;
                if (message.primaryKey && message.primaryKey.length) {
                    object.primaryKey = [];
                    for (var j = 0; j < message.primaryKey.length; ++j)
                        object.primaryKey[j] = $root.main.proto.PrimaryKeySchema.toObject(message.primaryKey[j], options);
                }
                if (message.definedColumn && message.definedColumn.length) {
                    object.definedColumn = [];
                    for (var j = 0; j < message.definedColumn.length; ++j)
                        object.definedColumn[j] = $root.main.proto.DefinedColumnSchema.toObject(message.definedColumn[j], options);
                }
                if (message.indexMeta && message.indexMeta.length) {
                    object.indexMeta = [];
                    for (var j = 0; j < message.indexMeta.length; ++j)
                        object.indexMeta[j] = $root.main.proto.IndexMeta.toObject(message.indexMeta[j], options);
                }
                return object;
            };

            /**
             * Converts this TableMeta to JSON.
             * @function toJSON
             * @memberof main.proto.TableMeta
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TableMeta.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TableMeta;
        })();

        /**
         * 表的状态变更只与用户的操作对应，内部的机器failover等状况不对应表的状态变更。
         * 有三个考虑：
         * 一是一般场景下用户只会在做了对表的修改操作后才会去检查表的状态；
         * 二是内部机器failover导致访问异常到用户能够查看到表的状态变更这两个时刻之间会有一段延迟，无法将表的不可服务状态与用户查看到的表的状态完全匹配上。
         * 三是内部机器failover后不能说是表的整个状态变更，而应该是partition的状态变更，对应表的状态就是PARTIAL_FAILOVER，这个partial的粒度无法体现，会让用户更加困惑。
         * @name main.proto.TableStatus
         * @enum {number}
         * @property {number} ACTIVE=1 ACTIVE value
         * @property {number} INACTIVE=2 INACTIVE value
         * @property {number} LOADING=3 LOADING value
         * @property {number} UNLOADING=4 UNLOADING value
         * @property {number} UPDATING=5 UPDATING value
         */
        proto.TableStatus = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "ACTIVE"] = 1;
            values[valuesById[2] = "INACTIVE"] = 2;
            values[valuesById[3] = "LOADING"] = 3;
            values[valuesById[4] = "UNLOADING"] = 4;
            values[valuesById[5] = "UPDATING"] = 5;
            return values;
        })();

        /**
         * RowExistenceExpectation enum.
         * @name main.proto.RowExistenceExpectation
         * @enum {number}
         * @property {number} IGNORE=0 IGNORE value
         * @property {number} EXPECT_EXIST=1 EXPECT_EXIST value
         * @property {number} EXPECT_NOT_EXIST=2 EXPECT_NOT_EXIST value
         */
        proto.RowExistenceExpectation = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "IGNORE"] = 0;
            values[valuesById[1] = "EXPECT_EXIST"] = 1;
            values[valuesById[2] = "EXPECT_NOT_EXIST"] = 2;
            return values;
        })();

        proto.Condition = (function() {

            /**
             * Properties of a Condition.
             * @memberof main.proto
             * @interface ICondition
             * @property {main.proto.RowExistenceExpectation} rowExistence Condition rowExistence
             * @property {Uint8Array|null} [columnCondition] Condition columnCondition
             */

            /**
             * Constructs a new Condition.
             * @memberof main.proto
             * @classdesc Represents a Condition.
             * @implements ICondition
             * @constructor
             * @param {main.proto.ICondition=} [properties] Properties to set
             */
            function Condition(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Condition rowExistence.
             * @member {main.proto.RowExistenceExpectation} rowExistence
             * @memberof main.proto.Condition
             * @instance
             */
            Condition.prototype.rowExistence = 0;

            /**
             * Condition columnCondition.
             * @member {Uint8Array} columnCondition
             * @memberof main.proto.Condition
             * @instance
             */
            Condition.prototype.columnCondition = $util.newBuffer([]);

            /**
             * Creates a new Condition instance using the specified properties.
             * @function create
             * @memberof main.proto.Condition
             * @static
             * @param {main.proto.ICondition=} [properties] Properties to set
             * @returns {main.proto.Condition} Condition instance
             */
            Condition.create = function create(properties) {
                return new Condition(properties);
            };

            /**
             * Encodes the specified Condition message. Does not implicitly {@link main.proto.Condition.verify|verify} messages.
             * @function encode
             * @memberof main.proto.Condition
             * @static
             * @param {main.proto.ICondition} message Condition message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Condition.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.rowExistence);
                if (message.columnCondition != null && Object.hasOwnProperty.call(message, "columnCondition"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.columnCondition);
                return writer;
            };

            /**
             * Encodes the specified Condition message, length delimited. Does not implicitly {@link main.proto.Condition.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.Condition
             * @static
             * @param {main.proto.ICondition} message Condition message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Condition.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Condition message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.Condition
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.Condition} Condition
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Condition.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.Condition();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.rowExistence = reader.int32();
                        break;
                    case 2:
                        message.columnCondition = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("rowExistence"))
                    throw $util.ProtocolError("missing required 'rowExistence'", { instance: message });
                return message;
            };

            /**
             * Decodes a Condition message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.Condition
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.Condition} Condition
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Condition.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Condition message.
             * @function verify
             * @memberof main.proto.Condition
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Condition.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                switch (message.rowExistence) {
                default:
                    return "rowExistence: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
                if (message.columnCondition != null && message.hasOwnProperty("columnCondition"))
                    if (!(message.columnCondition && typeof message.columnCondition.length === "number" || $util.isString(message.columnCondition)))
                        return "columnCondition: buffer expected";
                return null;
            };

            /**
             * Creates a Condition message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.Condition
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.Condition} Condition
             */
            Condition.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.Condition)
                    return object;
                var message = new $root.main.proto.Condition();
                switch (object.rowExistence) {
                case "IGNORE":
                case 0:
                    message.rowExistence = 0;
                    break;
                case "EXPECT_EXIST":
                case 1:
                    message.rowExistence = 1;
                    break;
                case "EXPECT_NOT_EXIST":
                case 2:
                    message.rowExistence = 2;
                    break;
                }
                if (object.columnCondition != null)
                    if (typeof object.columnCondition === "string")
                        $util.base64.decode(object.columnCondition, message.columnCondition = $util.newBuffer($util.base64.length(object.columnCondition)), 0);
                    else if (object.columnCondition.length)
                        message.columnCondition = object.columnCondition;
                return message;
            };

            /**
             * Creates a plain object from a Condition message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.Condition
             * @static
             * @param {main.proto.Condition} message Condition
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Condition.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.rowExistence = options.enums === String ? "IGNORE" : 0;
                    if (options.bytes === String)
                        object.columnCondition = "";
                    else {
                        object.columnCondition = [];
                        if (options.bytes !== Array)
                            object.columnCondition = $util.newBuffer(object.columnCondition);
                    }
                }
                if (message.rowExistence != null && message.hasOwnProperty("rowExistence"))
                    object.rowExistence = options.enums === String ? $root.main.proto.RowExistenceExpectation[message.rowExistence] : message.rowExistence;
                if (message.columnCondition != null && message.hasOwnProperty("columnCondition"))
                    object.columnCondition = options.bytes === String ? $util.base64.encode(message.columnCondition, 0, message.columnCondition.length) : options.bytes === Array ? Array.prototype.slice.call(message.columnCondition) : message.columnCondition;
                return object;
            };

            /**
             * Converts this Condition to JSON.
             * @function toJSON
             * @memberof main.proto.Condition
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Condition.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Condition;
        })();

        proto.CapacityUnit = (function() {

            /**
             * Properties of a CapacityUnit.
             * @memberof main.proto
             * @interface ICapacityUnit
             * @property {number|null} [read] CapacityUnit read
             * @property {number|null} [write] CapacityUnit write
             */

            /**
             * Constructs a new CapacityUnit.
             * @memberof main.proto
             * @classdesc Represents a CapacityUnit.
             * @implements ICapacityUnit
             * @constructor
             * @param {main.proto.ICapacityUnit=} [properties] Properties to set
             */
            function CapacityUnit(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CapacityUnit read.
             * @member {number} read
             * @memberof main.proto.CapacityUnit
             * @instance
             */
            CapacityUnit.prototype.read = 0;

            /**
             * CapacityUnit write.
             * @member {number} write
             * @memberof main.proto.CapacityUnit
             * @instance
             */
            CapacityUnit.prototype.write = 0;

            /**
             * Creates a new CapacityUnit instance using the specified properties.
             * @function create
             * @memberof main.proto.CapacityUnit
             * @static
             * @param {main.proto.ICapacityUnit=} [properties] Properties to set
             * @returns {main.proto.CapacityUnit} CapacityUnit instance
             */
            CapacityUnit.create = function create(properties) {
                return new CapacityUnit(properties);
            };

            /**
             * Encodes the specified CapacityUnit message. Does not implicitly {@link main.proto.CapacityUnit.verify|verify} messages.
             * @function encode
             * @memberof main.proto.CapacityUnit
             * @static
             * @param {main.proto.ICapacityUnit} message CapacityUnit message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CapacityUnit.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.read != null && Object.hasOwnProperty.call(message, "read"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.read);
                if (message.write != null && Object.hasOwnProperty.call(message, "write"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.write);
                return writer;
            };

            /**
             * Encodes the specified CapacityUnit message, length delimited. Does not implicitly {@link main.proto.CapacityUnit.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.CapacityUnit
             * @static
             * @param {main.proto.ICapacityUnit} message CapacityUnit message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CapacityUnit.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CapacityUnit message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.CapacityUnit
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.CapacityUnit} CapacityUnit
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CapacityUnit.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.CapacityUnit();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.read = reader.int32();
                        break;
                    case 2:
                        message.write = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CapacityUnit message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.CapacityUnit
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.CapacityUnit} CapacityUnit
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CapacityUnit.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CapacityUnit message.
             * @function verify
             * @memberof main.proto.CapacityUnit
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CapacityUnit.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.read != null && message.hasOwnProperty("read"))
                    if (!$util.isInteger(message.read))
                        return "read: integer expected";
                if (message.write != null && message.hasOwnProperty("write"))
                    if (!$util.isInteger(message.write))
                        return "write: integer expected";
                return null;
            };

            /**
             * Creates a CapacityUnit message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.CapacityUnit
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.CapacityUnit} CapacityUnit
             */
            CapacityUnit.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.CapacityUnit)
                    return object;
                var message = new $root.main.proto.CapacityUnit();
                if (object.read != null)
                    message.read = object.read | 0;
                if (object.write != null)
                    message.write = object.write | 0;
                return message;
            };

            /**
             * Creates a plain object from a CapacityUnit message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.CapacityUnit
             * @static
             * @param {main.proto.CapacityUnit} message CapacityUnit
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CapacityUnit.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.read = 0;
                    object.write = 0;
                }
                if (message.read != null && message.hasOwnProperty("read"))
                    object.read = message.read;
                if (message.write != null && message.hasOwnProperty("write"))
                    object.write = message.write;
                return object;
            };

            /**
             * Converts this CapacityUnit to JSON.
             * @function toJSON
             * @memberof main.proto.CapacityUnit
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CapacityUnit.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CapacityUnit;
        })();

        proto.ReservedThroughputDetails = (function() {

            /**
             * Properties of a ReservedThroughputDetails.
             * @memberof main.proto
             * @interface IReservedThroughputDetails
             * @property {main.proto.ICapacityUnit} capacityUnit ReservedThroughputDetails capacityUnit
             * @property {number|Long} lastIncreaseTime ReservedThroughputDetails lastIncreaseTime
             * @property {number|Long|null} [lastDecreaseTime] ReservedThroughputDetails lastDecreaseTime
             */

            /**
             * Constructs a new ReservedThroughputDetails.
             * @memberof main.proto
             * @classdesc Represents a ReservedThroughputDetails.
             * @implements IReservedThroughputDetails
             * @constructor
             * @param {main.proto.IReservedThroughputDetails=} [properties] Properties to set
             */
            function ReservedThroughputDetails(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReservedThroughputDetails capacityUnit.
             * @member {main.proto.ICapacityUnit} capacityUnit
             * @memberof main.proto.ReservedThroughputDetails
             * @instance
             */
            ReservedThroughputDetails.prototype.capacityUnit = null;

            /**
             * ReservedThroughputDetails lastIncreaseTime.
             * @member {number|Long} lastIncreaseTime
             * @memberof main.proto.ReservedThroughputDetails
             * @instance
             */
            ReservedThroughputDetails.prototype.lastIncreaseTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * ReservedThroughputDetails lastDecreaseTime.
             * @member {number|Long} lastDecreaseTime
             * @memberof main.proto.ReservedThroughputDetails
             * @instance
             */
            ReservedThroughputDetails.prototype.lastDecreaseTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new ReservedThroughputDetails instance using the specified properties.
             * @function create
             * @memberof main.proto.ReservedThroughputDetails
             * @static
             * @param {main.proto.IReservedThroughputDetails=} [properties] Properties to set
             * @returns {main.proto.ReservedThroughputDetails} ReservedThroughputDetails instance
             */
            ReservedThroughputDetails.create = function create(properties) {
                return new ReservedThroughputDetails(properties);
            };

            /**
             * Encodes the specified ReservedThroughputDetails message. Does not implicitly {@link main.proto.ReservedThroughputDetails.verify|verify} messages.
             * @function encode
             * @memberof main.proto.ReservedThroughputDetails
             * @static
             * @param {main.proto.IReservedThroughputDetails} message ReservedThroughputDetails message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReservedThroughputDetails.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                $root.main.proto.CapacityUnit.encode(message.capacityUnit, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.lastIncreaseTime);
                if (message.lastDecreaseTime != null && Object.hasOwnProperty.call(message, "lastDecreaseTime"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.lastDecreaseTime);
                return writer;
            };

            /**
             * Encodes the specified ReservedThroughputDetails message, length delimited. Does not implicitly {@link main.proto.ReservedThroughputDetails.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.ReservedThroughputDetails
             * @static
             * @param {main.proto.IReservedThroughputDetails} message ReservedThroughputDetails message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReservedThroughputDetails.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReservedThroughputDetails message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.ReservedThroughputDetails
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.ReservedThroughputDetails} ReservedThroughputDetails
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReservedThroughputDetails.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.ReservedThroughputDetails();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.capacityUnit = $root.main.proto.CapacityUnit.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.lastIncreaseTime = reader.int64();
                        break;
                    case 3:
                        message.lastDecreaseTime = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("capacityUnit"))
                    throw $util.ProtocolError("missing required 'capacityUnit'", { instance: message });
                if (!message.hasOwnProperty("lastIncreaseTime"))
                    throw $util.ProtocolError("missing required 'lastIncreaseTime'", { instance: message });
                return message;
            };

            /**
             * Decodes a ReservedThroughputDetails message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.ReservedThroughputDetails
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.ReservedThroughputDetails} ReservedThroughputDetails
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReservedThroughputDetails.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReservedThroughputDetails message.
             * @function verify
             * @memberof main.proto.ReservedThroughputDetails
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReservedThroughputDetails.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                {
                    var error = $root.main.proto.CapacityUnit.verify(message.capacityUnit);
                    if (error)
                        return "capacityUnit." + error;
                }
                if (!$util.isInteger(message.lastIncreaseTime) && !(message.lastIncreaseTime && $util.isInteger(message.lastIncreaseTime.low) && $util.isInteger(message.lastIncreaseTime.high)))
                    return "lastIncreaseTime: integer|Long expected";
                if (message.lastDecreaseTime != null && message.hasOwnProperty("lastDecreaseTime"))
                    if (!$util.isInteger(message.lastDecreaseTime) && !(message.lastDecreaseTime && $util.isInteger(message.lastDecreaseTime.low) && $util.isInteger(message.lastDecreaseTime.high)))
                        return "lastDecreaseTime: integer|Long expected";
                return null;
            };

            /**
             * Creates a ReservedThroughputDetails message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.ReservedThroughputDetails
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.ReservedThroughputDetails} ReservedThroughputDetails
             */
            ReservedThroughputDetails.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.ReservedThroughputDetails)
                    return object;
                var message = new $root.main.proto.ReservedThroughputDetails();
                if (object.capacityUnit != null) {
                    if (typeof object.capacityUnit !== "object")
                        throw TypeError(".main.proto.ReservedThroughputDetails.capacityUnit: object expected");
                    message.capacityUnit = $root.main.proto.CapacityUnit.fromObject(object.capacityUnit);
                }
                if (object.lastIncreaseTime != null)
                    if ($util.Long)
                        (message.lastIncreaseTime = $util.Long.fromValue(object.lastIncreaseTime)).unsigned = false;
                    else if (typeof object.lastIncreaseTime === "string")
                        message.lastIncreaseTime = parseInt(object.lastIncreaseTime, 10);
                    else if (typeof object.lastIncreaseTime === "number")
                        message.lastIncreaseTime = object.lastIncreaseTime;
                    else if (typeof object.lastIncreaseTime === "object")
                        message.lastIncreaseTime = new $util.LongBits(object.lastIncreaseTime.low >>> 0, object.lastIncreaseTime.high >>> 0).toNumber();
                if (object.lastDecreaseTime != null)
                    if ($util.Long)
                        (message.lastDecreaseTime = $util.Long.fromValue(object.lastDecreaseTime)).unsigned = false;
                    else if (typeof object.lastDecreaseTime === "string")
                        message.lastDecreaseTime = parseInt(object.lastDecreaseTime, 10);
                    else if (typeof object.lastDecreaseTime === "number")
                        message.lastDecreaseTime = object.lastDecreaseTime;
                    else if (typeof object.lastDecreaseTime === "object")
                        message.lastDecreaseTime = new $util.LongBits(object.lastDecreaseTime.low >>> 0, object.lastDecreaseTime.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a ReservedThroughputDetails message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.ReservedThroughputDetails
             * @static
             * @param {main.proto.ReservedThroughputDetails} message ReservedThroughputDetails
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReservedThroughputDetails.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.capacityUnit = null;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.lastIncreaseTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.lastIncreaseTime = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.lastDecreaseTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.lastDecreaseTime = options.longs === String ? "0" : 0;
                }
                if (message.capacityUnit != null && message.hasOwnProperty("capacityUnit"))
                    object.capacityUnit = $root.main.proto.CapacityUnit.toObject(message.capacityUnit, options);
                if (message.lastIncreaseTime != null && message.hasOwnProperty("lastIncreaseTime"))
                    if (typeof message.lastIncreaseTime === "number")
                        object.lastIncreaseTime = options.longs === String ? String(message.lastIncreaseTime) : message.lastIncreaseTime;
                    else
                        object.lastIncreaseTime = options.longs === String ? $util.Long.prototype.toString.call(message.lastIncreaseTime) : options.longs === Number ? new $util.LongBits(message.lastIncreaseTime.low >>> 0, message.lastIncreaseTime.high >>> 0).toNumber() : message.lastIncreaseTime;
                if (message.lastDecreaseTime != null && message.hasOwnProperty("lastDecreaseTime"))
                    if (typeof message.lastDecreaseTime === "number")
                        object.lastDecreaseTime = options.longs === String ? String(message.lastDecreaseTime) : message.lastDecreaseTime;
                    else
                        object.lastDecreaseTime = options.longs === String ? $util.Long.prototype.toString.call(message.lastDecreaseTime) : options.longs === Number ? new $util.LongBits(message.lastDecreaseTime.low >>> 0, message.lastDecreaseTime.high >>> 0).toNumber() : message.lastDecreaseTime;
                return object;
            };

            /**
             * Converts this ReservedThroughputDetails to JSON.
             * @function toJSON
             * @memberof main.proto.ReservedThroughputDetails
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReservedThroughputDetails.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReservedThroughputDetails;
        })();

        proto.ReservedThroughput = (function() {

            /**
             * Properties of a ReservedThroughput.
             * @memberof main.proto
             * @interface IReservedThroughput
             * @property {main.proto.ICapacityUnit} capacityUnit ReservedThroughput capacityUnit
             */

            /**
             * Constructs a new ReservedThroughput.
             * @memberof main.proto
             * @classdesc Represents a ReservedThroughput.
             * @implements IReservedThroughput
             * @constructor
             * @param {main.proto.IReservedThroughput=} [properties] Properties to set
             */
            function ReservedThroughput(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReservedThroughput capacityUnit.
             * @member {main.proto.ICapacityUnit} capacityUnit
             * @memberof main.proto.ReservedThroughput
             * @instance
             */
            ReservedThroughput.prototype.capacityUnit = null;

            /**
             * Creates a new ReservedThroughput instance using the specified properties.
             * @function create
             * @memberof main.proto.ReservedThroughput
             * @static
             * @param {main.proto.IReservedThroughput=} [properties] Properties to set
             * @returns {main.proto.ReservedThroughput} ReservedThroughput instance
             */
            ReservedThroughput.create = function create(properties) {
                return new ReservedThroughput(properties);
            };

            /**
             * Encodes the specified ReservedThroughput message. Does not implicitly {@link main.proto.ReservedThroughput.verify|verify} messages.
             * @function encode
             * @memberof main.proto.ReservedThroughput
             * @static
             * @param {main.proto.IReservedThroughput} message ReservedThroughput message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReservedThroughput.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                $root.main.proto.CapacityUnit.encode(message.capacityUnit, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReservedThroughput message, length delimited. Does not implicitly {@link main.proto.ReservedThroughput.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.ReservedThroughput
             * @static
             * @param {main.proto.IReservedThroughput} message ReservedThroughput message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReservedThroughput.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReservedThroughput message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.ReservedThroughput
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.ReservedThroughput} ReservedThroughput
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReservedThroughput.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.ReservedThroughput();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.capacityUnit = $root.main.proto.CapacityUnit.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("capacityUnit"))
                    throw $util.ProtocolError("missing required 'capacityUnit'", { instance: message });
                return message;
            };

            /**
             * Decodes a ReservedThroughput message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.ReservedThroughput
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.ReservedThroughput} ReservedThroughput
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReservedThroughput.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReservedThroughput message.
             * @function verify
             * @memberof main.proto.ReservedThroughput
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReservedThroughput.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                {
                    var error = $root.main.proto.CapacityUnit.verify(message.capacityUnit);
                    if (error)
                        return "capacityUnit." + error;
                }
                return null;
            };

            /**
             * Creates a ReservedThroughput message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.ReservedThroughput
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.ReservedThroughput} ReservedThroughput
             */
            ReservedThroughput.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.ReservedThroughput)
                    return object;
                var message = new $root.main.proto.ReservedThroughput();
                if (object.capacityUnit != null) {
                    if (typeof object.capacityUnit !== "object")
                        throw TypeError(".main.proto.ReservedThroughput.capacityUnit: object expected");
                    message.capacityUnit = $root.main.proto.CapacityUnit.fromObject(object.capacityUnit);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReservedThroughput message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.ReservedThroughput
             * @static
             * @param {main.proto.ReservedThroughput} message ReservedThroughput
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReservedThroughput.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.capacityUnit = null;
                if (message.capacityUnit != null && message.hasOwnProperty("capacityUnit"))
                    object.capacityUnit = $root.main.proto.CapacityUnit.toObject(message.capacityUnit, options);
                return object;
            };

            /**
             * Converts this ReservedThroughput to JSON.
             * @function toJSON
             * @memberof main.proto.ReservedThroughput
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReservedThroughput.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReservedThroughput;
        })();

        proto.ConsumedCapacity = (function() {

            /**
             * Properties of a ConsumedCapacity.
             * @memberof main.proto
             * @interface IConsumedCapacity
             * @property {main.proto.ICapacityUnit} capacityUnit ConsumedCapacity capacityUnit
             */

            /**
             * Constructs a new ConsumedCapacity.
             * @memberof main.proto
             * @classdesc Represents a ConsumedCapacity.
             * @implements IConsumedCapacity
             * @constructor
             * @param {main.proto.IConsumedCapacity=} [properties] Properties to set
             */
            function ConsumedCapacity(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ConsumedCapacity capacityUnit.
             * @member {main.proto.ICapacityUnit} capacityUnit
             * @memberof main.proto.ConsumedCapacity
             * @instance
             */
            ConsumedCapacity.prototype.capacityUnit = null;

            /**
             * Creates a new ConsumedCapacity instance using the specified properties.
             * @function create
             * @memberof main.proto.ConsumedCapacity
             * @static
             * @param {main.proto.IConsumedCapacity=} [properties] Properties to set
             * @returns {main.proto.ConsumedCapacity} ConsumedCapacity instance
             */
            ConsumedCapacity.create = function create(properties) {
                return new ConsumedCapacity(properties);
            };

            /**
             * Encodes the specified ConsumedCapacity message. Does not implicitly {@link main.proto.ConsumedCapacity.verify|verify} messages.
             * @function encode
             * @memberof main.proto.ConsumedCapacity
             * @static
             * @param {main.proto.IConsumedCapacity} message ConsumedCapacity message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConsumedCapacity.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                $root.main.proto.CapacityUnit.encode(message.capacityUnit, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ConsumedCapacity message, length delimited. Does not implicitly {@link main.proto.ConsumedCapacity.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.ConsumedCapacity
             * @static
             * @param {main.proto.IConsumedCapacity} message ConsumedCapacity message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConsumedCapacity.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ConsumedCapacity message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.ConsumedCapacity
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.ConsumedCapacity} ConsumedCapacity
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConsumedCapacity.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.ConsumedCapacity();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.capacityUnit = $root.main.proto.CapacityUnit.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("capacityUnit"))
                    throw $util.ProtocolError("missing required 'capacityUnit'", { instance: message });
                return message;
            };

            /**
             * Decodes a ConsumedCapacity message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.ConsumedCapacity
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.ConsumedCapacity} ConsumedCapacity
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConsumedCapacity.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ConsumedCapacity message.
             * @function verify
             * @memberof main.proto.ConsumedCapacity
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConsumedCapacity.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                {
                    var error = $root.main.proto.CapacityUnit.verify(message.capacityUnit);
                    if (error)
                        return "capacityUnit." + error;
                }
                return null;
            };

            /**
             * Creates a ConsumedCapacity message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.ConsumedCapacity
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.ConsumedCapacity} ConsumedCapacity
             */
            ConsumedCapacity.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.ConsumedCapacity)
                    return object;
                var message = new $root.main.proto.ConsumedCapacity();
                if (object.capacityUnit != null) {
                    if (typeof object.capacityUnit !== "object")
                        throw TypeError(".main.proto.ConsumedCapacity.capacityUnit: object expected");
                    message.capacityUnit = $root.main.proto.CapacityUnit.fromObject(object.capacityUnit);
                }
                return message;
            };

            /**
             * Creates a plain object from a ConsumedCapacity message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.ConsumedCapacity
             * @static
             * @param {main.proto.ConsumedCapacity} message ConsumedCapacity
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConsumedCapacity.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.capacityUnit = null;
                if (message.capacityUnit != null && message.hasOwnProperty("capacityUnit"))
                    object.capacityUnit = $root.main.proto.CapacityUnit.toObject(message.capacityUnit, options);
                return object;
            };

            /**
             * Converts this ConsumedCapacity to JSON.
             * @function toJSON
             * @memberof main.proto.ConsumedCapacity
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConsumedCapacity.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ConsumedCapacity;
        })();

        proto.StreamSpecification = (function() {

            /**
             * Properties of a StreamSpecification.
             * @memberof main.proto
             * @interface IStreamSpecification
             * @property {boolean} enableStream StreamSpecification enableStream
             * @property {number|null} [expirationTime] StreamSpecification expirationTime
             */

            /**
             * Constructs a new StreamSpecification.
             * @memberof main.proto
             * @classdesc Represents a StreamSpecification.
             * @implements IStreamSpecification
             * @constructor
             * @param {main.proto.IStreamSpecification=} [properties] Properties to set
             */
            function StreamSpecification(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StreamSpecification enableStream.
             * @member {boolean} enableStream
             * @memberof main.proto.StreamSpecification
             * @instance
             */
            StreamSpecification.prototype.enableStream = false;

            /**
             * StreamSpecification expirationTime.
             * @member {number} expirationTime
             * @memberof main.proto.StreamSpecification
             * @instance
             */
            StreamSpecification.prototype.expirationTime = 0;

            /**
             * Creates a new StreamSpecification instance using the specified properties.
             * @function create
             * @memberof main.proto.StreamSpecification
             * @static
             * @param {main.proto.IStreamSpecification=} [properties] Properties to set
             * @returns {main.proto.StreamSpecification} StreamSpecification instance
             */
            StreamSpecification.create = function create(properties) {
                return new StreamSpecification(properties);
            };

            /**
             * Encodes the specified StreamSpecification message. Does not implicitly {@link main.proto.StreamSpecification.verify|verify} messages.
             * @function encode
             * @memberof main.proto.StreamSpecification
             * @static
             * @param {main.proto.IStreamSpecification} message StreamSpecification message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StreamSpecification.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.enableStream);
                if (message.expirationTime != null && Object.hasOwnProperty.call(message, "expirationTime"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.expirationTime);
                return writer;
            };

            /**
             * Encodes the specified StreamSpecification message, length delimited. Does not implicitly {@link main.proto.StreamSpecification.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.StreamSpecification
             * @static
             * @param {main.proto.IStreamSpecification} message StreamSpecification message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StreamSpecification.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StreamSpecification message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.StreamSpecification
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.StreamSpecification} StreamSpecification
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StreamSpecification.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.StreamSpecification();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.enableStream = reader.bool();
                        break;
                    case 2:
                        message.expirationTime = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("enableStream"))
                    throw $util.ProtocolError("missing required 'enableStream'", { instance: message });
                return message;
            };

            /**
             * Decodes a StreamSpecification message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.StreamSpecification
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.StreamSpecification} StreamSpecification
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StreamSpecification.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StreamSpecification message.
             * @function verify
             * @memberof main.proto.StreamSpecification
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StreamSpecification.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (typeof message.enableStream !== "boolean")
                    return "enableStream: boolean expected";
                if (message.expirationTime != null && message.hasOwnProperty("expirationTime"))
                    if (!$util.isInteger(message.expirationTime))
                        return "expirationTime: integer expected";
                return null;
            };

            /**
             * Creates a StreamSpecification message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.StreamSpecification
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.StreamSpecification} StreamSpecification
             */
            StreamSpecification.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.StreamSpecification)
                    return object;
                var message = new $root.main.proto.StreamSpecification();
                if (object.enableStream != null)
                    message.enableStream = Boolean(object.enableStream);
                if (object.expirationTime != null)
                    message.expirationTime = object.expirationTime | 0;
                return message;
            };

            /**
             * Creates a plain object from a StreamSpecification message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.StreamSpecification
             * @static
             * @param {main.proto.StreamSpecification} message StreamSpecification
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StreamSpecification.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.enableStream = false;
                    object.expirationTime = 0;
                }
                if (message.enableStream != null && message.hasOwnProperty("enableStream"))
                    object.enableStream = message.enableStream;
                if (message.expirationTime != null && message.hasOwnProperty("expirationTime"))
                    object.expirationTime = message.expirationTime;
                return object;
            };

            /**
             * Converts this StreamSpecification to JSON.
             * @function toJSON
             * @memberof main.proto.StreamSpecification
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StreamSpecification.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StreamSpecification;
        })();

        proto.StreamDetails = (function() {

            /**
             * Properties of a StreamDetails.
             * @memberof main.proto
             * @interface IStreamDetails
             * @property {boolean} enableStream StreamDetails enableStream
             * @property {string|null} [streamId] StreamDetails streamId
             * @property {number|null} [expirationTime] StreamDetails expirationTime
             * @property {number|Long|null} [lastEnableTime] StreamDetails lastEnableTime
             */

            /**
             * Constructs a new StreamDetails.
             * @memberof main.proto
             * @classdesc Represents a StreamDetails.
             * @implements IStreamDetails
             * @constructor
             * @param {main.proto.IStreamDetails=} [properties] Properties to set
             */
            function StreamDetails(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StreamDetails enableStream.
             * @member {boolean} enableStream
             * @memberof main.proto.StreamDetails
             * @instance
             */
            StreamDetails.prototype.enableStream = false;

            /**
             * StreamDetails streamId.
             * @member {string} streamId
             * @memberof main.proto.StreamDetails
             * @instance
             */
            StreamDetails.prototype.streamId = "";

            /**
             * StreamDetails expirationTime.
             * @member {number} expirationTime
             * @memberof main.proto.StreamDetails
             * @instance
             */
            StreamDetails.prototype.expirationTime = 0;

            /**
             * StreamDetails lastEnableTime.
             * @member {number|Long} lastEnableTime
             * @memberof main.proto.StreamDetails
             * @instance
             */
            StreamDetails.prototype.lastEnableTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new StreamDetails instance using the specified properties.
             * @function create
             * @memberof main.proto.StreamDetails
             * @static
             * @param {main.proto.IStreamDetails=} [properties] Properties to set
             * @returns {main.proto.StreamDetails} StreamDetails instance
             */
            StreamDetails.create = function create(properties) {
                return new StreamDetails(properties);
            };

            /**
             * Encodes the specified StreamDetails message. Does not implicitly {@link main.proto.StreamDetails.verify|verify} messages.
             * @function encode
             * @memberof main.proto.StreamDetails
             * @static
             * @param {main.proto.IStreamDetails} message StreamDetails message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StreamDetails.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.enableStream);
                if (message.streamId != null && Object.hasOwnProperty.call(message, "streamId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.streamId);
                if (message.expirationTime != null && Object.hasOwnProperty.call(message, "expirationTime"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.expirationTime);
                if (message.lastEnableTime != null && Object.hasOwnProperty.call(message, "lastEnableTime"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.lastEnableTime);
                return writer;
            };

            /**
             * Encodes the specified StreamDetails message, length delimited. Does not implicitly {@link main.proto.StreamDetails.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.StreamDetails
             * @static
             * @param {main.proto.IStreamDetails} message StreamDetails message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StreamDetails.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StreamDetails message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.StreamDetails
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.StreamDetails} StreamDetails
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StreamDetails.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.StreamDetails();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.enableStream = reader.bool();
                        break;
                    case 2:
                        message.streamId = reader.string();
                        break;
                    case 3:
                        message.expirationTime = reader.int32();
                        break;
                    case 4:
                        message.lastEnableTime = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("enableStream"))
                    throw $util.ProtocolError("missing required 'enableStream'", { instance: message });
                return message;
            };

            /**
             * Decodes a StreamDetails message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.StreamDetails
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.StreamDetails} StreamDetails
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StreamDetails.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StreamDetails message.
             * @function verify
             * @memberof main.proto.StreamDetails
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StreamDetails.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (typeof message.enableStream !== "boolean")
                    return "enableStream: boolean expected";
                if (message.streamId != null && message.hasOwnProperty("streamId"))
                    if (!$util.isString(message.streamId))
                        return "streamId: string expected";
                if (message.expirationTime != null && message.hasOwnProperty("expirationTime"))
                    if (!$util.isInteger(message.expirationTime))
                        return "expirationTime: integer expected";
                if (message.lastEnableTime != null && message.hasOwnProperty("lastEnableTime"))
                    if (!$util.isInteger(message.lastEnableTime) && !(message.lastEnableTime && $util.isInteger(message.lastEnableTime.low) && $util.isInteger(message.lastEnableTime.high)))
                        return "lastEnableTime: integer|Long expected";
                return null;
            };

            /**
             * Creates a StreamDetails message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.StreamDetails
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.StreamDetails} StreamDetails
             */
            StreamDetails.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.StreamDetails)
                    return object;
                var message = new $root.main.proto.StreamDetails();
                if (object.enableStream != null)
                    message.enableStream = Boolean(object.enableStream);
                if (object.streamId != null)
                    message.streamId = String(object.streamId);
                if (object.expirationTime != null)
                    message.expirationTime = object.expirationTime | 0;
                if (object.lastEnableTime != null)
                    if ($util.Long)
                        (message.lastEnableTime = $util.Long.fromValue(object.lastEnableTime)).unsigned = false;
                    else if (typeof object.lastEnableTime === "string")
                        message.lastEnableTime = parseInt(object.lastEnableTime, 10);
                    else if (typeof object.lastEnableTime === "number")
                        message.lastEnableTime = object.lastEnableTime;
                    else if (typeof object.lastEnableTime === "object")
                        message.lastEnableTime = new $util.LongBits(object.lastEnableTime.low >>> 0, object.lastEnableTime.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a StreamDetails message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.StreamDetails
             * @static
             * @param {main.proto.StreamDetails} message StreamDetails
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StreamDetails.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.enableStream = false;
                    object.streamId = "";
                    object.expirationTime = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.lastEnableTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.lastEnableTime = options.longs === String ? "0" : 0;
                }
                if (message.enableStream != null && message.hasOwnProperty("enableStream"))
                    object.enableStream = message.enableStream;
                if (message.streamId != null && message.hasOwnProperty("streamId"))
                    object.streamId = message.streamId;
                if (message.expirationTime != null && message.hasOwnProperty("expirationTime"))
                    object.expirationTime = message.expirationTime;
                if (message.lastEnableTime != null && message.hasOwnProperty("lastEnableTime"))
                    if (typeof message.lastEnableTime === "number")
                        object.lastEnableTime = options.longs === String ? String(message.lastEnableTime) : message.lastEnableTime;
                    else
                        object.lastEnableTime = options.longs === String ? $util.Long.prototype.toString.call(message.lastEnableTime) : options.longs === Number ? new $util.LongBits(message.lastEnableTime.low >>> 0, message.lastEnableTime.high >>> 0).toNumber() : message.lastEnableTime;
                return object;
            };

            /**
             * Converts this StreamDetails to JSON.
             * @function toJSON
             * @memberof main.proto.StreamDetails
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StreamDetails.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StreamDetails;
        })();

        proto.CreateTableRequest = (function() {

            /**
             * Properties of a CreateTableRequest.
             * @memberof main.proto
             * @interface ICreateTableRequest
             * @property {main.proto.ITableMeta} tableMeta CreateTableRequest tableMeta
             * @property {main.proto.IReservedThroughput} reservedThroughput CreateTableRequest reservedThroughput
             * @property {main.proto.ITableOptions|null} [tableOptions] CreateTableRequest tableOptions
             * @property {Array.<main.proto.IPartitionRange>|null} [partitions] CreateTableRequest partitions
             * @property {main.proto.IStreamSpecification|null} [streamSpec] CreateTableRequest streamSpec
             * @property {Array.<main.proto.IIndexMeta>|null} [indexMetas] CreateTableRequest indexMetas
             */

            /**
             * Constructs a new CreateTableRequest.
             * @memberof main.proto
             * @classdesc table_meta用于存储表中不可更改的schema属性，可以更改的ReservedThroughput和TableOptions独立出来，作为UpdateTable的参数。
             * 加入GlobalIndex和LocalIndex之后，结构会变为：
             * message CreateTableRequest {
             * required TableMeta table_meta = 1;
             * required ReservedThroughput reserved_throughput = 2;
             * required TableOptions table_options = 3;
             * repeated LocalIndex local_indexes = 4; // LocalIndex不再单独包含ReservedThroughput和TableOptions，其与主表共享配置。
             * repeated GlobalIndex global_indexes = 5; // GlobalIndex内单独包含ReservedThroughput和TableOptions
             * }
             * @implements ICreateTableRequest
             * @constructor
             * @param {main.proto.ICreateTableRequest=} [properties] Properties to set
             */
            function CreateTableRequest(properties) {
                this.partitions = [];
                this.indexMetas = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreateTableRequest tableMeta.
             * @member {main.proto.ITableMeta} tableMeta
             * @memberof main.proto.CreateTableRequest
             * @instance
             */
            CreateTableRequest.prototype.tableMeta = null;

            /**
             * CreateTableRequest reservedThroughput.
             * @member {main.proto.IReservedThroughput} reservedThroughput
             * @memberof main.proto.CreateTableRequest
             * @instance
             */
            CreateTableRequest.prototype.reservedThroughput = null;

            /**
             * CreateTableRequest tableOptions.
             * @member {main.proto.ITableOptions|null|undefined} tableOptions
             * @memberof main.proto.CreateTableRequest
             * @instance
             */
            CreateTableRequest.prototype.tableOptions = null;

            /**
             * CreateTableRequest partitions.
             * @member {Array.<main.proto.IPartitionRange>} partitions
             * @memberof main.proto.CreateTableRequest
             * @instance
             */
            CreateTableRequest.prototype.partitions = $util.emptyArray;

            /**
             * CreateTableRequest streamSpec.
             * @member {main.proto.IStreamSpecification|null|undefined} streamSpec
             * @memberof main.proto.CreateTableRequest
             * @instance
             */
            CreateTableRequest.prototype.streamSpec = null;

            /**
             * CreateTableRequest indexMetas.
             * @member {Array.<main.proto.IIndexMeta>} indexMetas
             * @memberof main.proto.CreateTableRequest
             * @instance
             */
            CreateTableRequest.prototype.indexMetas = $util.emptyArray;

            /**
             * Creates a new CreateTableRequest instance using the specified properties.
             * @function create
             * @memberof main.proto.CreateTableRequest
             * @static
             * @param {main.proto.ICreateTableRequest=} [properties] Properties to set
             * @returns {main.proto.CreateTableRequest} CreateTableRequest instance
             */
            CreateTableRequest.create = function create(properties) {
                return new CreateTableRequest(properties);
            };

            /**
             * Encodes the specified CreateTableRequest message. Does not implicitly {@link main.proto.CreateTableRequest.verify|verify} messages.
             * @function encode
             * @memberof main.proto.CreateTableRequest
             * @static
             * @param {main.proto.ICreateTableRequest} message CreateTableRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateTableRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                $root.main.proto.TableMeta.encode(message.tableMeta, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                $root.main.proto.ReservedThroughput.encode(message.reservedThroughput, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.tableOptions != null && Object.hasOwnProperty.call(message, "tableOptions"))
                    $root.main.proto.TableOptions.encode(message.tableOptions, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.partitions != null && message.partitions.length)
                    for (var i = 0; i < message.partitions.length; ++i)
                        $root.main.proto.PartitionRange.encode(message.partitions[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.streamSpec != null && Object.hasOwnProperty.call(message, "streamSpec"))
                    $root.main.proto.StreamSpecification.encode(message.streamSpec, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.indexMetas != null && message.indexMetas.length)
                    for (var i = 0; i < message.indexMetas.length; ++i)
                        $root.main.proto.IndexMeta.encode(message.indexMetas[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CreateTableRequest message, length delimited. Does not implicitly {@link main.proto.CreateTableRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.CreateTableRequest
             * @static
             * @param {main.proto.ICreateTableRequest} message CreateTableRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateTableRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateTableRequest message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.CreateTableRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.CreateTableRequest} CreateTableRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateTableRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.CreateTableRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tableMeta = $root.main.proto.TableMeta.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.reservedThroughput = $root.main.proto.ReservedThroughput.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.tableOptions = $root.main.proto.TableOptions.decode(reader, reader.uint32());
                        break;
                    case 4:
                        if (!(message.partitions && message.partitions.length))
                            message.partitions = [];
                        message.partitions.push($root.main.proto.PartitionRange.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        message.streamSpec = $root.main.proto.StreamSpecification.decode(reader, reader.uint32());
                        break;
                    case 7:
                        if (!(message.indexMetas && message.indexMetas.length))
                            message.indexMetas = [];
                        message.indexMetas.push($root.main.proto.IndexMeta.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("tableMeta"))
                    throw $util.ProtocolError("missing required 'tableMeta'", { instance: message });
                if (!message.hasOwnProperty("reservedThroughput"))
                    throw $util.ProtocolError("missing required 'reservedThroughput'", { instance: message });
                return message;
            };

            /**
             * Decodes a CreateTableRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.CreateTableRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.CreateTableRequest} CreateTableRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateTableRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateTableRequest message.
             * @function verify
             * @memberof main.proto.CreateTableRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateTableRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                {
                    var error = $root.main.proto.TableMeta.verify(message.tableMeta);
                    if (error)
                        return "tableMeta." + error;
                }
                {
                    var error = $root.main.proto.ReservedThroughput.verify(message.reservedThroughput);
                    if (error)
                        return "reservedThroughput." + error;
                }
                if (message.tableOptions != null && message.hasOwnProperty("tableOptions")) {
                    var error = $root.main.proto.TableOptions.verify(message.tableOptions);
                    if (error)
                        return "tableOptions." + error;
                }
                if (message.partitions != null && message.hasOwnProperty("partitions")) {
                    if (!Array.isArray(message.partitions))
                        return "partitions: array expected";
                    for (var i = 0; i < message.partitions.length; ++i) {
                        var error = $root.main.proto.PartitionRange.verify(message.partitions[i]);
                        if (error)
                            return "partitions." + error;
                    }
                }
                if (message.streamSpec != null && message.hasOwnProperty("streamSpec")) {
                    var error = $root.main.proto.StreamSpecification.verify(message.streamSpec);
                    if (error)
                        return "streamSpec." + error;
                }
                if (message.indexMetas != null && message.hasOwnProperty("indexMetas")) {
                    if (!Array.isArray(message.indexMetas))
                        return "indexMetas: array expected";
                    for (var i = 0; i < message.indexMetas.length; ++i) {
                        var error = $root.main.proto.IndexMeta.verify(message.indexMetas[i]);
                        if (error)
                            return "indexMetas." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a CreateTableRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.CreateTableRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.CreateTableRequest} CreateTableRequest
             */
            CreateTableRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.CreateTableRequest)
                    return object;
                var message = new $root.main.proto.CreateTableRequest();
                if (object.tableMeta != null) {
                    if (typeof object.tableMeta !== "object")
                        throw TypeError(".main.proto.CreateTableRequest.tableMeta: object expected");
                    message.tableMeta = $root.main.proto.TableMeta.fromObject(object.tableMeta);
                }
                if (object.reservedThroughput != null) {
                    if (typeof object.reservedThroughput !== "object")
                        throw TypeError(".main.proto.CreateTableRequest.reservedThroughput: object expected");
                    message.reservedThroughput = $root.main.proto.ReservedThroughput.fromObject(object.reservedThroughput);
                }
                if (object.tableOptions != null) {
                    if (typeof object.tableOptions !== "object")
                        throw TypeError(".main.proto.CreateTableRequest.tableOptions: object expected");
                    message.tableOptions = $root.main.proto.TableOptions.fromObject(object.tableOptions);
                }
                if (object.partitions) {
                    if (!Array.isArray(object.partitions))
                        throw TypeError(".main.proto.CreateTableRequest.partitions: array expected");
                    message.partitions = [];
                    for (var i = 0; i < object.partitions.length; ++i) {
                        if (typeof object.partitions[i] !== "object")
                            throw TypeError(".main.proto.CreateTableRequest.partitions: object expected");
                        message.partitions[i] = $root.main.proto.PartitionRange.fromObject(object.partitions[i]);
                    }
                }
                if (object.streamSpec != null) {
                    if (typeof object.streamSpec !== "object")
                        throw TypeError(".main.proto.CreateTableRequest.streamSpec: object expected");
                    message.streamSpec = $root.main.proto.StreamSpecification.fromObject(object.streamSpec);
                }
                if (object.indexMetas) {
                    if (!Array.isArray(object.indexMetas))
                        throw TypeError(".main.proto.CreateTableRequest.indexMetas: array expected");
                    message.indexMetas = [];
                    for (var i = 0; i < object.indexMetas.length; ++i) {
                        if (typeof object.indexMetas[i] !== "object")
                            throw TypeError(".main.proto.CreateTableRequest.indexMetas: object expected");
                        message.indexMetas[i] = $root.main.proto.IndexMeta.fromObject(object.indexMetas[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a CreateTableRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.CreateTableRequest
             * @static
             * @param {main.proto.CreateTableRequest} message CreateTableRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateTableRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.partitions = [];
                    object.indexMetas = [];
                }
                if (options.defaults) {
                    object.tableMeta = null;
                    object.reservedThroughput = null;
                    object.tableOptions = null;
                    object.streamSpec = null;
                }
                if (message.tableMeta != null && message.hasOwnProperty("tableMeta"))
                    object.tableMeta = $root.main.proto.TableMeta.toObject(message.tableMeta, options);
                if (message.reservedThroughput != null && message.hasOwnProperty("reservedThroughput"))
                    object.reservedThroughput = $root.main.proto.ReservedThroughput.toObject(message.reservedThroughput, options);
                if (message.tableOptions != null && message.hasOwnProperty("tableOptions"))
                    object.tableOptions = $root.main.proto.TableOptions.toObject(message.tableOptions, options);
                if (message.partitions && message.partitions.length) {
                    object.partitions = [];
                    for (var j = 0; j < message.partitions.length; ++j)
                        object.partitions[j] = $root.main.proto.PartitionRange.toObject(message.partitions[j], options);
                }
                if (message.streamSpec != null && message.hasOwnProperty("streamSpec"))
                    object.streamSpec = $root.main.proto.StreamSpecification.toObject(message.streamSpec, options);
                if (message.indexMetas && message.indexMetas.length) {
                    object.indexMetas = [];
                    for (var j = 0; j < message.indexMetas.length; ++j)
                        object.indexMetas[j] = $root.main.proto.IndexMeta.toObject(message.indexMetas[j], options);
                }
                return object;
            };

            /**
             * Converts this CreateTableRequest to JSON.
             * @function toJSON
             * @memberof main.proto.CreateTableRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateTableRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CreateTableRequest;
        })();

        proto.CreateTableResponse = (function() {

            /**
             * Properties of a CreateTableResponse.
             * @memberof main.proto
             * @interface ICreateTableResponse
             */

            /**
             * Constructs a new CreateTableResponse.
             * @memberof main.proto
             * @classdesc Represents a CreateTableResponse.
             * @implements ICreateTableResponse
             * @constructor
             * @param {main.proto.ICreateTableResponse=} [properties] Properties to set
             */
            function CreateTableResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new CreateTableResponse instance using the specified properties.
             * @function create
             * @memberof main.proto.CreateTableResponse
             * @static
             * @param {main.proto.ICreateTableResponse=} [properties] Properties to set
             * @returns {main.proto.CreateTableResponse} CreateTableResponse instance
             */
            CreateTableResponse.create = function create(properties) {
                return new CreateTableResponse(properties);
            };

            /**
             * Encodes the specified CreateTableResponse message. Does not implicitly {@link main.proto.CreateTableResponse.verify|verify} messages.
             * @function encode
             * @memberof main.proto.CreateTableResponse
             * @static
             * @param {main.proto.ICreateTableResponse} message CreateTableResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateTableResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified CreateTableResponse message, length delimited. Does not implicitly {@link main.proto.CreateTableResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.CreateTableResponse
             * @static
             * @param {main.proto.ICreateTableResponse} message CreateTableResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateTableResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateTableResponse message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.CreateTableResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.CreateTableResponse} CreateTableResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateTableResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.CreateTableResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CreateTableResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.CreateTableResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.CreateTableResponse} CreateTableResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateTableResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateTableResponse message.
             * @function verify
             * @memberof main.proto.CreateTableResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateTableResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a CreateTableResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.CreateTableResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.CreateTableResponse} CreateTableResponse
             */
            CreateTableResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.CreateTableResponse)
                    return object;
                return new $root.main.proto.CreateTableResponse();
            };

            /**
             * Creates a plain object from a CreateTableResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.CreateTableResponse
             * @static
             * @param {main.proto.CreateTableResponse} message CreateTableResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateTableResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this CreateTableResponse to JSON.
             * @function toJSON
             * @memberof main.proto.CreateTableResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateTableResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CreateTableResponse;
        })();

        proto.CreateIndexRequest = (function() {

            /**
             * Properties of a CreateIndexRequest.
             * @memberof main.proto
             * @interface ICreateIndexRequest
             * @property {string} mainTableName CreateIndexRequest mainTableName
             * @property {main.proto.IIndexMeta} indexMeta CreateIndexRequest indexMeta
             * @property {boolean|null} [includeBaseData] CreateIndexRequest includeBaseData
             */

            /**
             * Constructs a new CreateIndexRequest.
             * @memberof main.proto
             * @classdesc Represents a CreateIndexRequest.
             * @implements ICreateIndexRequest
             * @constructor
             * @param {main.proto.ICreateIndexRequest=} [properties] Properties to set
             */
            function CreateIndexRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreateIndexRequest mainTableName.
             * @member {string} mainTableName
             * @memberof main.proto.CreateIndexRequest
             * @instance
             */
            CreateIndexRequest.prototype.mainTableName = "";

            /**
             * CreateIndexRequest indexMeta.
             * @member {main.proto.IIndexMeta} indexMeta
             * @memberof main.proto.CreateIndexRequest
             * @instance
             */
            CreateIndexRequest.prototype.indexMeta = null;

            /**
             * CreateIndexRequest includeBaseData.
             * @member {boolean} includeBaseData
             * @memberof main.proto.CreateIndexRequest
             * @instance
             */
            CreateIndexRequest.prototype.includeBaseData = false;

            /**
             * Creates a new CreateIndexRequest instance using the specified properties.
             * @function create
             * @memberof main.proto.CreateIndexRequest
             * @static
             * @param {main.proto.ICreateIndexRequest=} [properties] Properties to set
             * @returns {main.proto.CreateIndexRequest} CreateIndexRequest instance
             */
            CreateIndexRequest.create = function create(properties) {
                return new CreateIndexRequest(properties);
            };

            /**
             * Encodes the specified CreateIndexRequest message. Does not implicitly {@link main.proto.CreateIndexRequest.verify|verify} messages.
             * @function encode
             * @memberof main.proto.CreateIndexRequest
             * @static
             * @param {main.proto.ICreateIndexRequest} message CreateIndexRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateIndexRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.mainTableName);
                $root.main.proto.IndexMeta.encode(message.indexMeta, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.includeBaseData != null && Object.hasOwnProperty.call(message, "includeBaseData"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.includeBaseData);
                return writer;
            };

            /**
             * Encodes the specified CreateIndexRequest message, length delimited. Does not implicitly {@link main.proto.CreateIndexRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.CreateIndexRequest
             * @static
             * @param {main.proto.ICreateIndexRequest} message CreateIndexRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateIndexRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateIndexRequest message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.CreateIndexRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.CreateIndexRequest} CreateIndexRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateIndexRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.CreateIndexRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.mainTableName = reader.string();
                        break;
                    case 2:
                        message.indexMeta = $root.main.proto.IndexMeta.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.includeBaseData = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("mainTableName"))
                    throw $util.ProtocolError("missing required 'mainTableName'", { instance: message });
                if (!message.hasOwnProperty("indexMeta"))
                    throw $util.ProtocolError("missing required 'indexMeta'", { instance: message });
                return message;
            };

            /**
             * Decodes a CreateIndexRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.CreateIndexRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.CreateIndexRequest} CreateIndexRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateIndexRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateIndexRequest message.
             * @function verify
             * @memberof main.proto.CreateIndexRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateIndexRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.mainTableName))
                    return "mainTableName: string expected";
                {
                    var error = $root.main.proto.IndexMeta.verify(message.indexMeta);
                    if (error)
                        return "indexMeta." + error;
                }
                if (message.includeBaseData != null && message.hasOwnProperty("includeBaseData"))
                    if (typeof message.includeBaseData !== "boolean")
                        return "includeBaseData: boolean expected";
                return null;
            };

            /**
             * Creates a CreateIndexRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.CreateIndexRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.CreateIndexRequest} CreateIndexRequest
             */
            CreateIndexRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.CreateIndexRequest)
                    return object;
                var message = new $root.main.proto.CreateIndexRequest();
                if (object.mainTableName != null)
                    message.mainTableName = String(object.mainTableName);
                if (object.indexMeta != null) {
                    if (typeof object.indexMeta !== "object")
                        throw TypeError(".main.proto.CreateIndexRequest.indexMeta: object expected");
                    message.indexMeta = $root.main.proto.IndexMeta.fromObject(object.indexMeta);
                }
                if (object.includeBaseData != null)
                    message.includeBaseData = Boolean(object.includeBaseData);
                return message;
            };

            /**
             * Creates a plain object from a CreateIndexRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.CreateIndexRequest
             * @static
             * @param {main.proto.CreateIndexRequest} message CreateIndexRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateIndexRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.mainTableName = "";
                    object.indexMeta = null;
                    object.includeBaseData = false;
                }
                if (message.mainTableName != null && message.hasOwnProperty("mainTableName"))
                    object.mainTableName = message.mainTableName;
                if (message.indexMeta != null && message.hasOwnProperty("indexMeta"))
                    object.indexMeta = $root.main.proto.IndexMeta.toObject(message.indexMeta, options);
                if (message.includeBaseData != null && message.hasOwnProperty("includeBaseData"))
                    object.includeBaseData = message.includeBaseData;
                return object;
            };

            /**
             * Converts this CreateIndexRequest to JSON.
             * @function toJSON
             * @memberof main.proto.CreateIndexRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateIndexRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CreateIndexRequest;
        })();

        proto.CreateIndexResponse = (function() {

            /**
             * Properties of a CreateIndexResponse.
             * @memberof main.proto
             * @interface ICreateIndexResponse
             */

            /**
             * Constructs a new CreateIndexResponse.
             * @memberof main.proto
             * @classdesc Represents a CreateIndexResponse.
             * @implements ICreateIndexResponse
             * @constructor
             * @param {main.proto.ICreateIndexResponse=} [properties] Properties to set
             */
            function CreateIndexResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new CreateIndexResponse instance using the specified properties.
             * @function create
             * @memberof main.proto.CreateIndexResponse
             * @static
             * @param {main.proto.ICreateIndexResponse=} [properties] Properties to set
             * @returns {main.proto.CreateIndexResponse} CreateIndexResponse instance
             */
            CreateIndexResponse.create = function create(properties) {
                return new CreateIndexResponse(properties);
            };

            /**
             * Encodes the specified CreateIndexResponse message. Does not implicitly {@link main.proto.CreateIndexResponse.verify|verify} messages.
             * @function encode
             * @memberof main.proto.CreateIndexResponse
             * @static
             * @param {main.proto.ICreateIndexResponse} message CreateIndexResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateIndexResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified CreateIndexResponse message, length delimited. Does not implicitly {@link main.proto.CreateIndexResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.CreateIndexResponse
             * @static
             * @param {main.proto.ICreateIndexResponse} message CreateIndexResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateIndexResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateIndexResponse message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.CreateIndexResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.CreateIndexResponse} CreateIndexResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateIndexResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.CreateIndexResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CreateIndexResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.CreateIndexResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.CreateIndexResponse} CreateIndexResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateIndexResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateIndexResponse message.
             * @function verify
             * @memberof main.proto.CreateIndexResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateIndexResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a CreateIndexResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.CreateIndexResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.CreateIndexResponse} CreateIndexResponse
             */
            CreateIndexResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.CreateIndexResponse)
                    return object;
                return new $root.main.proto.CreateIndexResponse();
            };

            /**
             * Creates a plain object from a CreateIndexResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.CreateIndexResponse
             * @static
             * @param {main.proto.CreateIndexResponse} message CreateIndexResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateIndexResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this CreateIndexResponse to JSON.
             * @function toJSON
             * @memberof main.proto.CreateIndexResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateIndexResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CreateIndexResponse;
        })();

        proto.DropIndexRequest = (function() {

            /**
             * Properties of a DropIndexRequest.
             * @memberof main.proto
             * @interface IDropIndexRequest
             * @property {string} mainTableName DropIndexRequest mainTableName
             * @property {string} indexName DropIndexRequest indexName
             */

            /**
             * Constructs a new DropIndexRequest.
             * @memberof main.proto
             * @classdesc Represents a DropIndexRequest.
             * @implements IDropIndexRequest
             * @constructor
             * @param {main.proto.IDropIndexRequest=} [properties] Properties to set
             */
            function DropIndexRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DropIndexRequest mainTableName.
             * @member {string} mainTableName
             * @memberof main.proto.DropIndexRequest
             * @instance
             */
            DropIndexRequest.prototype.mainTableName = "";

            /**
             * DropIndexRequest indexName.
             * @member {string} indexName
             * @memberof main.proto.DropIndexRequest
             * @instance
             */
            DropIndexRequest.prototype.indexName = "";

            /**
             * Creates a new DropIndexRequest instance using the specified properties.
             * @function create
             * @memberof main.proto.DropIndexRequest
             * @static
             * @param {main.proto.IDropIndexRequest=} [properties] Properties to set
             * @returns {main.proto.DropIndexRequest} DropIndexRequest instance
             */
            DropIndexRequest.create = function create(properties) {
                return new DropIndexRequest(properties);
            };

            /**
             * Encodes the specified DropIndexRequest message. Does not implicitly {@link main.proto.DropIndexRequest.verify|verify} messages.
             * @function encode
             * @memberof main.proto.DropIndexRequest
             * @static
             * @param {main.proto.IDropIndexRequest} message DropIndexRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DropIndexRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.mainTableName);
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.indexName);
                return writer;
            };

            /**
             * Encodes the specified DropIndexRequest message, length delimited. Does not implicitly {@link main.proto.DropIndexRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.DropIndexRequest
             * @static
             * @param {main.proto.IDropIndexRequest} message DropIndexRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DropIndexRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DropIndexRequest message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.DropIndexRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.DropIndexRequest} DropIndexRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DropIndexRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.DropIndexRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.mainTableName = reader.string();
                        break;
                    case 2:
                        message.indexName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("mainTableName"))
                    throw $util.ProtocolError("missing required 'mainTableName'", { instance: message });
                if (!message.hasOwnProperty("indexName"))
                    throw $util.ProtocolError("missing required 'indexName'", { instance: message });
                return message;
            };

            /**
             * Decodes a DropIndexRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.DropIndexRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.DropIndexRequest} DropIndexRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DropIndexRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DropIndexRequest message.
             * @function verify
             * @memberof main.proto.DropIndexRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DropIndexRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.mainTableName))
                    return "mainTableName: string expected";
                if (!$util.isString(message.indexName))
                    return "indexName: string expected";
                return null;
            };

            /**
             * Creates a DropIndexRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.DropIndexRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.DropIndexRequest} DropIndexRequest
             */
            DropIndexRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.DropIndexRequest)
                    return object;
                var message = new $root.main.proto.DropIndexRequest();
                if (object.mainTableName != null)
                    message.mainTableName = String(object.mainTableName);
                if (object.indexName != null)
                    message.indexName = String(object.indexName);
                return message;
            };

            /**
             * Creates a plain object from a DropIndexRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.DropIndexRequest
             * @static
             * @param {main.proto.DropIndexRequest} message DropIndexRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DropIndexRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.mainTableName = "";
                    object.indexName = "";
                }
                if (message.mainTableName != null && message.hasOwnProperty("mainTableName"))
                    object.mainTableName = message.mainTableName;
                if (message.indexName != null && message.hasOwnProperty("indexName"))
                    object.indexName = message.indexName;
                return object;
            };

            /**
             * Converts this DropIndexRequest to JSON.
             * @function toJSON
             * @memberof main.proto.DropIndexRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DropIndexRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DropIndexRequest;
        })();

        proto.DropIndexResponse = (function() {

            /**
             * Properties of a DropIndexResponse.
             * @memberof main.proto
             * @interface IDropIndexResponse
             */

            /**
             * Constructs a new DropIndexResponse.
             * @memberof main.proto
             * @classdesc Represents a DropIndexResponse.
             * @implements IDropIndexResponse
             * @constructor
             * @param {main.proto.IDropIndexResponse=} [properties] Properties to set
             */
            function DropIndexResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new DropIndexResponse instance using the specified properties.
             * @function create
             * @memberof main.proto.DropIndexResponse
             * @static
             * @param {main.proto.IDropIndexResponse=} [properties] Properties to set
             * @returns {main.proto.DropIndexResponse} DropIndexResponse instance
             */
            DropIndexResponse.create = function create(properties) {
                return new DropIndexResponse(properties);
            };

            /**
             * Encodes the specified DropIndexResponse message. Does not implicitly {@link main.proto.DropIndexResponse.verify|verify} messages.
             * @function encode
             * @memberof main.proto.DropIndexResponse
             * @static
             * @param {main.proto.IDropIndexResponse} message DropIndexResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DropIndexResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified DropIndexResponse message, length delimited. Does not implicitly {@link main.proto.DropIndexResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.DropIndexResponse
             * @static
             * @param {main.proto.IDropIndexResponse} message DropIndexResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DropIndexResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DropIndexResponse message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.DropIndexResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.DropIndexResponse} DropIndexResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DropIndexResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.DropIndexResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DropIndexResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.DropIndexResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.DropIndexResponse} DropIndexResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DropIndexResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DropIndexResponse message.
             * @function verify
             * @memberof main.proto.DropIndexResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DropIndexResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a DropIndexResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.DropIndexResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.DropIndexResponse} DropIndexResponse
             */
            DropIndexResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.DropIndexResponse)
                    return object;
                return new $root.main.proto.DropIndexResponse();
            };

            /**
             * Creates a plain object from a DropIndexResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.DropIndexResponse
             * @static
             * @param {main.proto.DropIndexResponse} message DropIndexResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DropIndexResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this DropIndexResponse to JSON.
             * @function toJSON
             * @memberof main.proto.DropIndexResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DropIndexResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DropIndexResponse;
        })();

        proto.UpdateTableRequest = (function() {

            /**
             * Properties of an UpdateTableRequest.
             * @memberof main.proto
             * @interface IUpdateTableRequest
             * @property {string} tableName UpdateTableRequest tableName
             * @property {main.proto.IReservedThroughput|null} [reservedThroughput] UpdateTableRequest reservedThroughput
             * @property {main.proto.ITableOptions|null} [tableOptions] UpdateTableRequest tableOptions
             * @property {main.proto.IStreamSpecification|null} [streamSpec] UpdateTableRequest streamSpec
             */

            /**
             * Constructs a new UpdateTableRequest.
             * @memberof main.proto
             * @classdesc Represents an UpdateTableRequest.
             * @implements IUpdateTableRequest
             * @constructor
             * @param {main.proto.IUpdateTableRequest=} [properties] Properties to set
             */
            function UpdateTableRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UpdateTableRequest tableName.
             * @member {string} tableName
             * @memberof main.proto.UpdateTableRequest
             * @instance
             */
            UpdateTableRequest.prototype.tableName = "";

            /**
             * UpdateTableRequest reservedThroughput.
             * @member {main.proto.IReservedThroughput|null|undefined} reservedThroughput
             * @memberof main.proto.UpdateTableRequest
             * @instance
             */
            UpdateTableRequest.prototype.reservedThroughput = null;

            /**
             * UpdateTableRequest tableOptions.
             * @member {main.proto.ITableOptions|null|undefined} tableOptions
             * @memberof main.proto.UpdateTableRequest
             * @instance
             */
            UpdateTableRequest.prototype.tableOptions = null;

            /**
             * UpdateTableRequest streamSpec.
             * @member {main.proto.IStreamSpecification|null|undefined} streamSpec
             * @memberof main.proto.UpdateTableRequest
             * @instance
             */
            UpdateTableRequest.prototype.streamSpec = null;

            /**
             * Creates a new UpdateTableRequest instance using the specified properties.
             * @function create
             * @memberof main.proto.UpdateTableRequest
             * @static
             * @param {main.proto.IUpdateTableRequest=} [properties] Properties to set
             * @returns {main.proto.UpdateTableRequest} UpdateTableRequest instance
             */
            UpdateTableRequest.create = function create(properties) {
                return new UpdateTableRequest(properties);
            };

            /**
             * Encodes the specified UpdateTableRequest message. Does not implicitly {@link main.proto.UpdateTableRequest.verify|verify} messages.
             * @function encode
             * @memberof main.proto.UpdateTableRequest
             * @static
             * @param {main.proto.IUpdateTableRequest} message UpdateTableRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateTableRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.tableName);
                if (message.reservedThroughput != null && Object.hasOwnProperty.call(message, "reservedThroughput"))
                    $root.main.proto.ReservedThroughput.encode(message.reservedThroughput, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.tableOptions != null && Object.hasOwnProperty.call(message, "tableOptions"))
                    $root.main.proto.TableOptions.encode(message.tableOptions, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.streamSpec != null && Object.hasOwnProperty.call(message, "streamSpec"))
                    $root.main.proto.StreamSpecification.encode(message.streamSpec, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified UpdateTableRequest message, length delimited. Does not implicitly {@link main.proto.UpdateTableRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.UpdateTableRequest
             * @static
             * @param {main.proto.IUpdateTableRequest} message UpdateTableRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateTableRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UpdateTableRequest message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.UpdateTableRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.UpdateTableRequest} UpdateTableRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateTableRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.UpdateTableRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tableName = reader.string();
                        break;
                    case 2:
                        message.reservedThroughput = $root.main.proto.ReservedThroughput.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.tableOptions = $root.main.proto.TableOptions.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.streamSpec = $root.main.proto.StreamSpecification.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("tableName"))
                    throw $util.ProtocolError("missing required 'tableName'", { instance: message });
                return message;
            };

            /**
             * Decodes an UpdateTableRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.UpdateTableRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.UpdateTableRequest} UpdateTableRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateTableRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UpdateTableRequest message.
             * @function verify
             * @memberof main.proto.UpdateTableRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UpdateTableRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.tableName))
                    return "tableName: string expected";
                if (message.reservedThroughput != null && message.hasOwnProperty("reservedThroughput")) {
                    var error = $root.main.proto.ReservedThroughput.verify(message.reservedThroughput);
                    if (error)
                        return "reservedThroughput." + error;
                }
                if (message.tableOptions != null && message.hasOwnProperty("tableOptions")) {
                    var error = $root.main.proto.TableOptions.verify(message.tableOptions);
                    if (error)
                        return "tableOptions." + error;
                }
                if (message.streamSpec != null && message.hasOwnProperty("streamSpec")) {
                    var error = $root.main.proto.StreamSpecification.verify(message.streamSpec);
                    if (error)
                        return "streamSpec." + error;
                }
                return null;
            };

            /**
             * Creates an UpdateTableRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.UpdateTableRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.UpdateTableRequest} UpdateTableRequest
             */
            UpdateTableRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.UpdateTableRequest)
                    return object;
                var message = new $root.main.proto.UpdateTableRequest();
                if (object.tableName != null)
                    message.tableName = String(object.tableName);
                if (object.reservedThroughput != null) {
                    if (typeof object.reservedThroughput !== "object")
                        throw TypeError(".main.proto.UpdateTableRequest.reservedThroughput: object expected");
                    message.reservedThroughput = $root.main.proto.ReservedThroughput.fromObject(object.reservedThroughput);
                }
                if (object.tableOptions != null) {
                    if (typeof object.tableOptions !== "object")
                        throw TypeError(".main.proto.UpdateTableRequest.tableOptions: object expected");
                    message.tableOptions = $root.main.proto.TableOptions.fromObject(object.tableOptions);
                }
                if (object.streamSpec != null) {
                    if (typeof object.streamSpec !== "object")
                        throw TypeError(".main.proto.UpdateTableRequest.streamSpec: object expected");
                    message.streamSpec = $root.main.proto.StreamSpecification.fromObject(object.streamSpec);
                }
                return message;
            };

            /**
             * Creates a plain object from an UpdateTableRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.UpdateTableRequest
             * @static
             * @param {main.proto.UpdateTableRequest} message UpdateTableRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UpdateTableRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.tableName = "";
                    object.reservedThroughput = null;
                    object.tableOptions = null;
                    object.streamSpec = null;
                }
                if (message.tableName != null && message.hasOwnProperty("tableName"))
                    object.tableName = message.tableName;
                if (message.reservedThroughput != null && message.hasOwnProperty("reservedThroughput"))
                    object.reservedThroughput = $root.main.proto.ReservedThroughput.toObject(message.reservedThroughput, options);
                if (message.tableOptions != null && message.hasOwnProperty("tableOptions"))
                    object.tableOptions = $root.main.proto.TableOptions.toObject(message.tableOptions, options);
                if (message.streamSpec != null && message.hasOwnProperty("streamSpec"))
                    object.streamSpec = $root.main.proto.StreamSpecification.toObject(message.streamSpec, options);
                return object;
            };

            /**
             * Converts this UpdateTableRequest to JSON.
             * @function toJSON
             * @memberof main.proto.UpdateTableRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UpdateTableRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return UpdateTableRequest;
        })();

        proto.UpdateTableResponse = (function() {

            /**
             * Properties of an UpdateTableResponse.
             * @memberof main.proto
             * @interface IUpdateTableResponse
             * @property {main.proto.IReservedThroughputDetails} reservedThroughputDetails UpdateTableResponse reservedThroughputDetails
             * @property {main.proto.ITableOptions} tableOptions UpdateTableResponse tableOptions
             * @property {main.proto.IStreamDetails|null} [streamDetails] UpdateTableResponse streamDetails
             */

            /**
             * Constructs a new UpdateTableResponse.
             * @memberof main.proto
             * @classdesc Represents an UpdateTableResponse.
             * @implements IUpdateTableResponse
             * @constructor
             * @param {main.proto.IUpdateTableResponse=} [properties] Properties to set
             */
            function UpdateTableResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UpdateTableResponse reservedThroughputDetails.
             * @member {main.proto.IReservedThroughputDetails} reservedThroughputDetails
             * @memberof main.proto.UpdateTableResponse
             * @instance
             */
            UpdateTableResponse.prototype.reservedThroughputDetails = null;

            /**
             * UpdateTableResponse tableOptions.
             * @member {main.proto.ITableOptions} tableOptions
             * @memberof main.proto.UpdateTableResponse
             * @instance
             */
            UpdateTableResponse.prototype.tableOptions = null;

            /**
             * UpdateTableResponse streamDetails.
             * @member {main.proto.IStreamDetails|null|undefined} streamDetails
             * @memberof main.proto.UpdateTableResponse
             * @instance
             */
            UpdateTableResponse.prototype.streamDetails = null;

            /**
             * Creates a new UpdateTableResponse instance using the specified properties.
             * @function create
             * @memberof main.proto.UpdateTableResponse
             * @static
             * @param {main.proto.IUpdateTableResponse=} [properties] Properties to set
             * @returns {main.proto.UpdateTableResponse} UpdateTableResponse instance
             */
            UpdateTableResponse.create = function create(properties) {
                return new UpdateTableResponse(properties);
            };

            /**
             * Encodes the specified UpdateTableResponse message. Does not implicitly {@link main.proto.UpdateTableResponse.verify|verify} messages.
             * @function encode
             * @memberof main.proto.UpdateTableResponse
             * @static
             * @param {main.proto.IUpdateTableResponse} message UpdateTableResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateTableResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                $root.main.proto.ReservedThroughputDetails.encode(message.reservedThroughputDetails, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                $root.main.proto.TableOptions.encode(message.tableOptions, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.streamDetails != null && Object.hasOwnProperty.call(message, "streamDetails"))
                    $root.main.proto.StreamDetails.encode(message.streamDetails, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified UpdateTableResponse message, length delimited. Does not implicitly {@link main.proto.UpdateTableResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.UpdateTableResponse
             * @static
             * @param {main.proto.IUpdateTableResponse} message UpdateTableResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateTableResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UpdateTableResponse message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.UpdateTableResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.UpdateTableResponse} UpdateTableResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateTableResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.UpdateTableResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.reservedThroughputDetails = $root.main.proto.ReservedThroughputDetails.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.tableOptions = $root.main.proto.TableOptions.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.streamDetails = $root.main.proto.StreamDetails.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("reservedThroughputDetails"))
                    throw $util.ProtocolError("missing required 'reservedThroughputDetails'", { instance: message });
                if (!message.hasOwnProperty("tableOptions"))
                    throw $util.ProtocolError("missing required 'tableOptions'", { instance: message });
                return message;
            };

            /**
             * Decodes an UpdateTableResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.UpdateTableResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.UpdateTableResponse} UpdateTableResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateTableResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UpdateTableResponse message.
             * @function verify
             * @memberof main.proto.UpdateTableResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UpdateTableResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                {
                    var error = $root.main.proto.ReservedThroughputDetails.verify(message.reservedThroughputDetails);
                    if (error)
                        return "reservedThroughputDetails." + error;
                }
                {
                    var error = $root.main.proto.TableOptions.verify(message.tableOptions);
                    if (error)
                        return "tableOptions." + error;
                }
                if (message.streamDetails != null && message.hasOwnProperty("streamDetails")) {
                    var error = $root.main.proto.StreamDetails.verify(message.streamDetails);
                    if (error)
                        return "streamDetails." + error;
                }
                return null;
            };

            /**
             * Creates an UpdateTableResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.UpdateTableResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.UpdateTableResponse} UpdateTableResponse
             */
            UpdateTableResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.UpdateTableResponse)
                    return object;
                var message = new $root.main.proto.UpdateTableResponse();
                if (object.reservedThroughputDetails != null) {
                    if (typeof object.reservedThroughputDetails !== "object")
                        throw TypeError(".main.proto.UpdateTableResponse.reservedThroughputDetails: object expected");
                    message.reservedThroughputDetails = $root.main.proto.ReservedThroughputDetails.fromObject(object.reservedThroughputDetails);
                }
                if (object.tableOptions != null) {
                    if (typeof object.tableOptions !== "object")
                        throw TypeError(".main.proto.UpdateTableResponse.tableOptions: object expected");
                    message.tableOptions = $root.main.proto.TableOptions.fromObject(object.tableOptions);
                }
                if (object.streamDetails != null) {
                    if (typeof object.streamDetails !== "object")
                        throw TypeError(".main.proto.UpdateTableResponse.streamDetails: object expected");
                    message.streamDetails = $root.main.proto.StreamDetails.fromObject(object.streamDetails);
                }
                return message;
            };

            /**
             * Creates a plain object from an UpdateTableResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.UpdateTableResponse
             * @static
             * @param {main.proto.UpdateTableResponse} message UpdateTableResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UpdateTableResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.reservedThroughputDetails = null;
                    object.tableOptions = null;
                    object.streamDetails = null;
                }
                if (message.reservedThroughputDetails != null && message.hasOwnProperty("reservedThroughputDetails"))
                    object.reservedThroughputDetails = $root.main.proto.ReservedThroughputDetails.toObject(message.reservedThroughputDetails, options);
                if (message.tableOptions != null && message.hasOwnProperty("tableOptions"))
                    object.tableOptions = $root.main.proto.TableOptions.toObject(message.tableOptions, options);
                if (message.streamDetails != null && message.hasOwnProperty("streamDetails"))
                    object.streamDetails = $root.main.proto.StreamDetails.toObject(message.streamDetails, options);
                return object;
            };

            /**
             * Converts this UpdateTableResponse to JSON.
             * @function toJSON
             * @memberof main.proto.UpdateTableResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UpdateTableResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return UpdateTableResponse;
        })();

        proto.DescribeTableRequest = (function() {

            /**
             * Properties of a DescribeTableRequest.
             * @memberof main.proto
             * @interface IDescribeTableRequest
             * @property {string} tableName DescribeTableRequest tableName
             */

            /**
             * Constructs a new DescribeTableRequest.
             * @memberof main.proto
             * @classdesc Represents a DescribeTableRequest.
             * @implements IDescribeTableRequest
             * @constructor
             * @param {main.proto.IDescribeTableRequest=} [properties] Properties to set
             */
            function DescribeTableRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DescribeTableRequest tableName.
             * @member {string} tableName
             * @memberof main.proto.DescribeTableRequest
             * @instance
             */
            DescribeTableRequest.prototype.tableName = "";

            /**
             * Creates a new DescribeTableRequest instance using the specified properties.
             * @function create
             * @memberof main.proto.DescribeTableRequest
             * @static
             * @param {main.proto.IDescribeTableRequest=} [properties] Properties to set
             * @returns {main.proto.DescribeTableRequest} DescribeTableRequest instance
             */
            DescribeTableRequest.create = function create(properties) {
                return new DescribeTableRequest(properties);
            };

            /**
             * Encodes the specified DescribeTableRequest message. Does not implicitly {@link main.proto.DescribeTableRequest.verify|verify} messages.
             * @function encode
             * @memberof main.proto.DescribeTableRequest
             * @static
             * @param {main.proto.IDescribeTableRequest} message DescribeTableRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeTableRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.tableName);
                return writer;
            };

            /**
             * Encodes the specified DescribeTableRequest message, length delimited. Does not implicitly {@link main.proto.DescribeTableRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.DescribeTableRequest
             * @static
             * @param {main.proto.IDescribeTableRequest} message DescribeTableRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeTableRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DescribeTableRequest message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.DescribeTableRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.DescribeTableRequest} DescribeTableRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeTableRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.DescribeTableRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tableName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("tableName"))
                    throw $util.ProtocolError("missing required 'tableName'", { instance: message });
                return message;
            };

            /**
             * Decodes a DescribeTableRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.DescribeTableRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.DescribeTableRequest} DescribeTableRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeTableRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DescribeTableRequest message.
             * @function verify
             * @memberof main.proto.DescribeTableRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DescribeTableRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.tableName))
                    return "tableName: string expected";
                return null;
            };

            /**
             * Creates a DescribeTableRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.DescribeTableRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.DescribeTableRequest} DescribeTableRequest
             */
            DescribeTableRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.DescribeTableRequest)
                    return object;
                var message = new $root.main.proto.DescribeTableRequest();
                if (object.tableName != null)
                    message.tableName = String(object.tableName);
                return message;
            };

            /**
             * Creates a plain object from a DescribeTableRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.DescribeTableRequest
             * @static
             * @param {main.proto.DescribeTableRequest} message DescribeTableRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescribeTableRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.tableName = "";
                if (message.tableName != null && message.hasOwnProperty("tableName"))
                    object.tableName = message.tableName;
                return object;
            };

            /**
             * Converts this DescribeTableRequest to JSON.
             * @function toJSON
             * @memberof main.proto.DescribeTableRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DescribeTableRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DescribeTableRequest;
        })();

        proto.DescribeTableResponse = (function() {

            /**
             * Properties of a DescribeTableResponse.
             * @memberof main.proto
             * @interface IDescribeTableResponse
             * @property {main.proto.ITableMeta} tableMeta DescribeTableResponse tableMeta
             * @property {main.proto.IReservedThroughputDetails} reservedThroughputDetails DescribeTableResponse reservedThroughputDetails
             * @property {main.proto.ITableOptions} tableOptions DescribeTableResponse tableOptions
             * @property {main.proto.TableStatus} tableStatus DescribeTableResponse tableStatus
             * @property {main.proto.IStreamDetails|null} [streamDetails] DescribeTableResponse streamDetails
             * @property {Array.<Uint8Array>|null} [shardSplits] DescribeTableResponse shardSplits
             * @property {Array.<main.proto.IIndexMeta>|null} [indexMetas] DescribeTableResponse indexMetas
             */

            /**
             * Constructs a new DescribeTableResponse.
             * @memberof main.proto
             * @classdesc Represents a DescribeTableResponse.
             * @implements IDescribeTableResponse
             * @constructor
             * @param {main.proto.IDescribeTableResponse=} [properties] Properties to set
             */
            function DescribeTableResponse(properties) {
                this.shardSplits = [];
                this.indexMetas = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DescribeTableResponse tableMeta.
             * @member {main.proto.ITableMeta} tableMeta
             * @memberof main.proto.DescribeTableResponse
             * @instance
             */
            DescribeTableResponse.prototype.tableMeta = null;

            /**
             * DescribeTableResponse reservedThroughputDetails.
             * @member {main.proto.IReservedThroughputDetails} reservedThroughputDetails
             * @memberof main.proto.DescribeTableResponse
             * @instance
             */
            DescribeTableResponse.prototype.reservedThroughputDetails = null;

            /**
             * DescribeTableResponse tableOptions.
             * @member {main.proto.ITableOptions} tableOptions
             * @memberof main.proto.DescribeTableResponse
             * @instance
             */
            DescribeTableResponse.prototype.tableOptions = null;

            /**
             * DescribeTableResponse tableStatus.
             * @member {main.proto.TableStatus} tableStatus
             * @memberof main.proto.DescribeTableResponse
             * @instance
             */
            DescribeTableResponse.prototype.tableStatus = 1;

            /**
             * DescribeTableResponse streamDetails.
             * @member {main.proto.IStreamDetails|null|undefined} streamDetails
             * @memberof main.proto.DescribeTableResponse
             * @instance
             */
            DescribeTableResponse.prototype.streamDetails = null;

            /**
             * DescribeTableResponse shardSplits.
             * @member {Array.<Uint8Array>} shardSplits
             * @memberof main.proto.DescribeTableResponse
             * @instance
             */
            DescribeTableResponse.prototype.shardSplits = $util.emptyArray;

            /**
             * DescribeTableResponse indexMetas.
             * @member {Array.<main.proto.IIndexMeta>} indexMetas
             * @memberof main.proto.DescribeTableResponse
             * @instance
             */
            DescribeTableResponse.prototype.indexMetas = $util.emptyArray;

            /**
             * Creates a new DescribeTableResponse instance using the specified properties.
             * @function create
             * @memberof main.proto.DescribeTableResponse
             * @static
             * @param {main.proto.IDescribeTableResponse=} [properties] Properties to set
             * @returns {main.proto.DescribeTableResponse} DescribeTableResponse instance
             */
            DescribeTableResponse.create = function create(properties) {
                return new DescribeTableResponse(properties);
            };

            /**
             * Encodes the specified DescribeTableResponse message. Does not implicitly {@link main.proto.DescribeTableResponse.verify|verify} messages.
             * @function encode
             * @memberof main.proto.DescribeTableResponse
             * @static
             * @param {main.proto.IDescribeTableResponse} message DescribeTableResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeTableResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                $root.main.proto.TableMeta.encode(message.tableMeta, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                $root.main.proto.ReservedThroughputDetails.encode(message.reservedThroughputDetails, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                $root.main.proto.TableOptions.encode(message.tableOptions, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.tableStatus);
                if (message.streamDetails != null && Object.hasOwnProperty.call(message, "streamDetails"))
                    $root.main.proto.StreamDetails.encode(message.streamDetails, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.shardSplits != null && message.shardSplits.length)
                    for (var i = 0; i < message.shardSplits.length; ++i)
                        writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.shardSplits[i]);
                if (message.indexMetas != null && message.indexMetas.length)
                    for (var i = 0; i < message.indexMetas.length; ++i)
                        $root.main.proto.IndexMeta.encode(message.indexMetas[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DescribeTableResponse message, length delimited. Does not implicitly {@link main.proto.DescribeTableResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.DescribeTableResponse
             * @static
             * @param {main.proto.IDescribeTableResponse} message DescribeTableResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeTableResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DescribeTableResponse message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.DescribeTableResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.DescribeTableResponse} DescribeTableResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeTableResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.DescribeTableResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tableMeta = $root.main.proto.TableMeta.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.reservedThroughputDetails = $root.main.proto.ReservedThroughputDetails.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.tableOptions = $root.main.proto.TableOptions.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.tableStatus = reader.int32();
                        break;
                    case 5:
                        message.streamDetails = $root.main.proto.StreamDetails.decode(reader, reader.uint32());
                        break;
                    case 6:
                        if (!(message.shardSplits && message.shardSplits.length))
                            message.shardSplits = [];
                        message.shardSplits.push(reader.bytes());
                        break;
                    case 8:
                        if (!(message.indexMetas && message.indexMetas.length))
                            message.indexMetas = [];
                        message.indexMetas.push($root.main.proto.IndexMeta.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("tableMeta"))
                    throw $util.ProtocolError("missing required 'tableMeta'", { instance: message });
                if (!message.hasOwnProperty("reservedThroughputDetails"))
                    throw $util.ProtocolError("missing required 'reservedThroughputDetails'", { instance: message });
                if (!message.hasOwnProperty("tableOptions"))
                    throw $util.ProtocolError("missing required 'tableOptions'", { instance: message });
                if (!message.hasOwnProperty("tableStatus"))
                    throw $util.ProtocolError("missing required 'tableStatus'", { instance: message });
                return message;
            };

            /**
             * Decodes a DescribeTableResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.DescribeTableResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.DescribeTableResponse} DescribeTableResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeTableResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DescribeTableResponse message.
             * @function verify
             * @memberof main.proto.DescribeTableResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DescribeTableResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                {
                    var error = $root.main.proto.TableMeta.verify(message.tableMeta);
                    if (error)
                        return "tableMeta." + error;
                }
                {
                    var error = $root.main.proto.ReservedThroughputDetails.verify(message.reservedThroughputDetails);
                    if (error)
                        return "reservedThroughputDetails." + error;
                }
                {
                    var error = $root.main.proto.TableOptions.verify(message.tableOptions);
                    if (error)
                        return "tableOptions." + error;
                }
                switch (message.tableStatus) {
                default:
                    return "tableStatus: enum value expected";
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
                if (message.streamDetails != null && message.hasOwnProperty("streamDetails")) {
                    var error = $root.main.proto.StreamDetails.verify(message.streamDetails);
                    if (error)
                        return "streamDetails." + error;
                }
                if (message.shardSplits != null && message.hasOwnProperty("shardSplits")) {
                    if (!Array.isArray(message.shardSplits))
                        return "shardSplits: array expected";
                    for (var i = 0; i < message.shardSplits.length; ++i)
                        if (!(message.shardSplits[i] && typeof message.shardSplits[i].length === "number" || $util.isString(message.shardSplits[i])))
                            return "shardSplits: buffer[] expected";
                }
                if (message.indexMetas != null && message.hasOwnProperty("indexMetas")) {
                    if (!Array.isArray(message.indexMetas))
                        return "indexMetas: array expected";
                    for (var i = 0; i < message.indexMetas.length; ++i) {
                        var error = $root.main.proto.IndexMeta.verify(message.indexMetas[i]);
                        if (error)
                            return "indexMetas." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a DescribeTableResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.DescribeTableResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.DescribeTableResponse} DescribeTableResponse
             */
            DescribeTableResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.DescribeTableResponse)
                    return object;
                var message = new $root.main.proto.DescribeTableResponse();
                if (object.tableMeta != null) {
                    if (typeof object.tableMeta !== "object")
                        throw TypeError(".main.proto.DescribeTableResponse.tableMeta: object expected");
                    message.tableMeta = $root.main.proto.TableMeta.fromObject(object.tableMeta);
                }
                if (object.reservedThroughputDetails != null) {
                    if (typeof object.reservedThroughputDetails !== "object")
                        throw TypeError(".main.proto.DescribeTableResponse.reservedThroughputDetails: object expected");
                    message.reservedThroughputDetails = $root.main.proto.ReservedThroughputDetails.fromObject(object.reservedThroughputDetails);
                }
                if (object.tableOptions != null) {
                    if (typeof object.tableOptions !== "object")
                        throw TypeError(".main.proto.DescribeTableResponse.tableOptions: object expected");
                    message.tableOptions = $root.main.proto.TableOptions.fromObject(object.tableOptions);
                }
                switch (object.tableStatus) {
                case "ACTIVE":
                case 1:
                    message.tableStatus = 1;
                    break;
                case "INACTIVE":
                case 2:
                    message.tableStatus = 2;
                    break;
                case "LOADING":
                case 3:
                    message.tableStatus = 3;
                    break;
                case "UNLOADING":
                case 4:
                    message.tableStatus = 4;
                    break;
                case "UPDATING":
                case 5:
                    message.tableStatus = 5;
                    break;
                }
                if (object.streamDetails != null) {
                    if (typeof object.streamDetails !== "object")
                        throw TypeError(".main.proto.DescribeTableResponse.streamDetails: object expected");
                    message.streamDetails = $root.main.proto.StreamDetails.fromObject(object.streamDetails);
                }
                if (object.shardSplits) {
                    if (!Array.isArray(object.shardSplits))
                        throw TypeError(".main.proto.DescribeTableResponse.shardSplits: array expected");
                    message.shardSplits = [];
                    for (var i = 0; i < object.shardSplits.length; ++i)
                        if (typeof object.shardSplits[i] === "string")
                            $util.base64.decode(object.shardSplits[i], message.shardSplits[i] = $util.newBuffer($util.base64.length(object.shardSplits[i])), 0);
                        else if (object.shardSplits[i].length)
                            message.shardSplits[i] = object.shardSplits[i];
                }
                if (object.indexMetas) {
                    if (!Array.isArray(object.indexMetas))
                        throw TypeError(".main.proto.DescribeTableResponse.indexMetas: array expected");
                    message.indexMetas = [];
                    for (var i = 0; i < object.indexMetas.length; ++i) {
                        if (typeof object.indexMetas[i] !== "object")
                            throw TypeError(".main.proto.DescribeTableResponse.indexMetas: object expected");
                        message.indexMetas[i] = $root.main.proto.IndexMeta.fromObject(object.indexMetas[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a DescribeTableResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.DescribeTableResponse
             * @static
             * @param {main.proto.DescribeTableResponse} message DescribeTableResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescribeTableResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.shardSplits = [];
                    object.indexMetas = [];
                }
                if (options.defaults) {
                    object.tableMeta = null;
                    object.reservedThroughputDetails = null;
                    object.tableOptions = null;
                    object.tableStatus = options.enums === String ? "ACTIVE" : 1;
                    object.streamDetails = null;
                }
                if (message.tableMeta != null && message.hasOwnProperty("tableMeta"))
                    object.tableMeta = $root.main.proto.TableMeta.toObject(message.tableMeta, options);
                if (message.reservedThroughputDetails != null && message.hasOwnProperty("reservedThroughputDetails"))
                    object.reservedThroughputDetails = $root.main.proto.ReservedThroughputDetails.toObject(message.reservedThroughputDetails, options);
                if (message.tableOptions != null && message.hasOwnProperty("tableOptions"))
                    object.tableOptions = $root.main.proto.TableOptions.toObject(message.tableOptions, options);
                if (message.tableStatus != null && message.hasOwnProperty("tableStatus"))
                    object.tableStatus = options.enums === String ? $root.main.proto.TableStatus[message.tableStatus] : message.tableStatus;
                if (message.streamDetails != null && message.hasOwnProperty("streamDetails"))
                    object.streamDetails = $root.main.proto.StreamDetails.toObject(message.streamDetails, options);
                if (message.shardSplits && message.shardSplits.length) {
                    object.shardSplits = [];
                    for (var j = 0; j < message.shardSplits.length; ++j)
                        object.shardSplits[j] = options.bytes === String ? $util.base64.encode(message.shardSplits[j], 0, message.shardSplits[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.shardSplits[j]) : message.shardSplits[j];
                }
                if (message.indexMetas && message.indexMetas.length) {
                    object.indexMetas = [];
                    for (var j = 0; j < message.indexMetas.length; ++j)
                        object.indexMetas[j] = $root.main.proto.IndexMeta.toObject(message.indexMetas[j], options);
                }
                return object;
            };

            /**
             * Converts this DescribeTableResponse to JSON.
             * @function toJSON
             * @memberof main.proto.DescribeTableResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DescribeTableResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DescribeTableResponse;
        })();

        proto.ListTableRequest = (function() {

            /**
             * Properties of a ListTableRequest.
             * @memberof main.proto
             * @interface IListTableRequest
             */

            /**
             * Constructs a new ListTableRequest.
             * @memberof main.proto
             * @classdesc Represents a ListTableRequest.
             * @implements IListTableRequest
             * @constructor
             * @param {main.proto.IListTableRequest=} [properties] Properties to set
             */
            function ListTableRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new ListTableRequest instance using the specified properties.
             * @function create
             * @memberof main.proto.ListTableRequest
             * @static
             * @param {main.proto.IListTableRequest=} [properties] Properties to set
             * @returns {main.proto.ListTableRequest} ListTableRequest instance
             */
            ListTableRequest.create = function create(properties) {
                return new ListTableRequest(properties);
            };

            /**
             * Encodes the specified ListTableRequest message. Does not implicitly {@link main.proto.ListTableRequest.verify|verify} messages.
             * @function encode
             * @memberof main.proto.ListTableRequest
             * @static
             * @param {main.proto.IListTableRequest} message ListTableRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListTableRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified ListTableRequest message, length delimited. Does not implicitly {@link main.proto.ListTableRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.ListTableRequest
             * @static
             * @param {main.proto.IListTableRequest} message ListTableRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListTableRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListTableRequest message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.ListTableRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.ListTableRequest} ListTableRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListTableRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.ListTableRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListTableRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.ListTableRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.ListTableRequest} ListTableRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListTableRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListTableRequest message.
             * @function verify
             * @memberof main.proto.ListTableRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListTableRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a ListTableRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.ListTableRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.ListTableRequest} ListTableRequest
             */
            ListTableRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.ListTableRequest)
                    return object;
                return new $root.main.proto.ListTableRequest();
            };

            /**
             * Creates a plain object from a ListTableRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.ListTableRequest
             * @static
             * @param {main.proto.ListTableRequest} message ListTableRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListTableRequest.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this ListTableRequest to JSON.
             * @function toJSON
             * @memberof main.proto.ListTableRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListTableRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListTableRequest;
        })();

        proto.ListTableResponse = (function() {

            /**
             * Properties of a ListTableResponse.
             * @memberof main.proto
             * @interface IListTableResponse
             * @property {Array.<string>|null} [tableNames] ListTableResponse tableNames
             */

            /**
             * Constructs a new ListTableResponse.
             * @memberof main.proto
             * @classdesc 当前只返回一个简单的名称列表，需要讨论是否有业务场景需要获取除了表名之外的其他信息。
             * 其他信息可以包含预留吞吐量以及表的状态，这个信息只能是一个粗略的信息，表的详细信息还是需要通过DescribeTable来获取。
             * @implements IListTableResponse
             * @constructor
             * @param {main.proto.IListTableResponse=} [properties] Properties to set
             */
            function ListTableResponse(properties) {
                this.tableNames = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListTableResponse tableNames.
             * @member {Array.<string>} tableNames
             * @memberof main.proto.ListTableResponse
             * @instance
             */
            ListTableResponse.prototype.tableNames = $util.emptyArray;

            /**
             * Creates a new ListTableResponse instance using the specified properties.
             * @function create
             * @memberof main.proto.ListTableResponse
             * @static
             * @param {main.proto.IListTableResponse=} [properties] Properties to set
             * @returns {main.proto.ListTableResponse} ListTableResponse instance
             */
            ListTableResponse.create = function create(properties) {
                return new ListTableResponse(properties);
            };

            /**
             * Encodes the specified ListTableResponse message. Does not implicitly {@link main.proto.ListTableResponse.verify|verify} messages.
             * @function encode
             * @memberof main.proto.ListTableResponse
             * @static
             * @param {main.proto.IListTableResponse} message ListTableResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListTableResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tableNames != null && message.tableNames.length)
                    for (var i = 0; i < message.tableNames.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.tableNames[i]);
                return writer;
            };

            /**
             * Encodes the specified ListTableResponse message, length delimited. Does not implicitly {@link main.proto.ListTableResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.ListTableResponse
             * @static
             * @param {main.proto.IListTableResponse} message ListTableResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListTableResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListTableResponse message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.ListTableResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.ListTableResponse} ListTableResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListTableResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.ListTableResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.tableNames && message.tableNames.length))
                            message.tableNames = [];
                        message.tableNames.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListTableResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.ListTableResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.ListTableResponse} ListTableResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListTableResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListTableResponse message.
             * @function verify
             * @memberof main.proto.ListTableResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListTableResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tableNames != null && message.hasOwnProperty("tableNames")) {
                    if (!Array.isArray(message.tableNames))
                        return "tableNames: array expected";
                    for (var i = 0; i < message.tableNames.length; ++i)
                        if (!$util.isString(message.tableNames[i]))
                            return "tableNames: string[] expected";
                }
                return null;
            };

            /**
             * Creates a ListTableResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.ListTableResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.ListTableResponse} ListTableResponse
             */
            ListTableResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.ListTableResponse)
                    return object;
                var message = new $root.main.proto.ListTableResponse();
                if (object.tableNames) {
                    if (!Array.isArray(object.tableNames))
                        throw TypeError(".main.proto.ListTableResponse.tableNames: array expected");
                    message.tableNames = [];
                    for (var i = 0; i < object.tableNames.length; ++i)
                        message.tableNames[i] = String(object.tableNames[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a ListTableResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.ListTableResponse
             * @static
             * @param {main.proto.ListTableResponse} message ListTableResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListTableResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.tableNames = [];
                if (message.tableNames && message.tableNames.length) {
                    object.tableNames = [];
                    for (var j = 0; j < message.tableNames.length; ++j)
                        object.tableNames[j] = message.tableNames[j];
                }
                return object;
            };

            /**
             * Converts this ListTableResponse to JSON.
             * @function toJSON
             * @memberof main.proto.ListTableResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListTableResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListTableResponse;
        })();

        proto.DeleteTableRequest = (function() {

            /**
             * Properties of a DeleteTableRequest.
             * @memberof main.proto
             * @interface IDeleteTableRequest
             * @property {string} tableName DeleteTableRequest tableName
             */

            /**
             * Constructs a new DeleteTableRequest.
             * @memberof main.proto
             * @classdesc Represents a DeleteTableRequest.
             * @implements IDeleteTableRequest
             * @constructor
             * @param {main.proto.IDeleteTableRequest=} [properties] Properties to set
             */
            function DeleteTableRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeleteTableRequest tableName.
             * @member {string} tableName
             * @memberof main.proto.DeleteTableRequest
             * @instance
             */
            DeleteTableRequest.prototype.tableName = "";

            /**
             * Creates a new DeleteTableRequest instance using the specified properties.
             * @function create
             * @memberof main.proto.DeleteTableRequest
             * @static
             * @param {main.proto.IDeleteTableRequest=} [properties] Properties to set
             * @returns {main.proto.DeleteTableRequest} DeleteTableRequest instance
             */
            DeleteTableRequest.create = function create(properties) {
                return new DeleteTableRequest(properties);
            };

            /**
             * Encodes the specified DeleteTableRequest message. Does not implicitly {@link main.proto.DeleteTableRequest.verify|verify} messages.
             * @function encode
             * @memberof main.proto.DeleteTableRequest
             * @static
             * @param {main.proto.IDeleteTableRequest} message DeleteTableRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteTableRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.tableName);
                return writer;
            };

            /**
             * Encodes the specified DeleteTableRequest message, length delimited. Does not implicitly {@link main.proto.DeleteTableRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.DeleteTableRequest
             * @static
             * @param {main.proto.IDeleteTableRequest} message DeleteTableRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteTableRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteTableRequest message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.DeleteTableRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.DeleteTableRequest} DeleteTableRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteTableRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.DeleteTableRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tableName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("tableName"))
                    throw $util.ProtocolError("missing required 'tableName'", { instance: message });
                return message;
            };

            /**
             * Decodes a DeleteTableRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.DeleteTableRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.DeleteTableRequest} DeleteTableRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteTableRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteTableRequest message.
             * @function verify
             * @memberof main.proto.DeleteTableRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteTableRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.tableName))
                    return "tableName: string expected";
                return null;
            };

            /**
             * Creates a DeleteTableRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.DeleteTableRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.DeleteTableRequest} DeleteTableRequest
             */
            DeleteTableRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.DeleteTableRequest)
                    return object;
                var message = new $root.main.proto.DeleteTableRequest();
                if (object.tableName != null)
                    message.tableName = String(object.tableName);
                return message;
            };

            /**
             * Creates a plain object from a DeleteTableRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.DeleteTableRequest
             * @static
             * @param {main.proto.DeleteTableRequest} message DeleteTableRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteTableRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.tableName = "";
                if (message.tableName != null && message.hasOwnProperty("tableName"))
                    object.tableName = message.tableName;
                return object;
            };

            /**
             * Converts this DeleteTableRequest to JSON.
             * @function toJSON
             * @memberof main.proto.DeleteTableRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteTableRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DeleteTableRequest;
        })();

        proto.DeleteTableResponse = (function() {

            /**
             * Properties of a DeleteTableResponse.
             * @memberof main.proto
             * @interface IDeleteTableResponse
             */

            /**
             * Constructs a new DeleteTableResponse.
             * @memberof main.proto
             * @classdesc Represents a DeleteTableResponse.
             * @implements IDeleteTableResponse
             * @constructor
             * @param {main.proto.IDeleteTableResponse=} [properties] Properties to set
             */
            function DeleteTableResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new DeleteTableResponse instance using the specified properties.
             * @function create
             * @memberof main.proto.DeleteTableResponse
             * @static
             * @param {main.proto.IDeleteTableResponse=} [properties] Properties to set
             * @returns {main.proto.DeleteTableResponse} DeleteTableResponse instance
             */
            DeleteTableResponse.create = function create(properties) {
                return new DeleteTableResponse(properties);
            };

            /**
             * Encodes the specified DeleteTableResponse message. Does not implicitly {@link main.proto.DeleteTableResponse.verify|verify} messages.
             * @function encode
             * @memberof main.proto.DeleteTableResponse
             * @static
             * @param {main.proto.IDeleteTableResponse} message DeleteTableResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteTableResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified DeleteTableResponse message, length delimited. Does not implicitly {@link main.proto.DeleteTableResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.DeleteTableResponse
             * @static
             * @param {main.proto.IDeleteTableResponse} message DeleteTableResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteTableResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteTableResponse message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.DeleteTableResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.DeleteTableResponse} DeleteTableResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteTableResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.DeleteTableResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteTableResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.DeleteTableResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.DeleteTableResponse} DeleteTableResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteTableResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteTableResponse message.
             * @function verify
             * @memberof main.proto.DeleteTableResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteTableResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a DeleteTableResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.DeleteTableResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.DeleteTableResponse} DeleteTableResponse
             */
            DeleteTableResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.DeleteTableResponse)
                    return object;
                return new $root.main.proto.DeleteTableResponse();
            };

            /**
             * Creates a plain object from a DeleteTableResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.DeleteTableResponse
             * @static
             * @param {main.proto.DeleteTableResponse} message DeleteTableResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteTableResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this DeleteTableResponse to JSON.
             * @function toJSON
             * @memberof main.proto.DeleteTableResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteTableResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DeleteTableResponse;
        })();

        proto.LoadTableRequest = (function() {

            /**
             * Properties of a LoadTableRequest.
             * @memberof main.proto
             * @interface ILoadTableRequest
             * @property {string} tableName LoadTableRequest tableName
             */

            /**
             * Constructs a new LoadTableRequest.
             * @memberof main.proto
             * @classdesc Represents a LoadTableRequest.
             * @implements ILoadTableRequest
             * @constructor
             * @param {main.proto.ILoadTableRequest=} [properties] Properties to set
             */
            function LoadTableRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LoadTableRequest tableName.
             * @member {string} tableName
             * @memberof main.proto.LoadTableRequest
             * @instance
             */
            LoadTableRequest.prototype.tableName = "";

            /**
             * Creates a new LoadTableRequest instance using the specified properties.
             * @function create
             * @memberof main.proto.LoadTableRequest
             * @static
             * @param {main.proto.ILoadTableRequest=} [properties] Properties to set
             * @returns {main.proto.LoadTableRequest} LoadTableRequest instance
             */
            LoadTableRequest.create = function create(properties) {
                return new LoadTableRequest(properties);
            };

            /**
             * Encodes the specified LoadTableRequest message. Does not implicitly {@link main.proto.LoadTableRequest.verify|verify} messages.
             * @function encode
             * @memberof main.proto.LoadTableRequest
             * @static
             * @param {main.proto.ILoadTableRequest} message LoadTableRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoadTableRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.tableName);
                return writer;
            };

            /**
             * Encodes the specified LoadTableRequest message, length delimited. Does not implicitly {@link main.proto.LoadTableRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.LoadTableRequest
             * @static
             * @param {main.proto.ILoadTableRequest} message LoadTableRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoadTableRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LoadTableRequest message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.LoadTableRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.LoadTableRequest} LoadTableRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoadTableRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.LoadTableRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tableName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("tableName"))
                    throw $util.ProtocolError("missing required 'tableName'", { instance: message });
                return message;
            };

            /**
             * Decodes a LoadTableRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.LoadTableRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.LoadTableRequest} LoadTableRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoadTableRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LoadTableRequest message.
             * @function verify
             * @memberof main.proto.LoadTableRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LoadTableRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.tableName))
                    return "tableName: string expected";
                return null;
            };

            /**
             * Creates a LoadTableRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.LoadTableRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.LoadTableRequest} LoadTableRequest
             */
            LoadTableRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.LoadTableRequest)
                    return object;
                var message = new $root.main.proto.LoadTableRequest();
                if (object.tableName != null)
                    message.tableName = String(object.tableName);
                return message;
            };

            /**
             * Creates a plain object from a LoadTableRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.LoadTableRequest
             * @static
             * @param {main.proto.LoadTableRequest} message LoadTableRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LoadTableRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.tableName = "";
                if (message.tableName != null && message.hasOwnProperty("tableName"))
                    object.tableName = message.tableName;
                return object;
            };

            /**
             * Converts this LoadTableRequest to JSON.
             * @function toJSON
             * @memberof main.proto.LoadTableRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LoadTableRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return LoadTableRequest;
        })();

        proto.LoadTableResponse = (function() {

            /**
             * Properties of a LoadTableResponse.
             * @memberof main.proto
             * @interface ILoadTableResponse
             */

            /**
             * Constructs a new LoadTableResponse.
             * @memberof main.proto
             * @classdesc Represents a LoadTableResponse.
             * @implements ILoadTableResponse
             * @constructor
             * @param {main.proto.ILoadTableResponse=} [properties] Properties to set
             */
            function LoadTableResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new LoadTableResponse instance using the specified properties.
             * @function create
             * @memberof main.proto.LoadTableResponse
             * @static
             * @param {main.proto.ILoadTableResponse=} [properties] Properties to set
             * @returns {main.proto.LoadTableResponse} LoadTableResponse instance
             */
            LoadTableResponse.create = function create(properties) {
                return new LoadTableResponse(properties);
            };

            /**
             * Encodes the specified LoadTableResponse message. Does not implicitly {@link main.proto.LoadTableResponse.verify|verify} messages.
             * @function encode
             * @memberof main.proto.LoadTableResponse
             * @static
             * @param {main.proto.ILoadTableResponse} message LoadTableResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoadTableResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified LoadTableResponse message, length delimited. Does not implicitly {@link main.proto.LoadTableResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.LoadTableResponse
             * @static
             * @param {main.proto.ILoadTableResponse} message LoadTableResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoadTableResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LoadTableResponse message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.LoadTableResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.LoadTableResponse} LoadTableResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoadTableResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.LoadTableResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LoadTableResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.LoadTableResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.LoadTableResponse} LoadTableResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoadTableResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LoadTableResponse message.
             * @function verify
             * @memberof main.proto.LoadTableResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LoadTableResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a LoadTableResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.LoadTableResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.LoadTableResponse} LoadTableResponse
             */
            LoadTableResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.LoadTableResponse)
                    return object;
                return new $root.main.proto.LoadTableResponse();
            };

            /**
             * Creates a plain object from a LoadTableResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.LoadTableResponse
             * @static
             * @param {main.proto.LoadTableResponse} message LoadTableResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LoadTableResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this LoadTableResponse to JSON.
             * @function toJSON
             * @memberof main.proto.LoadTableResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LoadTableResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return LoadTableResponse;
        })();

        proto.UnloadTableRequest = (function() {

            /**
             * Properties of an UnloadTableRequest.
             * @memberof main.proto
             * @interface IUnloadTableRequest
             * @property {string} tableName UnloadTableRequest tableName
             */

            /**
             * Constructs a new UnloadTableRequest.
             * @memberof main.proto
             * @classdesc Represents an UnloadTableRequest.
             * @implements IUnloadTableRequest
             * @constructor
             * @param {main.proto.IUnloadTableRequest=} [properties] Properties to set
             */
            function UnloadTableRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UnloadTableRequest tableName.
             * @member {string} tableName
             * @memberof main.proto.UnloadTableRequest
             * @instance
             */
            UnloadTableRequest.prototype.tableName = "";

            /**
             * Creates a new UnloadTableRequest instance using the specified properties.
             * @function create
             * @memberof main.proto.UnloadTableRequest
             * @static
             * @param {main.proto.IUnloadTableRequest=} [properties] Properties to set
             * @returns {main.proto.UnloadTableRequest} UnloadTableRequest instance
             */
            UnloadTableRequest.create = function create(properties) {
                return new UnloadTableRequest(properties);
            };

            /**
             * Encodes the specified UnloadTableRequest message. Does not implicitly {@link main.proto.UnloadTableRequest.verify|verify} messages.
             * @function encode
             * @memberof main.proto.UnloadTableRequest
             * @static
             * @param {main.proto.IUnloadTableRequest} message UnloadTableRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UnloadTableRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.tableName);
                return writer;
            };

            /**
             * Encodes the specified UnloadTableRequest message, length delimited. Does not implicitly {@link main.proto.UnloadTableRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.UnloadTableRequest
             * @static
             * @param {main.proto.IUnloadTableRequest} message UnloadTableRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UnloadTableRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UnloadTableRequest message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.UnloadTableRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.UnloadTableRequest} UnloadTableRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UnloadTableRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.UnloadTableRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tableName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("tableName"))
                    throw $util.ProtocolError("missing required 'tableName'", { instance: message });
                return message;
            };

            /**
             * Decodes an UnloadTableRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.UnloadTableRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.UnloadTableRequest} UnloadTableRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UnloadTableRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UnloadTableRequest message.
             * @function verify
             * @memberof main.proto.UnloadTableRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UnloadTableRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.tableName))
                    return "tableName: string expected";
                return null;
            };

            /**
             * Creates an UnloadTableRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.UnloadTableRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.UnloadTableRequest} UnloadTableRequest
             */
            UnloadTableRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.UnloadTableRequest)
                    return object;
                var message = new $root.main.proto.UnloadTableRequest();
                if (object.tableName != null)
                    message.tableName = String(object.tableName);
                return message;
            };

            /**
             * Creates a plain object from an UnloadTableRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.UnloadTableRequest
             * @static
             * @param {main.proto.UnloadTableRequest} message UnloadTableRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UnloadTableRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.tableName = "";
                if (message.tableName != null && message.hasOwnProperty("tableName"))
                    object.tableName = message.tableName;
                return object;
            };

            /**
             * Converts this UnloadTableRequest to JSON.
             * @function toJSON
             * @memberof main.proto.UnloadTableRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UnloadTableRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return UnloadTableRequest;
        })();

        proto.UnloadTableResponse = (function() {

            /**
             * Properties of an UnloadTableResponse.
             * @memberof main.proto
             * @interface IUnloadTableResponse
             */

            /**
             * Constructs a new UnloadTableResponse.
             * @memberof main.proto
             * @classdesc Represents an UnloadTableResponse.
             * @implements IUnloadTableResponse
             * @constructor
             * @param {main.proto.IUnloadTableResponse=} [properties] Properties to set
             */
            function UnloadTableResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new UnloadTableResponse instance using the specified properties.
             * @function create
             * @memberof main.proto.UnloadTableResponse
             * @static
             * @param {main.proto.IUnloadTableResponse=} [properties] Properties to set
             * @returns {main.proto.UnloadTableResponse} UnloadTableResponse instance
             */
            UnloadTableResponse.create = function create(properties) {
                return new UnloadTableResponse(properties);
            };

            /**
             * Encodes the specified UnloadTableResponse message. Does not implicitly {@link main.proto.UnloadTableResponse.verify|verify} messages.
             * @function encode
             * @memberof main.proto.UnloadTableResponse
             * @static
             * @param {main.proto.IUnloadTableResponse} message UnloadTableResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UnloadTableResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified UnloadTableResponse message, length delimited. Does not implicitly {@link main.proto.UnloadTableResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.UnloadTableResponse
             * @static
             * @param {main.proto.IUnloadTableResponse} message UnloadTableResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UnloadTableResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UnloadTableResponse message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.UnloadTableResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.UnloadTableResponse} UnloadTableResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UnloadTableResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.UnloadTableResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UnloadTableResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.UnloadTableResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.UnloadTableResponse} UnloadTableResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UnloadTableResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UnloadTableResponse message.
             * @function verify
             * @memberof main.proto.UnloadTableResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UnloadTableResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an UnloadTableResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.UnloadTableResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.UnloadTableResponse} UnloadTableResponse
             */
            UnloadTableResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.UnloadTableResponse)
                    return object;
                return new $root.main.proto.UnloadTableResponse();
            };

            /**
             * Creates a plain object from an UnloadTableResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.UnloadTableResponse
             * @static
             * @param {main.proto.UnloadTableResponse} message UnloadTableResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UnloadTableResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this UnloadTableResponse to JSON.
             * @function toJSON
             * @memberof main.proto.UnloadTableResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UnloadTableResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return UnloadTableResponse;
        })();

        proto.TimeRange = (function() {

            /**
             * Properties of a TimeRange.
             * @memberof main.proto
             * @interface ITimeRange
             * @property {number|Long|null} [startTime] TimeRange startTime
             * @property {number|Long|null} [endTime] TimeRange endTime
             * @property {number|Long|null} [specificTime] TimeRange specificTime
             */

            /**
             * Constructs a new TimeRange.
             * @memberof main.proto
             * @classdesc 时间戳的取值最小值为0，最大值为INT64.MAX
             * 1. 若要查询一个范围，则指定start_time和end_time
             * 2. 若要查询一个特定时间戳，则指定specific_time
             * @implements ITimeRange
             * @constructor
             * @param {main.proto.ITimeRange=} [properties] Properties to set
             */
            function TimeRange(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TimeRange startTime.
             * @member {number|Long} startTime
             * @memberof main.proto.TimeRange
             * @instance
             */
            TimeRange.prototype.startTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * TimeRange endTime.
             * @member {number|Long} endTime
             * @memberof main.proto.TimeRange
             * @instance
             */
            TimeRange.prototype.endTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * TimeRange specificTime.
             * @member {number|Long} specificTime
             * @memberof main.proto.TimeRange
             * @instance
             */
            TimeRange.prototype.specificTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new TimeRange instance using the specified properties.
             * @function create
             * @memberof main.proto.TimeRange
             * @static
             * @param {main.proto.ITimeRange=} [properties] Properties to set
             * @returns {main.proto.TimeRange} TimeRange instance
             */
            TimeRange.create = function create(properties) {
                return new TimeRange(properties);
            };

            /**
             * Encodes the specified TimeRange message. Does not implicitly {@link main.proto.TimeRange.verify|verify} messages.
             * @function encode
             * @memberof main.proto.TimeRange
             * @static
             * @param {main.proto.ITimeRange} message TimeRange message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TimeRange.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.startTime != null && Object.hasOwnProperty.call(message, "startTime"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.startTime);
                if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.endTime);
                if (message.specificTime != null && Object.hasOwnProperty.call(message, "specificTime"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.specificTime);
                return writer;
            };

            /**
             * Encodes the specified TimeRange message, length delimited. Does not implicitly {@link main.proto.TimeRange.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.TimeRange
             * @static
             * @param {main.proto.ITimeRange} message TimeRange message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TimeRange.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TimeRange message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.TimeRange
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.TimeRange} TimeRange
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TimeRange.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.TimeRange();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.startTime = reader.int64();
                        break;
                    case 2:
                        message.endTime = reader.int64();
                        break;
                    case 3:
                        message.specificTime = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TimeRange message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.TimeRange
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.TimeRange} TimeRange
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TimeRange.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TimeRange message.
             * @function verify
             * @memberof main.proto.TimeRange
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TimeRange.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.startTime != null && message.hasOwnProperty("startTime"))
                    if (!$util.isInteger(message.startTime) && !(message.startTime && $util.isInteger(message.startTime.low) && $util.isInteger(message.startTime.high)))
                        return "startTime: integer|Long expected";
                if (message.endTime != null && message.hasOwnProperty("endTime"))
                    if (!$util.isInteger(message.endTime) && !(message.endTime && $util.isInteger(message.endTime.low) && $util.isInteger(message.endTime.high)))
                        return "endTime: integer|Long expected";
                if (message.specificTime != null && message.hasOwnProperty("specificTime"))
                    if (!$util.isInteger(message.specificTime) && !(message.specificTime && $util.isInteger(message.specificTime.low) && $util.isInteger(message.specificTime.high)))
                        return "specificTime: integer|Long expected";
                return null;
            };

            /**
             * Creates a TimeRange message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.TimeRange
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.TimeRange} TimeRange
             */
            TimeRange.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.TimeRange)
                    return object;
                var message = new $root.main.proto.TimeRange();
                if (object.startTime != null)
                    if ($util.Long)
                        (message.startTime = $util.Long.fromValue(object.startTime)).unsigned = false;
                    else if (typeof object.startTime === "string")
                        message.startTime = parseInt(object.startTime, 10);
                    else if (typeof object.startTime === "number")
                        message.startTime = object.startTime;
                    else if (typeof object.startTime === "object")
                        message.startTime = new $util.LongBits(object.startTime.low >>> 0, object.startTime.high >>> 0).toNumber();
                if (object.endTime != null)
                    if ($util.Long)
                        (message.endTime = $util.Long.fromValue(object.endTime)).unsigned = false;
                    else if (typeof object.endTime === "string")
                        message.endTime = parseInt(object.endTime, 10);
                    else if (typeof object.endTime === "number")
                        message.endTime = object.endTime;
                    else if (typeof object.endTime === "object")
                        message.endTime = new $util.LongBits(object.endTime.low >>> 0, object.endTime.high >>> 0).toNumber();
                if (object.specificTime != null)
                    if ($util.Long)
                        (message.specificTime = $util.Long.fromValue(object.specificTime)).unsigned = false;
                    else if (typeof object.specificTime === "string")
                        message.specificTime = parseInt(object.specificTime, 10);
                    else if (typeof object.specificTime === "number")
                        message.specificTime = object.specificTime;
                    else if (typeof object.specificTime === "object")
                        message.specificTime = new $util.LongBits(object.specificTime.low >>> 0, object.specificTime.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a TimeRange message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.TimeRange
             * @static
             * @param {main.proto.TimeRange} message TimeRange
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TimeRange.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.startTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.startTime = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.endTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.endTime = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.specificTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.specificTime = options.longs === String ? "0" : 0;
                }
                if (message.startTime != null && message.hasOwnProperty("startTime"))
                    if (typeof message.startTime === "number")
                        object.startTime = options.longs === String ? String(message.startTime) : message.startTime;
                    else
                        object.startTime = options.longs === String ? $util.Long.prototype.toString.call(message.startTime) : options.longs === Number ? new $util.LongBits(message.startTime.low >>> 0, message.startTime.high >>> 0).toNumber() : message.startTime;
                if (message.endTime != null && message.hasOwnProperty("endTime"))
                    if (typeof message.endTime === "number")
                        object.endTime = options.longs === String ? String(message.endTime) : message.endTime;
                    else
                        object.endTime = options.longs === String ? $util.Long.prototype.toString.call(message.endTime) : options.longs === Number ? new $util.LongBits(message.endTime.low >>> 0, message.endTime.high >>> 0).toNumber() : message.endTime;
                if (message.specificTime != null && message.hasOwnProperty("specificTime"))
                    if (typeof message.specificTime === "number")
                        object.specificTime = options.longs === String ? String(message.specificTime) : message.specificTime;
                    else
                        object.specificTime = options.longs === String ? $util.Long.prototype.toString.call(message.specificTime) : options.longs === Number ? new $util.LongBits(message.specificTime.low >>> 0, message.specificTime.high >>> 0).toNumber() : message.specificTime;
                return object;
            };

            /**
             * Converts this TimeRange to JSON.
             * @function toJSON
             * @memberof main.proto.TimeRange
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TimeRange.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TimeRange;
        })();

        /**
         * ReturnType enum.
         * @name main.proto.ReturnType
         * @enum {number}
         * @property {number} RT_NONE=0 RT_NONE value
         * @property {number} RT_PK=1 RT_PK value
         * @property {number} RT_AFTER_MODIFY=2 RT_AFTER_MODIFY value
         */
        proto.ReturnType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "RT_NONE"] = 0;
            values[valuesById[1] = "RT_PK"] = 1;
            values[valuesById[2] = "RT_AFTER_MODIFY"] = 2;
            return values;
        })();

        proto.ReturnContent = (function() {

            /**
             * Properties of a ReturnContent.
             * @memberof main.proto
             * @interface IReturnContent
             * @property {main.proto.ReturnType|null} [returnType] ReturnContent returnType
             * @property {Array.<string>|null} [returnColumnNames] ReturnContent returnColumnNames
             */

            /**
             * Constructs a new ReturnContent.
             * @memberof main.proto
             * @classdesc Represents a ReturnContent.
             * @implements IReturnContent
             * @constructor
             * @param {main.proto.IReturnContent=} [properties] Properties to set
             */
            function ReturnContent(properties) {
                this.returnColumnNames = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReturnContent returnType.
             * @member {main.proto.ReturnType} returnType
             * @memberof main.proto.ReturnContent
             * @instance
             */
            ReturnContent.prototype.returnType = 0;

            /**
             * ReturnContent returnColumnNames.
             * @member {Array.<string>} returnColumnNames
             * @memberof main.proto.ReturnContent
             * @instance
             */
            ReturnContent.prototype.returnColumnNames = $util.emptyArray;

            /**
             * Creates a new ReturnContent instance using the specified properties.
             * @function create
             * @memberof main.proto.ReturnContent
             * @static
             * @param {main.proto.IReturnContent=} [properties] Properties to set
             * @returns {main.proto.ReturnContent} ReturnContent instance
             */
            ReturnContent.create = function create(properties) {
                return new ReturnContent(properties);
            };

            /**
             * Encodes the specified ReturnContent message. Does not implicitly {@link main.proto.ReturnContent.verify|verify} messages.
             * @function encode
             * @memberof main.proto.ReturnContent
             * @static
             * @param {main.proto.IReturnContent} message ReturnContent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReturnContent.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.returnType != null && Object.hasOwnProperty.call(message, "returnType"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.returnType);
                if (message.returnColumnNames != null && message.returnColumnNames.length)
                    for (var i = 0; i < message.returnColumnNames.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.returnColumnNames[i]);
                return writer;
            };

            /**
             * Encodes the specified ReturnContent message, length delimited. Does not implicitly {@link main.proto.ReturnContent.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.ReturnContent
             * @static
             * @param {main.proto.IReturnContent} message ReturnContent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReturnContent.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReturnContent message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.ReturnContent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.ReturnContent} ReturnContent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReturnContent.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.ReturnContent();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.returnType = reader.int32();
                        break;
                    case 2:
                        if (!(message.returnColumnNames && message.returnColumnNames.length))
                            message.returnColumnNames = [];
                        message.returnColumnNames.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReturnContent message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.ReturnContent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.ReturnContent} ReturnContent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReturnContent.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReturnContent message.
             * @function verify
             * @memberof main.proto.ReturnContent
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReturnContent.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.returnType != null && message.hasOwnProperty("returnType"))
                    switch (message.returnType) {
                    default:
                        return "returnType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.returnColumnNames != null && message.hasOwnProperty("returnColumnNames")) {
                    if (!Array.isArray(message.returnColumnNames))
                        return "returnColumnNames: array expected";
                    for (var i = 0; i < message.returnColumnNames.length; ++i)
                        if (!$util.isString(message.returnColumnNames[i]))
                            return "returnColumnNames: string[] expected";
                }
                return null;
            };

            /**
             * Creates a ReturnContent message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.ReturnContent
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.ReturnContent} ReturnContent
             */
            ReturnContent.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.ReturnContent)
                    return object;
                var message = new $root.main.proto.ReturnContent();
                switch (object.returnType) {
                case "RT_NONE":
                case 0:
                    message.returnType = 0;
                    break;
                case "RT_PK":
                case 1:
                    message.returnType = 1;
                    break;
                case "RT_AFTER_MODIFY":
                case 2:
                    message.returnType = 2;
                    break;
                }
                if (object.returnColumnNames) {
                    if (!Array.isArray(object.returnColumnNames))
                        throw TypeError(".main.proto.ReturnContent.returnColumnNames: array expected");
                    message.returnColumnNames = [];
                    for (var i = 0; i < object.returnColumnNames.length; ++i)
                        message.returnColumnNames[i] = String(object.returnColumnNames[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReturnContent message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.ReturnContent
             * @static
             * @param {main.proto.ReturnContent} message ReturnContent
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReturnContent.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.returnColumnNames = [];
                if (options.defaults)
                    object.returnType = options.enums === String ? "RT_NONE" : 0;
                if (message.returnType != null && message.hasOwnProperty("returnType"))
                    object.returnType = options.enums === String ? $root.main.proto.ReturnType[message.returnType] : message.returnType;
                if (message.returnColumnNames && message.returnColumnNames.length) {
                    object.returnColumnNames = [];
                    for (var j = 0; j < message.returnColumnNames.length; ++j)
                        object.returnColumnNames[j] = message.returnColumnNames[j];
                }
                return object;
            };

            /**
             * Converts this ReturnContent to JSON.
             * @function toJSON
             * @memberof main.proto.ReturnContent
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReturnContent.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReturnContent;
        })();

        proto.GetRowRequest = (function() {

            /**
             * Properties of a GetRowRequest.
             * @memberof main.proto
             * @interface IGetRowRequest
             * @property {string} tableName GetRowRequest tableName
             * @property {Uint8Array} primaryKey GetRowRequest primaryKey
             * @property {Array.<string>|null} [columnsToGet] GetRowRequest columnsToGet
             * @property {main.proto.ITimeRange|null} [timeRange] GetRowRequest timeRange
             * @property {number|null} [maxVersions] GetRowRequest maxVersions
             * @property {boolean|null} [cacheBlocks] GetRowRequest cacheBlocks
             * @property {Uint8Array|null} [filter] GetRowRequest filter
             * @property {string|null} [startColumn] GetRowRequest startColumn
             * @property {string|null} [endColumn] GetRowRequest endColumn
             * @property {Uint8Array|null} [token] GetRowRequest token
             * @property {string|null} [transactionId] GetRowRequest transactionId
             */

            /**
             * Constructs a new GetRowRequest.
             * @memberof main.proto
             * @classdesc 1. 支持用户指定版本时间戳范围或者特定的版本时间来读取指定版本的列
             * 2. 目前暂不支持行内的断点
             * @implements IGetRowRequest
             * @constructor
             * @param {main.proto.IGetRowRequest=} [properties] Properties to set
             */
            function GetRowRequest(properties) {
                this.columnsToGet = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetRowRequest tableName.
             * @member {string} tableName
             * @memberof main.proto.GetRowRequest
             * @instance
             */
            GetRowRequest.prototype.tableName = "";

            /**
             * GetRowRequest primaryKey.
             * @member {Uint8Array} primaryKey
             * @memberof main.proto.GetRowRequest
             * @instance
             */
            GetRowRequest.prototype.primaryKey = $util.newBuffer([]);

            /**
             * GetRowRequest columnsToGet.
             * @member {Array.<string>} columnsToGet
             * @memberof main.proto.GetRowRequest
             * @instance
             */
            GetRowRequest.prototype.columnsToGet = $util.emptyArray;

            /**
             * GetRowRequest timeRange.
             * @member {main.proto.ITimeRange|null|undefined} timeRange
             * @memberof main.proto.GetRowRequest
             * @instance
             */
            GetRowRequest.prototype.timeRange = null;

            /**
             * GetRowRequest maxVersions.
             * @member {number} maxVersions
             * @memberof main.proto.GetRowRequest
             * @instance
             */
            GetRowRequest.prototype.maxVersions = 0;

            /**
             * GetRowRequest cacheBlocks.
             * @member {boolean} cacheBlocks
             * @memberof main.proto.GetRowRequest
             * @instance
             */
            GetRowRequest.prototype.cacheBlocks = true;

            /**
             * GetRowRequest filter.
             * @member {Uint8Array} filter
             * @memberof main.proto.GetRowRequest
             * @instance
             */
            GetRowRequest.prototype.filter = $util.newBuffer([]);

            /**
             * GetRowRequest startColumn.
             * @member {string} startColumn
             * @memberof main.proto.GetRowRequest
             * @instance
             */
            GetRowRequest.prototype.startColumn = "";

            /**
             * GetRowRequest endColumn.
             * @member {string} endColumn
             * @memberof main.proto.GetRowRequest
             * @instance
             */
            GetRowRequest.prototype.endColumn = "";

            /**
             * GetRowRequest token.
             * @member {Uint8Array} token
             * @memberof main.proto.GetRowRequest
             * @instance
             */
            GetRowRequest.prototype.token = $util.newBuffer([]);

            /**
             * GetRowRequest transactionId.
             * @member {string} transactionId
             * @memberof main.proto.GetRowRequest
             * @instance
             */
            GetRowRequest.prototype.transactionId = "";

            /**
             * Creates a new GetRowRequest instance using the specified properties.
             * @function create
             * @memberof main.proto.GetRowRequest
             * @static
             * @param {main.proto.IGetRowRequest=} [properties] Properties to set
             * @returns {main.proto.GetRowRequest} GetRowRequest instance
             */
            GetRowRequest.create = function create(properties) {
                return new GetRowRequest(properties);
            };

            /**
             * Encodes the specified GetRowRequest message. Does not implicitly {@link main.proto.GetRowRequest.verify|verify} messages.
             * @function encode
             * @memberof main.proto.GetRowRequest
             * @static
             * @param {main.proto.IGetRowRequest} message GetRowRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetRowRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.tableName);
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.primaryKey);
                if (message.columnsToGet != null && message.columnsToGet.length)
                    for (var i = 0; i < message.columnsToGet.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.columnsToGet[i]);
                if (message.timeRange != null && Object.hasOwnProperty.call(message, "timeRange"))
                    $root.main.proto.TimeRange.encode(message.timeRange, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.maxVersions != null && Object.hasOwnProperty.call(message, "maxVersions"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.maxVersions);
                if (message.cacheBlocks != null && Object.hasOwnProperty.call(message, "cacheBlocks"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.cacheBlocks);
                if (message.filter != null && Object.hasOwnProperty.call(message, "filter"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.filter);
                if (message.startColumn != null && Object.hasOwnProperty.call(message, "startColumn"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.startColumn);
                if (message.endColumn != null && Object.hasOwnProperty.call(message, "endColumn"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.endColumn);
                if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                    writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.token);
                if (message.transactionId != null && Object.hasOwnProperty.call(message, "transactionId"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.transactionId);
                return writer;
            };

            /**
             * Encodes the specified GetRowRequest message, length delimited. Does not implicitly {@link main.proto.GetRowRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.GetRowRequest
             * @static
             * @param {main.proto.IGetRowRequest} message GetRowRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetRowRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetRowRequest message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.GetRowRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.GetRowRequest} GetRowRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetRowRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.GetRowRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tableName = reader.string();
                        break;
                    case 2:
                        message.primaryKey = reader.bytes();
                        break;
                    case 3:
                        if (!(message.columnsToGet && message.columnsToGet.length))
                            message.columnsToGet = [];
                        message.columnsToGet.push(reader.string());
                        break;
                    case 4:
                        message.timeRange = $root.main.proto.TimeRange.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.maxVersions = reader.int32();
                        break;
                    case 6:
                        message.cacheBlocks = reader.bool();
                        break;
                    case 7:
                        message.filter = reader.bytes();
                        break;
                    case 8:
                        message.startColumn = reader.string();
                        break;
                    case 9:
                        message.endColumn = reader.string();
                        break;
                    case 10:
                        message.token = reader.bytes();
                        break;
                    case 11:
                        message.transactionId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("tableName"))
                    throw $util.ProtocolError("missing required 'tableName'", { instance: message });
                if (!message.hasOwnProperty("primaryKey"))
                    throw $util.ProtocolError("missing required 'primaryKey'", { instance: message });
                return message;
            };

            /**
             * Decodes a GetRowRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.GetRowRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.GetRowRequest} GetRowRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetRowRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetRowRequest message.
             * @function verify
             * @memberof main.proto.GetRowRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetRowRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.tableName))
                    return "tableName: string expected";
                if (!(message.primaryKey && typeof message.primaryKey.length === "number" || $util.isString(message.primaryKey)))
                    return "primaryKey: buffer expected";
                if (message.columnsToGet != null && message.hasOwnProperty("columnsToGet")) {
                    if (!Array.isArray(message.columnsToGet))
                        return "columnsToGet: array expected";
                    for (var i = 0; i < message.columnsToGet.length; ++i)
                        if (!$util.isString(message.columnsToGet[i]))
                            return "columnsToGet: string[] expected";
                }
                if (message.timeRange != null && message.hasOwnProperty("timeRange")) {
                    var error = $root.main.proto.TimeRange.verify(message.timeRange);
                    if (error)
                        return "timeRange." + error;
                }
                if (message.maxVersions != null && message.hasOwnProperty("maxVersions"))
                    if (!$util.isInteger(message.maxVersions))
                        return "maxVersions: integer expected";
                if (message.cacheBlocks != null && message.hasOwnProperty("cacheBlocks"))
                    if (typeof message.cacheBlocks !== "boolean")
                        return "cacheBlocks: boolean expected";
                if (message.filter != null && message.hasOwnProperty("filter"))
                    if (!(message.filter && typeof message.filter.length === "number" || $util.isString(message.filter)))
                        return "filter: buffer expected";
                if (message.startColumn != null && message.hasOwnProperty("startColumn"))
                    if (!$util.isString(message.startColumn))
                        return "startColumn: string expected";
                if (message.endColumn != null && message.hasOwnProperty("endColumn"))
                    if (!$util.isString(message.endColumn))
                        return "endColumn: string expected";
                if (message.token != null && message.hasOwnProperty("token"))
                    if (!(message.token && typeof message.token.length === "number" || $util.isString(message.token)))
                        return "token: buffer expected";
                if (message.transactionId != null && message.hasOwnProperty("transactionId"))
                    if (!$util.isString(message.transactionId))
                        return "transactionId: string expected";
                return null;
            };

            /**
             * Creates a GetRowRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.GetRowRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.GetRowRequest} GetRowRequest
             */
            GetRowRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.GetRowRequest)
                    return object;
                var message = new $root.main.proto.GetRowRequest();
                if (object.tableName != null)
                    message.tableName = String(object.tableName);
                if (object.primaryKey != null)
                    if (typeof object.primaryKey === "string")
                        $util.base64.decode(object.primaryKey, message.primaryKey = $util.newBuffer($util.base64.length(object.primaryKey)), 0);
                    else if (object.primaryKey.length)
                        message.primaryKey = object.primaryKey;
                if (object.columnsToGet) {
                    if (!Array.isArray(object.columnsToGet))
                        throw TypeError(".main.proto.GetRowRequest.columnsToGet: array expected");
                    message.columnsToGet = [];
                    for (var i = 0; i < object.columnsToGet.length; ++i)
                        message.columnsToGet[i] = String(object.columnsToGet[i]);
                }
                if (object.timeRange != null) {
                    if (typeof object.timeRange !== "object")
                        throw TypeError(".main.proto.GetRowRequest.timeRange: object expected");
                    message.timeRange = $root.main.proto.TimeRange.fromObject(object.timeRange);
                }
                if (object.maxVersions != null)
                    message.maxVersions = object.maxVersions | 0;
                if (object.cacheBlocks != null)
                    message.cacheBlocks = Boolean(object.cacheBlocks);
                if (object.filter != null)
                    if (typeof object.filter === "string")
                        $util.base64.decode(object.filter, message.filter = $util.newBuffer($util.base64.length(object.filter)), 0);
                    else if (object.filter.length)
                        message.filter = object.filter;
                if (object.startColumn != null)
                    message.startColumn = String(object.startColumn);
                if (object.endColumn != null)
                    message.endColumn = String(object.endColumn);
                if (object.token != null)
                    if (typeof object.token === "string")
                        $util.base64.decode(object.token, message.token = $util.newBuffer($util.base64.length(object.token)), 0);
                    else if (object.token.length)
                        message.token = object.token;
                if (object.transactionId != null)
                    message.transactionId = String(object.transactionId);
                return message;
            };

            /**
             * Creates a plain object from a GetRowRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.GetRowRequest
             * @static
             * @param {main.proto.GetRowRequest} message GetRowRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetRowRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.columnsToGet = [];
                if (options.defaults) {
                    object.tableName = "";
                    if (options.bytes === String)
                        object.primaryKey = "";
                    else {
                        object.primaryKey = [];
                        if (options.bytes !== Array)
                            object.primaryKey = $util.newBuffer(object.primaryKey);
                    }
                    object.timeRange = null;
                    object.maxVersions = 0;
                    object.cacheBlocks = true;
                    if (options.bytes === String)
                        object.filter = "";
                    else {
                        object.filter = [];
                        if (options.bytes !== Array)
                            object.filter = $util.newBuffer(object.filter);
                    }
                    object.startColumn = "";
                    object.endColumn = "";
                    if (options.bytes === String)
                        object.token = "";
                    else {
                        object.token = [];
                        if (options.bytes !== Array)
                            object.token = $util.newBuffer(object.token);
                    }
                    object.transactionId = "";
                }
                if (message.tableName != null && message.hasOwnProperty("tableName"))
                    object.tableName = message.tableName;
                if (message.primaryKey != null && message.hasOwnProperty("primaryKey"))
                    object.primaryKey = options.bytes === String ? $util.base64.encode(message.primaryKey, 0, message.primaryKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.primaryKey) : message.primaryKey;
                if (message.columnsToGet && message.columnsToGet.length) {
                    object.columnsToGet = [];
                    for (var j = 0; j < message.columnsToGet.length; ++j)
                        object.columnsToGet[j] = message.columnsToGet[j];
                }
                if (message.timeRange != null && message.hasOwnProperty("timeRange"))
                    object.timeRange = $root.main.proto.TimeRange.toObject(message.timeRange, options);
                if (message.maxVersions != null && message.hasOwnProperty("maxVersions"))
                    object.maxVersions = message.maxVersions;
                if (message.cacheBlocks != null && message.hasOwnProperty("cacheBlocks"))
                    object.cacheBlocks = message.cacheBlocks;
                if (message.filter != null && message.hasOwnProperty("filter"))
                    object.filter = options.bytes === String ? $util.base64.encode(message.filter, 0, message.filter.length) : options.bytes === Array ? Array.prototype.slice.call(message.filter) : message.filter;
                if (message.startColumn != null && message.hasOwnProperty("startColumn"))
                    object.startColumn = message.startColumn;
                if (message.endColumn != null && message.hasOwnProperty("endColumn"))
                    object.endColumn = message.endColumn;
                if (message.token != null && message.hasOwnProperty("token"))
                    object.token = options.bytes === String ? $util.base64.encode(message.token, 0, message.token.length) : options.bytes === Array ? Array.prototype.slice.call(message.token) : message.token;
                if (message.transactionId != null && message.hasOwnProperty("transactionId"))
                    object.transactionId = message.transactionId;
                return object;
            };

            /**
             * Converts this GetRowRequest to JSON.
             * @function toJSON
             * @memberof main.proto.GetRowRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetRowRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GetRowRequest;
        })();

        proto.GetRowResponse = (function() {

            /**
             * Properties of a GetRowResponse.
             * @memberof main.proto
             * @interface IGetRowResponse
             * @property {main.proto.IConsumedCapacity} consumed GetRowResponse consumed
             * @property {Uint8Array} row GetRowResponse row
             * @property {Uint8Array|null} [nextToken] GetRowResponse nextToken
             */

            /**
             * Constructs a new GetRowResponse.
             * @memberof main.proto
             * @classdesc Represents a GetRowResponse.
             * @implements IGetRowResponse
             * @constructor
             * @param {main.proto.IGetRowResponse=} [properties] Properties to set
             */
            function GetRowResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetRowResponse consumed.
             * @member {main.proto.IConsumedCapacity} consumed
             * @memberof main.proto.GetRowResponse
             * @instance
             */
            GetRowResponse.prototype.consumed = null;

            /**
             * GetRowResponse row.
             * @member {Uint8Array} row
             * @memberof main.proto.GetRowResponse
             * @instance
             */
            GetRowResponse.prototype.row = $util.newBuffer([]);

            /**
             * GetRowResponse nextToken.
             * @member {Uint8Array} nextToken
             * @memberof main.proto.GetRowResponse
             * @instance
             */
            GetRowResponse.prototype.nextToken = $util.newBuffer([]);

            /**
             * Creates a new GetRowResponse instance using the specified properties.
             * @function create
             * @memberof main.proto.GetRowResponse
             * @static
             * @param {main.proto.IGetRowResponse=} [properties] Properties to set
             * @returns {main.proto.GetRowResponse} GetRowResponse instance
             */
            GetRowResponse.create = function create(properties) {
                return new GetRowResponse(properties);
            };

            /**
             * Encodes the specified GetRowResponse message. Does not implicitly {@link main.proto.GetRowResponse.verify|verify} messages.
             * @function encode
             * @memberof main.proto.GetRowResponse
             * @static
             * @param {main.proto.IGetRowResponse} message GetRowResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetRowResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                $root.main.proto.ConsumedCapacity.encode(message.consumed, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.row);
                if (message.nextToken != null && Object.hasOwnProperty.call(message, "nextToken"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.nextToken);
                return writer;
            };

            /**
             * Encodes the specified GetRowResponse message, length delimited. Does not implicitly {@link main.proto.GetRowResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.GetRowResponse
             * @static
             * @param {main.proto.IGetRowResponse} message GetRowResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetRowResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetRowResponse message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.GetRowResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.GetRowResponse} GetRowResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetRowResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.GetRowResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.consumed = $root.main.proto.ConsumedCapacity.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.row = reader.bytes();
                        break;
                    case 3:
                        message.nextToken = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("consumed"))
                    throw $util.ProtocolError("missing required 'consumed'", { instance: message });
                if (!message.hasOwnProperty("row"))
                    throw $util.ProtocolError("missing required 'row'", { instance: message });
                return message;
            };

            /**
             * Decodes a GetRowResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.GetRowResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.GetRowResponse} GetRowResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetRowResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetRowResponse message.
             * @function verify
             * @memberof main.proto.GetRowResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetRowResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                {
                    var error = $root.main.proto.ConsumedCapacity.verify(message.consumed);
                    if (error)
                        return "consumed." + error;
                }
                if (!(message.row && typeof message.row.length === "number" || $util.isString(message.row)))
                    return "row: buffer expected";
                if (message.nextToken != null && message.hasOwnProperty("nextToken"))
                    if (!(message.nextToken && typeof message.nextToken.length === "number" || $util.isString(message.nextToken)))
                        return "nextToken: buffer expected";
                return null;
            };

            /**
             * Creates a GetRowResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.GetRowResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.GetRowResponse} GetRowResponse
             */
            GetRowResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.GetRowResponse)
                    return object;
                var message = new $root.main.proto.GetRowResponse();
                if (object.consumed != null) {
                    if (typeof object.consumed !== "object")
                        throw TypeError(".main.proto.GetRowResponse.consumed: object expected");
                    message.consumed = $root.main.proto.ConsumedCapacity.fromObject(object.consumed);
                }
                if (object.row != null)
                    if (typeof object.row === "string")
                        $util.base64.decode(object.row, message.row = $util.newBuffer($util.base64.length(object.row)), 0);
                    else if (object.row.length)
                        message.row = object.row;
                if (object.nextToken != null)
                    if (typeof object.nextToken === "string")
                        $util.base64.decode(object.nextToken, message.nextToken = $util.newBuffer($util.base64.length(object.nextToken)), 0);
                    else if (object.nextToken.length)
                        message.nextToken = object.nextToken;
                return message;
            };

            /**
             * Creates a plain object from a GetRowResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.GetRowResponse
             * @static
             * @param {main.proto.GetRowResponse} message GetRowResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetRowResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.consumed = null;
                    if (options.bytes === String)
                        object.row = "";
                    else {
                        object.row = [];
                        if (options.bytes !== Array)
                            object.row = $util.newBuffer(object.row);
                    }
                    if (options.bytes === String)
                        object.nextToken = "";
                    else {
                        object.nextToken = [];
                        if (options.bytes !== Array)
                            object.nextToken = $util.newBuffer(object.nextToken);
                    }
                }
                if (message.consumed != null && message.hasOwnProperty("consumed"))
                    object.consumed = $root.main.proto.ConsumedCapacity.toObject(message.consumed, options);
                if (message.row != null && message.hasOwnProperty("row"))
                    object.row = options.bytes === String ? $util.base64.encode(message.row, 0, message.row.length) : options.bytes === Array ? Array.prototype.slice.call(message.row) : message.row;
                if (message.nextToken != null && message.hasOwnProperty("nextToken"))
                    object.nextToken = options.bytes === String ? $util.base64.encode(message.nextToken, 0, message.nextToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.nextToken) : message.nextToken;
                return object;
            };

            /**
             * Converts this GetRowResponse to JSON.
             * @function toJSON
             * @memberof main.proto.GetRowResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetRowResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GetRowResponse;
        })();

        proto.UpdateRowRequest = (function() {

            /**
             * Properties of an UpdateRowRequest.
             * @memberof main.proto
             * @interface IUpdateRowRequest
             * @property {string} tableName UpdateRowRequest tableName
             * @property {Uint8Array} rowChange UpdateRowRequest rowChange
             * @property {main.proto.ICondition} condition UpdateRowRequest condition
             * @property {main.proto.IReturnContent|null} [returnContent] UpdateRowRequest returnContent
             * @property {string|null} [transactionId] UpdateRowRequest transactionId
             */

            /**
             * Constructs a new UpdateRowRequest.
             * @memberof main.proto
             * @classdesc Represents an UpdateRowRequest.
             * @implements IUpdateRowRequest
             * @constructor
             * @param {main.proto.IUpdateRowRequest=} [properties] Properties to set
             */
            function UpdateRowRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UpdateRowRequest tableName.
             * @member {string} tableName
             * @memberof main.proto.UpdateRowRequest
             * @instance
             */
            UpdateRowRequest.prototype.tableName = "";

            /**
             * UpdateRowRequest rowChange.
             * @member {Uint8Array} rowChange
             * @memberof main.proto.UpdateRowRequest
             * @instance
             */
            UpdateRowRequest.prototype.rowChange = $util.newBuffer([]);

            /**
             * UpdateRowRequest condition.
             * @member {main.proto.ICondition} condition
             * @memberof main.proto.UpdateRowRequest
             * @instance
             */
            UpdateRowRequest.prototype.condition = null;

            /**
             * UpdateRowRequest returnContent.
             * @member {main.proto.IReturnContent|null|undefined} returnContent
             * @memberof main.proto.UpdateRowRequest
             * @instance
             */
            UpdateRowRequest.prototype.returnContent = null;

            /**
             * UpdateRowRequest transactionId.
             * @member {string} transactionId
             * @memberof main.proto.UpdateRowRequest
             * @instance
             */
            UpdateRowRequest.prototype.transactionId = "";

            /**
             * Creates a new UpdateRowRequest instance using the specified properties.
             * @function create
             * @memberof main.proto.UpdateRowRequest
             * @static
             * @param {main.proto.IUpdateRowRequest=} [properties] Properties to set
             * @returns {main.proto.UpdateRowRequest} UpdateRowRequest instance
             */
            UpdateRowRequest.create = function create(properties) {
                return new UpdateRowRequest(properties);
            };

            /**
             * Encodes the specified UpdateRowRequest message. Does not implicitly {@link main.proto.UpdateRowRequest.verify|verify} messages.
             * @function encode
             * @memberof main.proto.UpdateRowRequest
             * @static
             * @param {main.proto.IUpdateRowRequest} message UpdateRowRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateRowRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.tableName);
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.rowChange);
                $root.main.proto.Condition.encode(message.condition, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.returnContent != null && Object.hasOwnProperty.call(message, "returnContent"))
                    $root.main.proto.ReturnContent.encode(message.returnContent, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.transactionId != null && Object.hasOwnProperty.call(message, "transactionId"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.transactionId);
                return writer;
            };

            /**
             * Encodes the specified UpdateRowRequest message, length delimited. Does not implicitly {@link main.proto.UpdateRowRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.UpdateRowRequest
             * @static
             * @param {main.proto.IUpdateRowRequest} message UpdateRowRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateRowRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UpdateRowRequest message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.UpdateRowRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.UpdateRowRequest} UpdateRowRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateRowRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.UpdateRowRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tableName = reader.string();
                        break;
                    case 2:
                        message.rowChange = reader.bytes();
                        break;
                    case 3:
                        message.condition = $root.main.proto.Condition.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.returnContent = $root.main.proto.ReturnContent.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.transactionId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("tableName"))
                    throw $util.ProtocolError("missing required 'tableName'", { instance: message });
                if (!message.hasOwnProperty("rowChange"))
                    throw $util.ProtocolError("missing required 'rowChange'", { instance: message });
                if (!message.hasOwnProperty("condition"))
                    throw $util.ProtocolError("missing required 'condition'", { instance: message });
                return message;
            };

            /**
             * Decodes an UpdateRowRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.UpdateRowRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.UpdateRowRequest} UpdateRowRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateRowRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UpdateRowRequest message.
             * @function verify
             * @memberof main.proto.UpdateRowRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UpdateRowRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.tableName))
                    return "tableName: string expected";
                if (!(message.rowChange && typeof message.rowChange.length === "number" || $util.isString(message.rowChange)))
                    return "rowChange: buffer expected";
                {
                    var error = $root.main.proto.Condition.verify(message.condition);
                    if (error)
                        return "condition." + error;
                }
                if (message.returnContent != null && message.hasOwnProperty("returnContent")) {
                    var error = $root.main.proto.ReturnContent.verify(message.returnContent);
                    if (error)
                        return "returnContent." + error;
                }
                if (message.transactionId != null && message.hasOwnProperty("transactionId"))
                    if (!$util.isString(message.transactionId))
                        return "transactionId: string expected";
                return null;
            };

            /**
             * Creates an UpdateRowRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.UpdateRowRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.UpdateRowRequest} UpdateRowRequest
             */
            UpdateRowRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.UpdateRowRequest)
                    return object;
                var message = new $root.main.proto.UpdateRowRequest();
                if (object.tableName != null)
                    message.tableName = String(object.tableName);
                if (object.rowChange != null)
                    if (typeof object.rowChange === "string")
                        $util.base64.decode(object.rowChange, message.rowChange = $util.newBuffer($util.base64.length(object.rowChange)), 0);
                    else if (object.rowChange.length)
                        message.rowChange = object.rowChange;
                if (object.condition != null) {
                    if (typeof object.condition !== "object")
                        throw TypeError(".main.proto.UpdateRowRequest.condition: object expected");
                    message.condition = $root.main.proto.Condition.fromObject(object.condition);
                }
                if (object.returnContent != null) {
                    if (typeof object.returnContent !== "object")
                        throw TypeError(".main.proto.UpdateRowRequest.returnContent: object expected");
                    message.returnContent = $root.main.proto.ReturnContent.fromObject(object.returnContent);
                }
                if (object.transactionId != null)
                    message.transactionId = String(object.transactionId);
                return message;
            };

            /**
             * Creates a plain object from an UpdateRowRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.UpdateRowRequest
             * @static
             * @param {main.proto.UpdateRowRequest} message UpdateRowRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UpdateRowRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.tableName = "";
                    if (options.bytes === String)
                        object.rowChange = "";
                    else {
                        object.rowChange = [];
                        if (options.bytes !== Array)
                            object.rowChange = $util.newBuffer(object.rowChange);
                    }
                    object.condition = null;
                    object.returnContent = null;
                    object.transactionId = "";
                }
                if (message.tableName != null && message.hasOwnProperty("tableName"))
                    object.tableName = message.tableName;
                if (message.rowChange != null && message.hasOwnProperty("rowChange"))
                    object.rowChange = options.bytes === String ? $util.base64.encode(message.rowChange, 0, message.rowChange.length) : options.bytes === Array ? Array.prototype.slice.call(message.rowChange) : message.rowChange;
                if (message.condition != null && message.hasOwnProperty("condition"))
                    object.condition = $root.main.proto.Condition.toObject(message.condition, options);
                if (message.returnContent != null && message.hasOwnProperty("returnContent"))
                    object.returnContent = $root.main.proto.ReturnContent.toObject(message.returnContent, options);
                if (message.transactionId != null && message.hasOwnProperty("transactionId"))
                    object.transactionId = message.transactionId;
                return object;
            };

            /**
             * Converts this UpdateRowRequest to JSON.
             * @function toJSON
             * @memberof main.proto.UpdateRowRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UpdateRowRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return UpdateRowRequest;
        })();

        proto.UpdateRowResponse = (function() {

            /**
             * Properties of an UpdateRowResponse.
             * @memberof main.proto
             * @interface IUpdateRowResponse
             * @property {main.proto.IConsumedCapacity} consumed UpdateRowResponse consumed
             * @property {Uint8Array|null} [row] UpdateRowResponse row
             */

            /**
             * Constructs a new UpdateRowResponse.
             * @memberof main.proto
             * @classdesc Represents an UpdateRowResponse.
             * @implements IUpdateRowResponse
             * @constructor
             * @param {main.proto.IUpdateRowResponse=} [properties] Properties to set
             */
            function UpdateRowResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UpdateRowResponse consumed.
             * @member {main.proto.IConsumedCapacity} consumed
             * @memberof main.proto.UpdateRowResponse
             * @instance
             */
            UpdateRowResponse.prototype.consumed = null;

            /**
             * UpdateRowResponse row.
             * @member {Uint8Array} row
             * @memberof main.proto.UpdateRowResponse
             * @instance
             */
            UpdateRowResponse.prototype.row = $util.newBuffer([]);

            /**
             * Creates a new UpdateRowResponse instance using the specified properties.
             * @function create
             * @memberof main.proto.UpdateRowResponse
             * @static
             * @param {main.proto.IUpdateRowResponse=} [properties] Properties to set
             * @returns {main.proto.UpdateRowResponse} UpdateRowResponse instance
             */
            UpdateRowResponse.create = function create(properties) {
                return new UpdateRowResponse(properties);
            };

            /**
             * Encodes the specified UpdateRowResponse message. Does not implicitly {@link main.proto.UpdateRowResponse.verify|verify} messages.
             * @function encode
             * @memberof main.proto.UpdateRowResponse
             * @static
             * @param {main.proto.IUpdateRowResponse} message UpdateRowResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateRowResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                $root.main.proto.ConsumedCapacity.encode(message.consumed, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.row != null && Object.hasOwnProperty.call(message, "row"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.row);
                return writer;
            };

            /**
             * Encodes the specified UpdateRowResponse message, length delimited. Does not implicitly {@link main.proto.UpdateRowResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.UpdateRowResponse
             * @static
             * @param {main.proto.IUpdateRowResponse} message UpdateRowResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateRowResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UpdateRowResponse message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.UpdateRowResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.UpdateRowResponse} UpdateRowResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateRowResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.UpdateRowResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.consumed = $root.main.proto.ConsumedCapacity.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.row = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("consumed"))
                    throw $util.ProtocolError("missing required 'consumed'", { instance: message });
                return message;
            };

            /**
             * Decodes an UpdateRowResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.UpdateRowResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.UpdateRowResponse} UpdateRowResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateRowResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UpdateRowResponse message.
             * @function verify
             * @memberof main.proto.UpdateRowResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UpdateRowResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                {
                    var error = $root.main.proto.ConsumedCapacity.verify(message.consumed);
                    if (error)
                        return "consumed." + error;
                }
                if (message.row != null && message.hasOwnProperty("row"))
                    if (!(message.row && typeof message.row.length === "number" || $util.isString(message.row)))
                        return "row: buffer expected";
                return null;
            };

            /**
             * Creates an UpdateRowResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.UpdateRowResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.UpdateRowResponse} UpdateRowResponse
             */
            UpdateRowResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.UpdateRowResponse)
                    return object;
                var message = new $root.main.proto.UpdateRowResponse();
                if (object.consumed != null) {
                    if (typeof object.consumed !== "object")
                        throw TypeError(".main.proto.UpdateRowResponse.consumed: object expected");
                    message.consumed = $root.main.proto.ConsumedCapacity.fromObject(object.consumed);
                }
                if (object.row != null)
                    if (typeof object.row === "string")
                        $util.base64.decode(object.row, message.row = $util.newBuffer($util.base64.length(object.row)), 0);
                    else if (object.row.length)
                        message.row = object.row;
                return message;
            };

            /**
             * Creates a plain object from an UpdateRowResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.UpdateRowResponse
             * @static
             * @param {main.proto.UpdateRowResponse} message UpdateRowResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UpdateRowResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.consumed = null;
                    if (options.bytes === String)
                        object.row = "";
                    else {
                        object.row = [];
                        if (options.bytes !== Array)
                            object.row = $util.newBuffer(object.row);
                    }
                }
                if (message.consumed != null && message.hasOwnProperty("consumed"))
                    object.consumed = $root.main.proto.ConsumedCapacity.toObject(message.consumed, options);
                if (message.row != null && message.hasOwnProperty("row"))
                    object.row = options.bytes === String ? $util.base64.encode(message.row, 0, message.row.length) : options.bytes === Array ? Array.prototype.slice.call(message.row) : message.row;
                return object;
            };

            /**
             * Converts this UpdateRowResponse to JSON.
             * @function toJSON
             * @memberof main.proto.UpdateRowResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UpdateRowResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return UpdateRowResponse;
        })();

        proto.PutRowRequest = (function() {

            /**
             * Properties of a PutRowRequest.
             * @memberof main.proto
             * @interface IPutRowRequest
             * @property {string} tableName PutRowRequest tableName
             * @property {Uint8Array} row PutRowRequest row
             * @property {main.proto.ICondition} condition PutRowRequest condition
             * @property {main.proto.IReturnContent|null} [returnContent] PutRowRequest returnContent
             * @property {string|null} [transactionId] PutRowRequest transactionId
             */

            /**
             * Constructs a new PutRowRequest.
             * @memberof main.proto
             * @classdesc 这里允许用户为每列单独设置timestamp，而不是强制整行统一一个timestamp。
             * 原因是列都是用统一的结构，该结构本身是带timestamp的，其次强制统一timestamp增强了规范性但是丧失了灵活性，且该规范性没有明显的好处，反而带来了结构的复杂。
             * @implements IPutRowRequest
             * @constructor
             * @param {main.proto.IPutRowRequest=} [properties] Properties to set
             */
            function PutRowRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PutRowRequest tableName.
             * @member {string} tableName
             * @memberof main.proto.PutRowRequest
             * @instance
             */
            PutRowRequest.prototype.tableName = "";

            /**
             * PutRowRequest row.
             * @member {Uint8Array} row
             * @memberof main.proto.PutRowRequest
             * @instance
             */
            PutRowRequest.prototype.row = $util.newBuffer([]);

            /**
             * PutRowRequest condition.
             * @member {main.proto.ICondition} condition
             * @memberof main.proto.PutRowRequest
             * @instance
             */
            PutRowRequest.prototype.condition = null;

            /**
             * PutRowRequest returnContent.
             * @member {main.proto.IReturnContent|null|undefined} returnContent
             * @memberof main.proto.PutRowRequest
             * @instance
             */
            PutRowRequest.prototype.returnContent = null;

            /**
             * PutRowRequest transactionId.
             * @member {string} transactionId
             * @memberof main.proto.PutRowRequest
             * @instance
             */
            PutRowRequest.prototype.transactionId = "";

            /**
             * Creates a new PutRowRequest instance using the specified properties.
             * @function create
             * @memberof main.proto.PutRowRequest
             * @static
             * @param {main.proto.IPutRowRequest=} [properties] Properties to set
             * @returns {main.proto.PutRowRequest} PutRowRequest instance
             */
            PutRowRequest.create = function create(properties) {
                return new PutRowRequest(properties);
            };

            /**
             * Encodes the specified PutRowRequest message. Does not implicitly {@link main.proto.PutRowRequest.verify|verify} messages.
             * @function encode
             * @memberof main.proto.PutRowRequest
             * @static
             * @param {main.proto.IPutRowRequest} message PutRowRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PutRowRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.tableName);
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.row);
                $root.main.proto.Condition.encode(message.condition, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.returnContent != null && Object.hasOwnProperty.call(message, "returnContent"))
                    $root.main.proto.ReturnContent.encode(message.returnContent, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.transactionId != null && Object.hasOwnProperty.call(message, "transactionId"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.transactionId);
                return writer;
            };

            /**
             * Encodes the specified PutRowRequest message, length delimited. Does not implicitly {@link main.proto.PutRowRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.PutRowRequest
             * @static
             * @param {main.proto.IPutRowRequest} message PutRowRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PutRowRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PutRowRequest message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.PutRowRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.PutRowRequest} PutRowRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PutRowRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.PutRowRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tableName = reader.string();
                        break;
                    case 2:
                        message.row = reader.bytes();
                        break;
                    case 3:
                        message.condition = $root.main.proto.Condition.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.returnContent = $root.main.proto.ReturnContent.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.transactionId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("tableName"))
                    throw $util.ProtocolError("missing required 'tableName'", { instance: message });
                if (!message.hasOwnProperty("row"))
                    throw $util.ProtocolError("missing required 'row'", { instance: message });
                if (!message.hasOwnProperty("condition"))
                    throw $util.ProtocolError("missing required 'condition'", { instance: message });
                return message;
            };

            /**
             * Decodes a PutRowRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.PutRowRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.PutRowRequest} PutRowRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PutRowRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PutRowRequest message.
             * @function verify
             * @memberof main.proto.PutRowRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PutRowRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.tableName))
                    return "tableName: string expected";
                if (!(message.row && typeof message.row.length === "number" || $util.isString(message.row)))
                    return "row: buffer expected";
                {
                    var error = $root.main.proto.Condition.verify(message.condition);
                    if (error)
                        return "condition." + error;
                }
                if (message.returnContent != null && message.hasOwnProperty("returnContent")) {
                    var error = $root.main.proto.ReturnContent.verify(message.returnContent);
                    if (error)
                        return "returnContent." + error;
                }
                if (message.transactionId != null && message.hasOwnProperty("transactionId"))
                    if (!$util.isString(message.transactionId))
                        return "transactionId: string expected";
                return null;
            };

            /**
             * Creates a PutRowRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.PutRowRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.PutRowRequest} PutRowRequest
             */
            PutRowRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.PutRowRequest)
                    return object;
                var message = new $root.main.proto.PutRowRequest();
                if (object.tableName != null)
                    message.tableName = String(object.tableName);
                if (object.row != null)
                    if (typeof object.row === "string")
                        $util.base64.decode(object.row, message.row = $util.newBuffer($util.base64.length(object.row)), 0);
                    else if (object.row.length)
                        message.row = object.row;
                if (object.condition != null) {
                    if (typeof object.condition !== "object")
                        throw TypeError(".main.proto.PutRowRequest.condition: object expected");
                    message.condition = $root.main.proto.Condition.fromObject(object.condition);
                }
                if (object.returnContent != null) {
                    if (typeof object.returnContent !== "object")
                        throw TypeError(".main.proto.PutRowRequest.returnContent: object expected");
                    message.returnContent = $root.main.proto.ReturnContent.fromObject(object.returnContent);
                }
                if (object.transactionId != null)
                    message.transactionId = String(object.transactionId);
                return message;
            };

            /**
             * Creates a plain object from a PutRowRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.PutRowRequest
             * @static
             * @param {main.proto.PutRowRequest} message PutRowRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PutRowRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.tableName = "";
                    if (options.bytes === String)
                        object.row = "";
                    else {
                        object.row = [];
                        if (options.bytes !== Array)
                            object.row = $util.newBuffer(object.row);
                    }
                    object.condition = null;
                    object.returnContent = null;
                    object.transactionId = "";
                }
                if (message.tableName != null && message.hasOwnProperty("tableName"))
                    object.tableName = message.tableName;
                if (message.row != null && message.hasOwnProperty("row"))
                    object.row = options.bytes === String ? $util.base64.encode(message.row, 0, message.row.length) : options.bytes === Array ? Array.prototype.slice.call(message.row) : message.row;
                if (message.condition != null && message.hasOwnProperty("condition"))
                    object.condition = $root.main.proto.Condition.toObject(message.condition, options);
                if (message.returnContent != null && message.hasOwnProperty("returnContent"))
                    object.returnContent = $root.main.proto.ReturnContent.toObject(message.returnContent, options);
                if (message.transactionId != null && message.hasOwnProperty("transactionId"))
                    object.transactionId = message.transactionId;
                return object;
            };

            /**
             * Converts this PutRowRequest to JSON.
             * @function toJSON
             * @memberof main.proto.PutRowRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PutRowRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PutRowRequest;
        })();

        proto.PutRowResponse = (function() {

            /**
             * Properties of a PutRowResponse.
             * @memberof main.proto
             * @interface IPutRowResponse
             * @property {main.proto.IConsumedCapacity} consumed PutRowResponse consumed
             * @property {Uint8Array|null} [row] PutRowResponse row
             */

            /**
             * Constructs a new PutRowResponse.
             * @memberof main.proto
             * @classdesc Represents a PutRowResponse.
             * @implements IPutRowResponse
             * @constructor
             * @param {main.proto.IPutRowResponse=} [properties] Properties to set
             */
            function PutRowResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PutRowResponse consumed.
             * @member {main.proto.IConsumedCapacity} consumed
             * @memberof main.proto.PutRowResponse
             * @instance
             */
            PutRowResponse.prototype.consumed = null;

            /**
             * PutRowResponse row.
             * @member {Uint8Array} row
             * @memberof main.proto.PutRowResponse
             * @instance
             */
            PutRowResponse.prototype.row = $util.newBuffer([]);

            /**
             * Creates a new PutRowResponse instance using the specified properties.
             * @function create
             * @memberof main.proto.PutRowResponse
             * @static
             * @param {main.proto.IPutRowResponse=} [properties] Properties to set
             * @returns {main.proto.PutRowResponse} PutRowResponse instance
             */
            PutRowResponse.create = function create(properties) {
                return new PutRowResponse(properties);
            };

            /**
             * Encodes the specified PutRowResponse message. Does not implicitly {@link main.proto.PutRowResponse.verify|verify} messages.
             * @function encode
             * @memberof main.proto.PutRowResponse
             * @static
             * @param {main.proto.IPutRowResponse} message PutRowResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PutRowResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                $root.main.proto.ConsumedCapacity.encode(message.consumed, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.row != null && Object.hasOwnProperty.call(message, "row"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.row);
                return writer;
            };

            /**
             * Encodes the specified PutRowResponse message, length delimited. Does not implicitly {@link main.proto.PutRowResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.PutRowResponse
             * @static
             * @param {main.proto.IPutRowResponse} message PutRowResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PutRowResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PutRowResponse message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.PutRowResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.PutRowResponse} PutRowResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PutRowResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.PutRowResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.consumed = $root.main.proto.ConsumedCapacity.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.row = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("consumed"))
                    throw $util.ProtocolError("missing required 'consumed'", { instance: message });
                return message;
            };

            /**
             * Decodes a PutRowResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.PutRowResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.PutRowResponse} PutRowResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PutRowResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PutRowResponse message.
             * @function verify
             * @memberof main.proto.PutRowResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PutRowResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                {
                    var error = $root.main.proto.ConsumedCapacity.verify(message.consumed);
                    if (error)
                        return "consumed." + error;
                }
                if (message.row != null && message.hasOwnProperty("row"))
                    if (!(message.row && typeof message.row.length === "number" || $util.isString(message.row)))
                        return "row: buffer expected";
                return null;
            };

            /**
             * Creates a PutRowResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.PutRowResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.PutRowResponse} PutRowResponse
             */
            PutRowResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.PutRowResponse)
                    return object;
                var message = new $root.main.proto.PutRowResponse();
                if (object.consumed != null) {
                    if (typeof object.consumed !== "object")
                        throw TypeError(".main.proto.PutRowResponse.consumed: object expected");
                    message.consumed = $root.main.proto.ConsumedCapacity.fromObject(object.consumed);
                }
                if (object.row != null)
                    if (typeof object.row === "string")
                        $util.base64.decode(object.row, message.row = $util.newBuffer($util.base64.length(object.row)), 0);
                    else if (object.row.length)
                        message.row = object.row;
                return message;
            };

            /**
             * Creates a plain object from a PutRowResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.PutRowResponse
             * @static
             * @param {main.proto.PutRowResponse} message PutRowResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PutRowResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.consumed = null;
                    if (options.bytes === String)
                        object.row = "";
                    else {
                        object.row = [];
                        if (options.bytes !== Array)
                            object.row = $util.newBuffer(object.row);
                    }
                }
                if (message.consumed != null && message.hasOwnProperty("consumed"))
                    object.consumed = $root.main.proto.ConsumedCapacity.toObject(message.consumed, options);
                if (message.row != null && message.hasOwnProperty("row"))
                    object.row = options.bytes === String ? $util.base64.encode(message.row, 0, message.row.length) : options.bytes === Array ? Array.prototype.slice.call(message.row) : message.row;
                return object;
            };

            /**
             * Converts this PutRowResponse to JSON.
             * @function toJSON
             * @memberof main.proto.PutRowResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PutRowResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PutRowResponse;
        })();

        proto.DeleteRowRequest = (function() {

            /**
             * Properties of a DeleteRowRequest.
             * @memberof main.proto
             * @interface IDeleteRowRequest
             * @property {string} tableName DeleteRowRequest tableName
             * @property {Uint8Array} primaryKey DeleteRowRequest primaryKey
             * @property {main.proto.ICondition} condition DeleteRowRequest condition
             * @property {main.proto.IReturnContent|null} [returnContent] DeleteRowRequest returnContent
             * @property {string|null} [transactionId] DeleteRowRequest transactionId
             */

            /**
             * Constructs a new DeleteRowRequest.
             * @memberof main.proto
             * @classdesc OTS只支持删除该行的所有列所有版本，不支持：
             * 1. 删除所有列的所有小于等于某个版本的所有版本
             * @implements IDeleteRowRequest
             * @constructor
             * @param {main.proto.IDeleteRowRequest=} [properties] Properties to set
             */
            function DeleteRowRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeleteRowRequest tableName.
             * @member {string} tableName
             * @memberof main.proto.DeleteRowRequest
             * @instance
             */
            DeleteRowRequest.prototype.tableName = "";

            /**
             * DeleteRowRequest primaryKey.
             * @member {Uint8Array} primaryKey
             * @memberof main.proto.DeleteRowRequest
             * @instance
             */
            DeleteRowRequest.prototype.primaryKey = $util.newBuffer([]);

            /**
             * DeleteRowRequest condition.
             * @member {main.proto.ICondition} condition
             * @memberof main.proto.DeleteRowRequest
             * @instance
             */
            DeleteRowRequest.prototype.condition = null;

            /**
             * DeleteRowRequest returnContent.
             * @member {main.proto.IReturnContent|null|undefined} returnContent
             * @memberof main.proto.DeleteRowRequest
             * @instance
             */
            DeleteRowRequest.prototype.returnContent = null;

            /**
             * DeleteRowRequest transactionId.
             * @member {string} transactionId
             * @memberof main.proto.DeleteRowRequest
             * @instance
             */
            DeleteRowRequest.prototype.transactionId = "";

            /**
             * Creates a new DeleteRowRequest instance using the specified properties.
             * @function create
             * @memberof main.proto.DeleteRowRequest
             * @static
             * @param {main.proto.IDeleteRowRequest=} [properties] Properties to set
             * @returns {main.proto.DeleteRowRequest} DeleteRowRequest instance
             */
            DeleteRowRequest.create = function create(properties) {
                return new DeleteRowRequest(properties);
            };

            /**
             * Encodes the specified DeleteRowRequest message. Does not implicitly {@link main.proto.DeleteRowRequest.verify|verify} messages.
             * @function encode
             * @memberof main.proto.DeleteRowRequest
             * @static
             * @param {main.proto.IDeleteRowRequest} message DeleteRowRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteRowRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.tableName);
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.primaryKey);
                $root.main.proto.Condition.encode(message.condition, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.returnContent != null && Object.hasOwnProperty.call(message, "returnContent"))
                    $root.main.proto.ReturnContent.encode(message.returnContent, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.transactionId != null && Object.hasOwnProperty.call(message, "transactionId"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.transactionId);
                return writer;
            };

            /**
             * Encodes the specified DeleteRowRequest message, length delimited. Does not implicitly {@link main.proto.DeleteRowRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.DeleteRowRequest
             * @static
             * @param {main.proto.IDeleteRowRequest} message DeleteRowRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteRowRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteRowRequest message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.DeleteRowRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.DeleteRowRequest} DeleteRowRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteRowRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.DeleteRowRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tableName = reader.string();
                        break;
                    case 2:
                        message.primaryKey = reader.bytes();
                        break;
                    case 3:
                        message.condition = $root.main.proto.Condition.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.returnContent = $root.main.proto.ReturnContent.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.transactionId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("tableName"))
                    throw $util.ProtocolError("missing required 'tableName'", { instance: message });
                if (!message.hasOwnProperty("primaryKey"))
                    throw $util.ProtocolError("missing required 'primaryKey'", { instance: message });
                if (!message.hasOwnProperty("condition"))
                    throw $util.ProtocolError("missing required 'condition'", { instance: message });
                return message;
            };

            /**
             * Decodes a DeleteRowRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.DeleteRowRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.DeleteRowRequest} DeleteRowRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteRowRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteRowRequest message.
             * @function verify
             * @memberof main.proto.DeleteRowRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteRowRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.tableName))
                    return "tableName: string expected";
                if (!(message.primaryKey && typeof message.primaryKey.length === "number" || $util.isString(message.primaryKey)))
                    return "primaryKey: buffer expected";
                {
                    var error = $root.main.proto.Condition.verify(message.condition);
                    if (error)
                        return "condition." + error;
                }
                if (message.returnContent != null && message.hasOwnProperty("returnContent")) {
                    var error = $root.main.proto.ReturnContent.verify(message.returnContent);
                    if (error)
                        return "returnContent." + error;
                }
                if (message.transactionId != null && message.hasOwnProperty("transactionId"))
                    if (!$util.isString(message.transactionId))
                        return "transactionId: string expected";
                return null;
            };

            /**
             * Creates a DeleteRowRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.DeleteRowRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.DeleteRowRequest} DeleteRowRequest
             */
            DeleteRowRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.DeleteRowRequest)
                    return object;
                var message = new $root.main.proto.DeleteRowRequest();
                if (object.tableName != null)
                    message.tableName = String(object.tableName);
                if (object.primaryKey != null)
                    if (typeof object.primaryKey === "string")
                        $util.base64.decode(object.primaryKey, message.primaryKey = $util.newBuffer($util.base64.length(object.primaryKey)), 0);
                    else if (object.primaryKey.length)
                        message.primaryKey = object.primaryKey;
                if (object.condition != null) {
                    if (typeof object.condition !== "object")
                        throw TypeError(".main.proto.DeleteRowRequest.condition: object expected");
                    message.condition = $root.main.proto.Condition.fromObject(object.condition);
                }
                if (object.returnContent != null) {
                    if (typeof object.returnContent !== "object")
                        throw TypeError(".main.proto.DeleteRowRequest.returnContent: object expected");
                    message.returnContent = $root.main.proto.ReturnContent.fromObject(object.returnContent);
                }
                if (object.transactionId != null)
                    message.transactionId = String(object.transactionId);
                return message;
            };

            /**
             * Creates a plain object from a DeleteRowRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.DeleteRowRequest
             * @static
             * @param {main.proto.DeleteRowRequest} message DeleteRowRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteRowRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.tableName = "";
                    if (options.bytes === String)
                        object.primaryKey = "";
                    else {
                        object.primaryKey = [];
                        if (options.bytes !== Array)
                            object.primaryKey = $util.newBuffer(object.primaryKey);
                    }
                    object.condition = null;
                    object.returnContent = null;
                    object.transactionId = "";
                }
                if (message.tableName != null && message.hasOwnProperty("tableName"))
                    object.tableName = message.tableName;
                if (message.primaryKey != null && message.hasOwnProperty("primaryKey"))
                    object.primaryKey = options.bytes === String ? $util.base64.encode(message.primaryKey, 0, message.primaryKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.primaryKey) : message.primaryKey;
                if (message.condition != null && message.hasOwnProperty("condition"))
                    object.condition = $root.main.proto.Condition.toObject(message.condition, options);
                if (message.returnContent != null && message.hasOwnProperty("returnContent"))
                    object.returnContent = $root.main.proto.ReturnContent.toObject(message.returnContent, options);
                if (message.transactionId != null && message.hasOwnProperty("transactionId"))
                    object.transactionId = message.transactionId;
                return object;
            };

            /**
             * Converts this DeleteRowRequest to JSON.
             * @function toJSON
             * @memberof main.proto.DeleteRowRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteRowRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DeleteRowRequest;
        })();

        proto.DeleteRowResponse = (function() {

            /**
             * Properties of a DeleteRowResponse.
             * @memberof main.proto
             * @interface IDeleteRowResponse
             * @property {main.proto.IConsumedCapacity} consumed DeleteRowResponse consumed
             * @property {Uint8Array|null} [row] DeleteRowResponse row
             */

            /**
             * Constructs a new DeleteRowResponse.
             * @memberof main.proto
             * @classdesc Represents a DeleteRowResponse.
             * @implements IDeleteRowResponse
             * @constructor
             * @param {main.proto.IDeleteRowResponse=} [properties] Properties to set
             */
            function DeleteRowResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeleteRowResponse consumed.
             * @member {main.proto.IConsumedCapacity} consumed
             * @memberof main.proto.DeleteRowResponse
             * @instance
             */
            DeleteRowResponse.prototype.consumed = null;

            /**
             * DeleteRowResponse row.
             * @member {Uint8Array} row
             * @memberof main.proto.DeleteRowResponse
             * @instance
             */
            DeleteRowResponse.prototype.row = $util.newBuffer([]);

            /**
             * Creates a new DeleteRowResponse instance using the specified properties.
             * @function create
             * @memberof main.proto.DeleteRowResponse
             * @static
             * @param {main.proto.IDeleteRowResponse=} [properties] Properties to set
             * @returns {main.proto.DeleteRowResponse} DeleteRowResponse instance
             */
            DeleteRowResponse.create = function create(properties) {
                return new DeleteRowResponse(properties);
            };

            /**
             * Encodes the specified DeleteRowResponse message. Does not implicitly {@link main.proto.DeleteRowResponse.verify|verify} messages.
             * @function encode
             * @memberof main.proto.DeleteRowResponse
             * @static
             * @param {main.proto.IDeleteRowResponse} message DeleteRowResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteRowResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                $root.main.proto.ConsumedCapacity.encode(message.consumed, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.row != null && Object.hasOwnProperty.call(message, "row"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.row);
                return writer;
            };

            /**
             * Encodes the specified DeleteRowResponse message, length delimited. Does not implicitly {@link main.proto.DeleteRowResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.DeleteRowResponse
             * @static
             * @param {main.proto.IDeleteRowResponse} message DeleteRowResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteRowResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteRowResponse message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.DeleteRowResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.DeleteRowResponse} DeleteRowResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteRowResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.DeleteRowResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.consumed = $root.main.proto.ConsumedCapacity.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.row = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("consumed"))
                    throw $util.ProtocolError("missing required 'consumed'", { instance: message });
                return message;
            };

            /**
             * Decodes a DeleteRowResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.DeleteRowResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.DeleteRowResponse} DeleteRowResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteRowResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteRowResponse message.
             * @function verify
             * @memberof main.proto.DeleteRowResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteRowResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                {
                    var error = $root.main.proto.ConsumedCapacity.verify(message.consumed);
                    if (error)
                        return "consumed." + error;
                }
                if (message.row != null && message.hasOwnProperty("row"))
                    if (!(message.row && typeof message.row.length === "number" || $util.isString(message.row)))
                        return "row: buffer expected";
                return null;
            };

            /**
             * Creates a DeleteRowResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.DeleteRowResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.DeleteRowResponse} DeleteRowResponse
             */
            DeleteRowResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.DeleteRowResponse)
                    return object;
                var message = new $root.main.proto.DeleteRowResponse();
                if (object.consumed != null) {
                    if (typeof object.consumed !== "object")
                        throw TypeError(".main.proto.DeleteRowResponse.consumed: object expected");
                    message.consumed = $root.main.proto.ConsumedCapacity.fromObject(object.consumed);
                }
                if (object.row != null)
                    if (typeof object.row === "string")
                        $util.base64.decode(object.row, message.row = $util.newBuffer($util.base64.length(object.row)), 0);
                    else if (object.row.length)
                        message.row = object.row;
                return message;
            };

            /**
             * Creates a plain object from a DeleteRowResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.DeleteRowResponse
             * @static
             * @param {main.proto.DeleteRowResponse} message DeleteRowResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteRowResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.consumed = null;
                    if (options.bytes === String)
                        object.row = "";
                    else {
                        object.row = [];
                        if (options.bytes !== Array)
                            object.row = $util.newBuffer(object.row);
                    }
                }
                if (message.consumed != null && message.hasOwnProperty("consumed"))
                    object.consumed = $root.main.proto.ConsumedCapacity.toObject(message.consumed, options);
                if (message.row != null && message.hasOwnProperty("row"))
                    object.row = options.bytes === String ? $util.base64.encode(message.row, 0, message.row.length) : options.bytes === Array ? Array.prototype.slice.call(message.row) : message.row;
                return object;
            };

            /**
             * Converts this DeleteRowResponse to JSON.
             * @function toJSON
             * @memberof main.proto.DeleteRowResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteRowResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DeleteRowResponse;
        })();

        proto.TableInBatchGetRowRequest = (function() {

            /**
             * Properties of a TableInBatchGetRowRequest.
             * @memberof main.proto
             * @interface ITableInBatchGetRowRequest
             * @property {string} tableName TableInBatchGetRowRequest tableName
             * @property {Array.<Uint8Array>|null} [primaryKey] TableInBatchGetRowRequest primaryKey
             * @property {Array.<Uint8Array>|null} [token] TableInBatchGetRowRequest token
             * @property {Array.<string>|null} [columnsToGet] TableInBatchGetRowRequest columnsToGet
             * @property {main.proto.ITimeRange|null} [timeRange] TableInBatchGetRowRequest timeRange
             * @property {number|null} [maxVersions] TableInBatchGetRowRequest maxVersions
             * @property {boolean|null} [cacheBlocks] TableInBatchGetRowRequest cacheBlocks
             * @property {Uint8Array|null} [filter] TableInBatchGetRowRequest filter
             * @property {string|null} [startColumn] TableInBatchGetRowRequest startColumn
             * @property {string|null} [endColumn] TableInBatchGetRowRequest endColumn
             */

            /**
             * Constructs a new TableInBatchGetRowRequest.
             * @memberof main.proto
             * @classdesc HBase支持Batch操作的每行都拥有不同的查询参数，OTS不支持。
             * @implements ITableInBatchGetRowRequest
             * @constructor
             * @param {main.proto.ITableInBatchGetRowRequest=} [properties] Properties to set
             */
            function TableInBatchGetRowRequest(properties) {
                this.primaryKey = [];
                this.token = [];
                this.columnsToGet = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TableInBatchGetRowRequest tableName.
             * @member {string} tableName
             * @memberof main.proto.TableInBatchGetRowRequest
             * @instance
             */
            TableInBatchGetRowRequest.prototype.tableName = "";

            /**
             * TableInBatchGetRowRequest primaryKey.
             * @member {Array.<Uint8Array>} primaryKey
             * @memberof main.proto.TableInBatchGetRowRequest
             * @instance
             */
            TableInBatchGetRowRequest.prototype.primaryKey = $util.emptyArray;

            /**
             * TableInBatchGetRowRequest token.
             * @member {Array.<Uint8Array>} token
             * @memberof main.proto.TableInBatchGetRowRequest
             * @instance
             */
            TableInBatchGetRowRequest.prototype.token = $util.emptyArray;

            /**
             * TableInBatchGetRowRequest columnsToGet.
             * @member {Array.<string>} columnsToGet
             * @memberof main.proto.TableInBatchGetRowRequest
             * @instance
             */
            TableInBatchGetRowRequest.prototype.columnsToGet = $util.emptyArray;

            /**
             * TableInBatchGetRowRequest timeRange.
             * @member {main.proto.ITimeRange|null|undefined} timeRange
             * @memberof main.proto.TableInBatchGetRowRequest
             * @instance
             */
            TableInBatchGetRowRequest.prototype.timeRange = null;

            /**
             * TableInBatchGetRowRequest maxVersions.
             * @member {number} maxVersions
             * @memberof main.proto.TableInBatchGetRowRequest
             * @instance
             */
            TableInBatchGetRowRequest.prototype.maxVersions = 0;

            /**
             * TableInBatchGetRowRequest cacheBlocks.
             * @member {boolean} cacheBlocks
             * @memberof main.proto.TableInBatchGetRowRequest
             * @instance
             */
            TableInBatchGetRowRequest.prototype.cacheBlocks = true;

            /**
             * TableInBatchGetRowRequest filter.
             * @member {Uint8Array} filter
             * @memberof main.proto.TableInBatchGetRowRequest
             * @instance
             */
            TableInBatchGetRowRequest.prototype.filter = $util.newBuffer([]);

            /**
             * TableInBatchGetRowRequest startColumn.
             * @member {string} startColumn
             * @memberof main.proto.TableInBatchGetRowRequest
             * @instance
             */
            TableInBatchGetRowRequest.prototype.startColumn = "";

            /**
             * TableInBatchGetRowRequest endColumn.
             * @member {string} endColumn
             * @memberof main.proto.TableInBatchGetRowRequest
             * @instance
             */
            TableInBatchGetRowRequest.prototype.endColumn = "";

            /**
             * Creates a new TableInBatchGetRowRequest instance using the specified properties.
             * @function create
             * @memberof main.proto.TableInBatchGetRowRequest
             * @static
             * @param {main.proto.ITableInBatchGetRowRequest=} [properties] Properties to set
             * @returns {main.proto.TableInBatchGetRowRequest} TableInBatchGetRowRequest instance
             */
            TableInBatchGetRowRequest.create = function create(properties) {
                return new TableInBatchGetRowRequest(properties);
            };

            /**
             * Encodes the specified TableInBatchGetRowRequest message. Does not implicitly {@link main.proto.TableInBatchGetRowRequest.verify|verify} messages.
             * @function encode
             * @memberof main.proto.TableInBatchGetRowRequest
             * @static
             * @param {main.proto.ITableInBatchGetRowRequest} message TableInBatchGetRowRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TableInBatchGetRowRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.tableName);
                if (message.primaryKey != null && message.primaryKey.length)
                    for (var i = 0; i < message.primaryKey.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.primaryKey[i]);
                if (message.token != null && message.token.length)
                    for (var i = 0; i < message.token.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.token[i]);
                if (message.columnsToGet != null && message.columnsToGet.length)
                    for (var i = 0; i < message.columnsToGet.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.columnsToGet[i]);
                if (message.timeRange != null && Object.hasOwnProperty.call(message, "timeRange"))
                    $root.main.proto.TimeRange.encode(message.timeRange, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.maxVersions != null && Object.hasOwnProperty.call(message, "maxVersions"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.maxVersions);
                if (message.cacheBlocks != null && Object.hasOwnProperty.call(message, "cacheBlocks"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.cacheBlocks);
                if (message.filter != null && Object.hasOwnProperty.call(message, "filter"))
                    writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.filter);
                if (message.startColumn != null && Object.hasOwnProperty.call(message, "startColumn"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.startColumn);
                if (message.endColumn != null && Object.hasOwnProperty.call(message, "endColumn"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.endColumn);
                return writer;
            };

            /**
             * Encodes the specified TableInBatchGetRowRequest message, length delimited. Does not implicitly {@link main.proto.TableInBatchGetRowRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.TableInBatchGetRowRequest
             * @static
             * @param {main.proto.ITableInBatchGetRowRequest} message TableInBatchGetRowRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TableInBatchGetRowRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TableInBatchGetRowRequest message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.TableInBatchGetRowRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.TableInBatchGetRowRequest} TableInBatchGetRowRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TableInBatchGetRowRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.TableInBatchGetRowRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tableName = reader.string();
                        break;
                    case 2:
                        if (!(message.primaryKey && message.primaryKey.length))
                            message.primaryKey = [];
                        message.primaryKey.push(reader.bytes());
                        break;
                    case 3:
                        if (!(message.token && message.token.length))
                            message.token = [];
                        message.token.push(reader.bytes());
                        break;
                    case 4:
                        if (!(message.columnsToGet && message.columnsToGet.length))
                            message.columnsToGet = [];
                        message.columnsToGet.push(reader.string());
                        break;
                    case 5:
                        message.timeRange = $root.main.proto.TimeRange.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.maxVersions = reader.int32();
                        break;
                    case 7:
                        message.cacheBlocks = reader.bool();
                        break;
                    case 8:
                        message.filter = reader.bytes();
                        break;
                    case 9:
                        message.startColumn = reader.string();
                        break;
                    case 10:
                        message.endColumn = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("tableName"))
                    throw $util.ProtocolError("missing required 'tableName'", { instance: message });
                return message;
            };

            /**
             * Decodes a TableInBatchGetRowRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.TableInBatchGetRowRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.TableInBatchGetRowRequest} TableInBatchGetRowRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TableInBatchGetRowRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TableInBatchGetRowRequest message.
             * @function verify
             * @memberof main.proto.TableInBatchGetRowRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TableInBatchGetRowRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.tableName))
                    return "tableName: string expected";
                if (message.primaryKey != null && message.hasOwnProperty("primaryKey")) {
                    if (!Array.isArray(message.primaryKey))
                        return "primaryKey: array expected";
                    for (var i = 0; i < message.primaryKey.length; ++i)
                        if (!(message.primaryKey[i] && typeof message.primaryKey[i].length === "number" || $util.isString(message.primaryKey[i])))
                            return "primaryKey: buffer[] expected";
                }
                if (message.token != null && message.hasOwnProperty("token")) {
                    if (!Array.isArray(message.token))
                        return "token: array expected";
                    for (var i = 0; i < message.token.length; ++i)
                        if (!(message.token[i] && typeof message.token[i].length === "number" || $util.isString(message.token[i])))
                            return "token: buffer[] expected";
                }
                if (message.columnsToGet != null && message.hasOwnProperty("columnsToGet")) {
                    if (!Array.isArray(message.columnsToGet))
                        return "columnsToGet: array expected";
                    for (var i = 0; i < message.columnsToGet.length; ++i)
                        if (!$util.isString(message.columnsToGet[i]))
                            return "columnsToGet: string[] expected";
                }
                if (message.timeRange != null && message.hasOwnProperty("timeRange")) {
                    var error = $root.main.proto.TimeRange.verify(message.timeRange);
                    if (error)
                        return "timeRange." + error;
                }
                if (message.maxVersions != null && message.hasOwnProperty("maxVersions"))
                    if (!$util.isInteger(message.maxVersions))
                        return "maxVersions: integer expected";
                if (message.cacheBlocks != null && message.hasOwnProperty("cacheBlocks"))
                    if (typeof message.cacheBlocks !== "boolean")
                        return "cacheBlocks: boolean expected";
                if (message.filter != null && message.hasOwnProperty("filter"))
                    if (!(message.filter && typeof message.filter.length === "number" || $util.isString(message.filter)))
                        return "filter: buffer expected";
                if (message.startColumn != null && message.hasOwnProperty("startColumn"))
                    if (!$util.isString(message.startColumn))
                        return "startColumn: string expected";
                if (message.endColumn != null && message.hasOwnProperty("endColumn"))
                    if (!$util.isString(message.endColumn))
                        return "endColumn: string expected";
                return null;
            };

            /**
             * Creates a TableInBatchGetRowRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.TableInBatchGetRowRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.TableInBatchGetRowRequest} TableInBatchGetRowRequest
             */
            TableInBatchGetRowRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.TableInBatchGetRowRequest)
                    return object;
                var message = new $root.main.proto.TableInBatchGetRowRequest();
                if (object.tableName != null)
                    message.tableName = String(object.tableName);
                if (object.primaryKey) {
                    if (!Array.isArray(object.primaryKey))
                        throw TypeError(".main.proto.TableInBatchGetRowRequest.primaryKey: array expected");
                    message.primaryKey = [];
                    for (var i = 0; i < object.primaryKey.length; ++i)
                        if (typeof object.primaryKey[i] === "string")
                            $util.base64.decode(object.primaryKey[i], message.primaryKey[i] = $util.newBuffer($util.base64.length(object.primaryKey[i])), 0);
                        else if (object.primaryKey[i].length)
                            message.primaryKey[i] = object.primaryKey[i];
                }
                if (object.token) {
                    if (!Array.isArray(object.token))
                        throw TypeError(".main.proto.TableInBatchGetRowRequest.token: array expected");
                    message.token = [];
                    for (var i = 0; i < object.token.length; ++i)
                        if (typeof object.token[i] === "string")
                            $util.base64.decode(object.token[i], message.token[i] = $util.newBuffer($util.base64.length(object.token[i])), 0);
                        else if (object.token[i].length)
                            message.token[i] = object.token[i];
                }
                if (object.columnsToGet) {
                    if (!Array.isArray(object.columnsToGet))
                        throw TypeError(".main.proto.TableInBatchGetRowRequest.columnsToGet: array expected");
                    message.columnsToGet = [];
                    for (var i = 0; i < object.columnsToGet.length; ++i)
                        message.columnsToGet[i] = String(object.columnsToGet[i]);
                }
                if (object.timeRange != null) {
                    if (typeof object.timeRange !== "object")
                        throw TypeError(".main.proto.TableInBatchGetRowRequest.timeRange: object expected");
                    message.timeRange = $root.main.proto.TimeRange.fromObject(object.timeRange);
                }
                if (object.maxVersions != null)
                    message.maxVersions = object.maxVersions | 0;
                if (object.cacheBlocks != null)
                    message.cacheBlocks = Boolean(object.cacheBlocks);
                if (object.filter != null)
                    if (typeof object.filter === "string")
                        $util.base64.decode(object.filter, message.filter = $util.newBuffer($util.base64.length(object.filter)), 0);
                    else if (object.filter.length)
                        message.filter = object.filter;
                if (object.startColumn != null)
                    message.startColumn = String(object.startColumn);
                if (object.endColumn != null)
                    message.endColumn = String(object.endColumn);
                return message;
            };

            /**
             * Creates a plain object from a TableInBatchGetRowRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.TableInBatchGetRowRequest
             * @static
             * @param {main.proto.TableInBatchGetRowRequest} message TableInBatchGetRowRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TableInBatchGetRowRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.primaryKey = [];
                    object.token = [];
                    object.columnsToGet = [];
                }
                if (options.defaults) {
                    object.tableName = "";
                    object.timeRange = null;
                    object.maxVersions = 0;
                    object.cacheBlocks = true;
                    if (options.bytes === String)
                        object.filter = "";
                    else {
                        object.filter = [];
                        if (options.bytes !== Array)
                            object.filter = $util.newBuffer(object.filter);
                    }
                    object.startColumn = "";
                    object.endColumn = "";
                }
                if (message.tableName != null && message.hasOwnProperty("tableName"))
                    object.tableName = message.tableName;
                if (message.primaryKey && message.primaryKey.length) {
                    object.primaryKey = [];
                    for (var j = 0; j < message.primaryKey.length; ++j)
                        object.primaryKey[j] = options.bytes === String ? $util.base64.encode(message.primaryKey[j], 0, message.primaryKey[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.primaryKey[j]) : message.primaryKey[j];
                }
                if (message.token && message.token.length) {
                    object.token = [];
                    for (var j = 0; j < message.token.length; ++j)
                        object.token[j] = options.bytes === String ? $util.base64.encode(message.token[j], 0, message.token[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.token[j]) : message.token[j];
                }
                if (message.columnsToGet && message.columnsToGet.length) {
                    object.columnsToGet = [];
                    for (var j = 0; j < message.columnsToGet.length; ++j)
                        object.columnsToGet[j] = message.columnsToGet[j];
                }
                if (message.timeRange != null && message.hasOwnProperty("timeRange"))
                    object.timeRange = $root.main.proto.TimeRange.toObject(message.timeRange, options);
                if (message.maxVersions != null && message.hasOwnProperty("maxVersions"))
                    object.maxVersions = message.maxVersions;
                if (message.cacheBlocks != null && message.hasOwnProperty("cacheBlocks"))
                    object.cacheBlocks = message.cacheBlocks;
                if (message.filter != null && message.hasOwnProperty("filter"))
                    object.filter = options.bytes === String ? $util.base64.encode(message.filter, 0, message.filter.length) : options.bytes === Array ? Array.prototype.slice.call(message.filter) : message.filter;
                if (message.startColumn != null && message.hasOwnProperty("startColumn"))
                    object.startColumn = message.startColumn;
                if (message.endColumn != null && message.hasOwnProperty("endColumn"))
                    object.endColumn = message.endColumn;
                return object;
            };

            /**
             * Converts this TableInBatchGetRowRequest to JSON.
             * @function toJSON
             * @memberof main.proto.TableInBatchGetRowRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TableInBatchGetRowRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TableInBatchGetRowRequest;
        })();

        proto.BatchGetRowRequest = (function() {

            /**
             * Properties of a BatchGetRowRequest.
             * @memberof main.proto
             * @interface IBatchGetRowRequest
             * @property {Array.<main.proto.ITableInBatchGetRowRequest>|null} [tables] BatchGetRowRequest tables
             */

            /**
             * Constructs a new BatchGetRowRequest.
             * @memberof main.proto
             * @classdesc Represents a BatchGetRowRequest.
             * @implements IBatchGetRowRequest
             * @constructor
             * @param {main.proto.IBatchGetRowRequest=} [properties] Properties to set
             */
            function BatchGetRowRequest(properties) {
                this.tables = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BatchGetRowRequest tables.
             * @member {Array.<main.proto.ITableInBatchGetRowRequest>} tables
             * @memberof main.proto.BatchGetRowRequest
             * @instance
             */
            BatchGetRowRequest.prototype.tables = $util.emptyArray;

            /**
             * Creates a new BatchGetRowRequest instance using the specified properties.
             * @function create
             * @memberof main.proto.BatchGetRowRequest
             * @static
             * @param {main.proto.IBatchGetRowRequest=} [properties] Properties to set
             * @returns {main.proto.BatchGetRowRequest} BatchGetRowRequest instance
             */
            BatchGetRowRequest.create = function create(properties) {
                return new BatchGetRowRequest(properties);
            };

            /**
             * Encodes the specified BatchGetRowRequest message. Does not implicitly {@link main.proto.BatchGetRowRequest.verify|verify} messages.
             * @function encode
             * @memberof main.proto.BatchGetRowRequest
             * @static
             * @param {main.proto.IBatchGetRowRequest} message BatchGetRowRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchGetRowRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tables != null && message.tables.length)
                    for (var i = 0; i < message.tables.length; ++i)
                        $root.main.proto.TableInBatchGetRowRequest.encode(message.tables[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified BatchGetRowRequest message, length delimited. Does not implicitly {@link main.proto.BatchGetRowRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.BatchGetRowRequest
             * @static
             * @param {main.proto.IBatchGetRowRequest} message BatchGetRowRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchGetRowRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BatchGetRowRequest message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.BatchGetRowRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.BatchGetRowRequest} BatchGetRowRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchGetRowRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.BatchGetRowRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.tables && message.tables.length))
                            message.tables = [];
                        message.tables.push($root.main.proto.TableInBatchGetRowRequest.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BatchGetRowRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.BatchGetRowRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.BatchGetRowRequest} BatchGetRowRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchGetRowRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BatchGetRowRequest message.
             * @function verify
             * @memberof main.proto.BatchGetRowRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BatchGetRowRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tables != null && message.hasOwnProperty("tables")) {
                    if (!Array.isArray(message.tables))
                        return "tables: array expected";
                    for (var i = 0; i < message.tables.length; ++i) {
                        var error = $root.main.proto.TableInBatchGetRowRequest.verify(message.tables[i]);
                        if (error)
                            return "tables." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a BatchGetRowRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.BatchGetRowRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.BatchGetRowRequest} BatchGetRowRequest
             */
            BatchGetRowRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.BatchGetRowRequest)
                    return object;
                var message = new $root.main.proto.BatchGetRowRequest();
                if (object.tables) {
                    if (!Array.isArray(object.tables))
                        throw TypeError(".main.proto.BatchGetRowRequest.tables: array expected");
                    message.tables = [];
                    for (var i = 0; i < object.tables.length; ++i) {
                        if (typeof object.tables[i] !== "object")
                            throw TypeError(".main.proto.BatchGetRowRequest.tables: object expected");
                        message.tables[i] = $root.main.proto.TableInBatchGetRowRequest.fromObject(object.tables[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a BatchGetRowRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.BatchGetRowRequest
             * @static
             * @param {main.proto.BatchGetRowRequest} message BatchGetRowRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BatchGetRowRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.tables = [];
                if (message.tables && message.tables.length) {
                    object.tables = [];
                    for (var j = 0; j < message.tables.length; ++j)
                        object.tables[j] = $root.main.proto.TableInBatchGetRowRequest.toObject(message.tables[j], options);
                }
                return object;
            };

            /**
             * Converts this BatchGetRowRequest to JSON.
             * @function toJSON
             * @memberof main.proto.BatchGetRowRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BatchGetRowRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BatchGetRowRequest;
        })();

        proto.RowInBatchGetRowResponse = (function() {

            /**
             * Properties of a RowInBatchGetRowResponse.
             * @memberof main.proto
             * @interface IRowInBatchGetRowResponse
             * @property {boolean} isOk RowInBatchGetRowResponse isOk
             * @property {main.proto.IError|null} [error] RowInBatchGetRowResponse error
             * @property {main.proto.IConsumedCapacity|null} [consumed] RowInBatchGetRowResponse consumed
             * @property {Uint8Array|null} [row] RowInBatchGetRowResponse row
             * @property {Uint8Array|null} [nextToken] RowInBatchGetRowResponse nextToken
             */

            /**
             * Constructs a new RowInBatchGetRowResponse.
             * @memberof main.proto
             * @classdesc Represents a RowInBatchGetRowResponse.
             * @implements IRowInBatchGetRowResponse
             * @constructor
             * @param {main.proto.IRowInBatchGetRowResponse=} [properties] Properties to set
             */
            function RowInBatchGetRowResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RowInBatchGetRowResponse isOk.
             * @member {boolean} isOk
             * @memberof main.proto.RowInBatchGetRowResponse
             * @instance
             */
            RowInBatchGetRowResponse.prototype.isOk = false;

            /**
             * RowInBatchGetRowResponse error.
             * @member {main.proto.IError|null|undefined} error
             * @memberof main.proto.RowInBatchGetRowResponse
             * @instance
             */
            RowInBatchGetRowResponse.prototype.error = null;

            /**
             * RowInBatchGetRowResponse consumed.
             * @member {main.proto.IConsumedCapacity|null|undefined} consumed
             * @memberof main.proto.RowInBatchGetRowResponse
             * @instance
             */
            RowInBatchGetRowResponse.prototype.consumed = null;

            /**
             * RowInBatchGetRowResponse row.
             * @member {Uint8Array} row
             * @memberof main.proto.RowInBatchGetRowResponse
             * @instance
             */
            RowInBatchGetRowResponse.prototype.row = $util.newBuffer([]);

            /**
             * RowInBatchGetRowResponse nextToken.
             * @member {Uint8Array} nextToken
             * @memberof main.proto.RowInBatchGetRowResponse
             * @instance
             */
            RowInBatchGetRowResponse.prototype.nextToken = $util.newBuffer([]);

            /**
             * Creates a new RowInBatchGetRowResponse instance using the specified properties.
             * @function create
             * @memberof main.proto.RowInBatchGetRowResponse
             * @static
             * @param {main.proto.IRowInBatchGetRowResponse=} [properties] Properties to set
             * @returns {main.proto.RowInBatchGetRowResponse} RowInBatchGetRowResponse instance
             */
            RowInBatchGetRowResponse.create = function create(properties) {
                return new RowInBatchGetRowResponse(properties);
            };

            /**
             * Encodes the specified RowInBatchGetRowResponse message. Does not implicitly {@link main.proto.RowInBatchGetRowResponse.verify|verify} messages.
             * @function encode
             * @memberof main.proto.RowInBatchGetRowResponse
             * @static
             * @param {main.proto.IRowInBatchGetRowResponse} message RowInBatchGetRowResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RowInBatchGetRowResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isOk);
                if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                    $root.main.proto.Error.encode(message.error, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.consumed != null && Object.hasOwnProperty.call(message, "consumed"))
                    $root.main.proto.ConsumedCapacity.encode(message.consumed, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.row != null && Object.hasOwnProperty.call(message, "row"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.row);
                if (message.nextToken != null && Object.hasOwnProperty.call(message, "nextToken"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.nextToken);
                return writer;
            };

            /**
             * Encodes the specified RowInBatchGetRowResponse message, length delimited. Does not implicitly {@link main.proto.RowInBatchGetRowResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.RowInBatchGetRowResponse
             * @static
             * @param {main.proto.IRowInBatchGetRowResponse} message RowInBatchGetRowResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RowInBatchGetRowResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RowInBatchGetRowResponse message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.RowInBatchGetRowResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.RowInBatchGetRowResponse} RowInBatchGetRowResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RowInBatchGetRowResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.RowInBatchGetRowResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.isOk = reader.bool();
                        break;
                    case 2:
                        message.error = $root.main.proto.Error.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.consumed = $root.main.proto.ConsumedCapacity.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.row = reader.bytes();
                        break;
                    case 5:
                        message.nextToken = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("isOk"))
                    throw $util.ProtocolError("missing required 'isOk'", { instance: message });
                return message;
            };

            /**
             * Decodes a RowInBatchGetRowResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.RowInBatchGetRowResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.RowInBatchGetRowResponse} RowInBatchGetRowResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RowInBatchGetRowResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RowInBatchGetRowResponse message.
             * @function verify
             * @memberof main.proto.RowInBatchGetRowResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RowInBatchGetRowResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (typeof message.isOk !== "boolean")
                    return "isOk: boolean expected";
                if (message.error != null && message.hasOwnProperty("error")) {
                    var error = $root.main.proto.Error.verify(message.error);
                    if (error)
                        return "error." + error;
                }
                if (message.consumed != null && message.hasOwnProperty("consumed")) {
                    var error = $root.main.proto.ConsumedCapacity.verify(message.consumed);
                    if (error)
                        return "consumed." + error;
                }
                if (message.row != null && message.hasOwnProperty("row"))
                    if (!(message.row && typeof message.row.length === "number" || $util.isString(message.row)))
                        return "row: buffer expected";
                if (message.nextToken != null && message.hasOwnProperty("nextToken"))
                    if (!(message.nextToken && typeof message.nextToken.length === "number" || $util.isString(message.nextToken)))
                        return "nextToken: buffer expected";
                return null;
            };

            /**
             * Creates a RowInBatchGetRowResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.RowInBatchGetRowResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.RowInBatchGetRowResponse} RowInBatchGetRowResponse
             */
            RowInBatchGetRowResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.RowInBatchGetRowResponse)
                    return object;
                var message = new $root.main.proto.RowInBatchGetRowResponse();
                if (object.isOk != null)
                    message.isOk = Boolean(object.isOk);
                if (object.error != null) {
                    if (typeof object.error !== "object")
                        throw TypeError(".main.proto.RowInBatchGetRowResponse.error: object expected");
                    message.error = $root.main.proto.Error.fromObject(object.error);
                }
                if (object.consumed != null) {
                    if (typeof object.consumed !== "object")
                        throw TypeError(".main.proto.RowInBatchGetRowResponse.consumed: object expected");
                    message.consumed = $root.main.proto.ConsumedCapacity.fromObject(object.consumed);
                }
                if (object.row != null)
                    if (typeof object.row === "string")
                        $util.base64.decode(object.row, message.row = $util.newBuffer($util.base64.length(object.row)), 0);
                    else if (object.row.length)
                        message.row = object.row;
                if (object.nextToken != null)
                    if (typeof object.nextToken === "string")
                        $util.base64.decode(object.nextToken, message.nextToken = $util.newBuffer($util.base64.length(object.nextToken)), 0);
                    else if (object.nextToken.length)
                        message.nextToken = object.nextToken;
                return message;
            };

            /**
             * Creates a plain object from a RowInBatchGetRowResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.RowInBatchGetRowResponse
             * @static
             * @param {main.proto.RowInBatchGetRowResponse} message RowInBatchGetRowResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RowInBatchGetRowResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.isOk = false;
                    object.error = null;
                    object.consumed = null;
                    if (options.bytes === String)
                        object.row = "";
                    else {
                        object.row = [];
                        if (options.bytes !== Array)
                            object.row = $util.newBuffer(object.row);
                    }
                    if (options.bytes === String)
                        object.nextToken = "";
                    else {
                        object.nextToken = [];
                        if (options.bytes !== Array)
                            object.nextToken = $util.newBuffer(object.nextToken);
                    }
                }
                if (message.isOk != null && message.hasOwnProperty("isOk"))
                    object.isOk = message.isOk;
                if (message.error != null && message.hasOwnProperty("error"))
                    object.error = $root.main.proto.Error.toObject(message.error, options);
                if (message.consumed != null && message.hasOwnProperty("consumed"))
                    object.consumed = $root.main.proto.ConsumedCapacity.toObject(message.consumed, options);
                if (message.row != null && message.hasOwnProperty("row"))
                    object.row = options.bytes === String ? $util.base64.encode(message.row, 0, message.row.length) : options.bytes === Array ? Array.prototype.slice.call(message.row) : message.row;
                if (message.nextToken != null && message.hasOwnProperty("nextToken"))
                    object.nextToken = options.bytes === String ? $util.base64.encode(message.nextToken, 0, message.nextToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.nextToken) : message.nextToken;
                return object;
            };

            /**
             * Converts this RowInBatchGetRowResponse to JSON.
             * @function toJSON
             * @memberof main.proto.RowInBatchGetRowResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RowInBatchGetRowResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RowInBatchGetRowResponse;
        })();

        proto.TableInBatchGetRowResponse = (function() {

            /**
             * Properties of a TableInBatchGetRowResponse.
             * @memberof main.proto
             * @interface ITableInBatchGetRowResponse
             * @property {string} tableName TableInBatchGetRowResponse tableName
             * @property {Array.<main.proto.IRowInBatchGetRowResponse>|null} [rows] TableInBatchGetRowResponse rows
             */

            /**
             * Constructs a new TableInBatchGetRowResponse.
             * @memberof main.proto
             * @classdesc Represents a TableInBatchGetRowResponse.
             * @implements ITableInBatchGetRowResponse
             * @constructor
             * @param {main.proto.ITableInBatchGetRowResponse=} [properties] Properties to set
             */
            function TableInBatchGetRowResponse(properties) {
                this.rows = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TableInBatchGetRowResponse tableName.
             * @member {string} tableName
             * @memberof main.proto.TableInBatchGetRowResponse
             * @instance
             */
            TableInBatchGetRowResponse.prototype.tableName = "";

            /**
             * TableInBatchGetRowResponse rows.
             * @member {Array.<main.proto.IRowInBatchGetRowResponse>} rows
             * @memberof main.proto.TableInBatchGetRowResponse
             * @instance
             */
            TableInBatchGetRowResponse.prototype.rows = $util.emptyArray;

            /**
             * Creates a new TableInBatchGetRowResponse instance using the specified properties.
             * @function create
             * @memberof main.proto.TableInBatchGetRowResponse
             * @static
             * @param {main.proto.ITableInBatchGetRowResponse=} [properties] Properties to set
             * @returns {main.proto.TableInBatchGetRowResponse} TableInBatchGetRowResponse instance
             */
            TableInBatchGetRowResponse.create = function create(properties) {
                return new TableInBatchGetRowResponse(properties);
            };

            /**
             * Encodes the specified TableInBatchGetRowResponse message. Does not implicitly {@link main.proto.TableInBatchGetRowResponse.verify|verify} messages.
             * @function encode
             * @memberof main.proto.TableInBatchGetRowResponse
             * @static
             * @param {main.proto.ITableInBatchGetRowResponse} message TableInBatchGetRowResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TableInBatchGetRowResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.tableName);
                if (message.rows != null && message.rows.length)
                    for (var i = 0; i < message.rows.length; ++i)
                        $root.main.proto.RowInBatchGetRowResponse.encode(message.rows[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified TableInBatchGetRowResponse message, length delimited. Does not implicitly {@link main.proto.TableInBatchGetRowResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.TableInBatchGetRowResponse
             * @static
             * @param {main.proto.ITableInBatchGetRowResponse} message TableInBatchGetRowResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TableInBatchGetRowResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TableInBatchGetRowResponse message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.TableInBatchGetRowResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.TableInBatchGetRowResponse} TableInBatchGetRowResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TableInBatchGetRowResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.TableInBatchGetRowResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tableName = reader.string();
                        break;
                    case 2:
                        if (!(message.rows && message.rows.length))
                            message.rows = [];
                        message.rows.push($root.main.proto.RowInBatchGetRowResponse.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("tableName"))
                    throw $util.ProtocolError("missing required 'tableName'", { instance: message });
                return message;
            };

            /**
             * Decodes a TableInBatchGetRowResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.TableInBatchGetRowResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.TableInBatchGetRowResponse} TableInBatchGetRowResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TableInBatchGetRowResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TableInBatchGetRowResponse message.
             * @function verify
             * @memberof main.proto.TableInBatchGetRowResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TableInBatchGetRowResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.tableName))
                    return "tableName: string expected";
                if (message.rows != null && message.hasOwnProperty("rows")) {
                    if (!Array.isArray(message.rows))
                        return "rows: array expected";
                    for (var i = 0; i < message.rows.length; ++i) {
                        var error = $root.main.proto.RowInBatchGetRowResponse.verify(message.rows[i]);
                        if (error)
                            return "rows." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a TableInBatchGetRowResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.TableInBatchGetRowResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.TableInBatchGetRowResponse} TableInBatchGetRowResponse
             */
            TableInBatchGetRowResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.TableInBatchGetRowResponse)
                    return object;
                var message = new $root.main.proto.TableInBatchGetRowResponse();
                if (object.tableName != null)
                    message.tableName = String(object.tableName);
                if (object.rows) {
                    if (!Array.isArray(object.rows))
                        throw TypeError(".main.proto.TableInBatchGetRowResponse.rows: array expected");
                    message.rows = [];
                    for (var i = 0; i < object.rows.length; ++i) {
                        if (typeof object.rows[i] !== "object")
                            throw TypeError(".main.proto.TableInBatchGetRowResponse.rows: object expected");
                        message.rows[i] = $root.main.proto.RowInBatchGetRowResponse.fromObject(object.rows[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a TableInBatchGetRowResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.TableInBatchGetRowResponse
             * @static
             * @param {main.proto.TableInBatchGetRowResponse} message TableInBatchGetRowResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TableInBatchGetRowResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.rows = [];
                if (options.defaults)
                    object.tableName = "";
                if (message.tableName != null && message.hasOwnProperty("tableName"))
                    object.tableName = message.tableName;
                if (message.rows && message.rows.length) {
                    object.rows = [];
                    for (var j = 0; j < message.rows.length; ++j)
                        object.rows[j] = $root.main.proto.RowInBatchGetRowResponse.toObject(message.rows[j], options);
                }
                return object;
            };

            /**
             * Converts this TableInBatchGetRowResponse to JSON.
             * @function toJSON
             * @memberof main.proto.TableInBatchGetRowResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TableInBatchGetRowResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TableInBatchGetRowResponse;
        })();

        proto.BatchGetRowResponse = (function() {

            /**
             * Properties of a BatchGetRowResponse.
             * @memberof main.proto
             * @interface IBatchGetRowResponse
             * @property {Array.<main.proto.ITableInBatchGetRowResponse>|null} [tables] BatchGetRowResponse tables
             */

            /**
             * Constructs a new BatchGetRowResponse.
             * @memberof main.proto
             * @classdesc Represents a BatchGetRowResponse.
             * @implements IBatchGetRowResponse
             * @constructor
             * @param {main.proto.IBatchGetRowResponse=} [properties] Properties to set
             */
            function BatchGetRowResponse(properties) {
                this.tables = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BatchGetRowResponse tables.
             * @member {Array.<main.proto.ITableInBatchGetRowResponse>} tables
             * @memberof main.proto.BatchGetRowResponse
             * @instance
             */
            BatchGetRowResponse.prototype.tables = $util.emptyArray;

            /**
             * Creates a new BatchGetRowResponse instance using the specified properties.
             * @function create
             * @memberof main.proto.BatchGetRowResponse
             * @static
             * @param {main.proto.IBatchGetRowResponse=} [properties] Properties to set
             * @returns {main.proto.BatchGetRowResponse} BatchGetRowResponse instance
             */
            BatchGetRowResponse.create = function create(properties) {
                return new BatchGetRowResponse(properties);
            };

            /**
             * Encodes the specified BatchGetRowResponse message. Does not implicitly {@link main.proto.BatchGetRowResponse.verify|verify} messages.
             * @function encode
             * @memberof main.proto.BatchGetRowResponse
             * @static
             * @param {main.proto.IBatchGetRowResponse} message BatchGetRowResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchGetRowResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tables != null && message.tables.length)
                    for (var i = 0; i < message.tables.length; ++i)
                        $root.main.proto.TableInBatchGetRowResponse.encode(message.tables[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified BatchGetRowResponse message, length delimited. Does not implicitly {@link main.proto.BatchGetRowResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.BatchGetRowResponse
             * @static
             * @param {main.proto.IBatchGetRowResponse} message BatchGetRowResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchGetRowResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BatchGetRowResponse message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.BatchGetRowResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.BatchGetRowResponse} BatchGetRowResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchGetRowResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.BatchGetRowResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.tables && message.tables.length))
                            message.tables = [];
                        message.tables.push($root.main.proto.TableInBatchGetRowResponse.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BatchGetRowResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.BatchGetRowResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.BatchGetRowResponse} BatchGetRowResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchGetRowResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BatchGetRowResponse message.
             * @function verify
             * @memberof main.proto.BatchGetRowResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BatchGetRowResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tables != null && message.hasOwnProperty("tables")) {
                    if (!Array.isArray(message.tables))
                        return "tables: array expected";
                    for (var i = 0; i < message.tables.length; ++i) {
                        var error = $root.main.proto.TableInBatchGetRowResponse.verify(message.tables[i]);
                        if (error)
                            return "tables." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a BatchGetRowResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.BatchGetRowResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.BatchGetRowResponse} BatchGetRowResponse
             */
            BatchGetRowResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.BatchGetRowResponse)
                    return object;
                var message = new $root.main.proto.BatchGetRowResponse();
                if (object.tables) {
                    if (!Array.isArray(object.tables))
                        throw TypeError(".main.proto.BatchGetRowResponse.tables: array expected");
                    message.tables = [];
                    for (var i = 0; i < object.tables.length; ++i) {
                        if (typeof object.tables[i] !== "object")
                            throw TypeError(".main.proto.BatchGetRowResponse.tables: object expected");
                        message.tables[i] = $root.main.proto.TableInBatchGetRowResponse.fromObject(object.tables[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a BatchGetRowResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.BatchGetRowResponse
             * @static
             * @param {main.proto.BatchGetRowResponse} message BatchGetRowResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BatchGetRowResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.tables = [];
                if (message.tables && message.tables.length) {
                    object.tables = [];
                    for (var j = 0; j < message.tables.length; ++j)
                        object.tables[j] = $root.main.proto.TableInBatchGetRowResponse.toObject(message.tables[j], options);
                }
                return object;
            };

            /**
             * Converts this BatchGetRowResponse to JSON.
             * @function toJSON
             * @memberof main.proto.BatchGetRowResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BatchGetRowResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BatchGetRowResponse;
        })();

        /**
         * OperationType enum.
         * @name main.proto.OperationType
         * @enum {number}
         * @property {number} PUT=1 PUT value
         * @property {number} UPDATE=2 UPDATE value
         * @property {number} DELETE=3 DELETE value
         */
        proto.OperationType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "PUT"] = 1;
            values[valuesById[2] = "UPDATE"] = 2;
            values[valuesById[3] = "DELETE"] = 3;
            return values;
        })();

        proto.RowInBatchWriteRowRequest = (function() {

            /**
             * Properties of a RowInBatchWriteRowRequest.
             * @memberof main.proto
             * @interface IRowInBatchWriteRowRequest
             * @property {main.proto.OperationType} type RowInBatchWriteRowRequest type
             * @property {Uint8Array} rowChange RowInBatchWriteRowRequest rowChange
             * @property {main.proto.ICondition} condition RowInBatchWriteRowRequest condition
             * @property {main.proto.IReturnContent|null} [returnContent] RowInBatchWriteRowRequest returnContent
             */

            /**
             * Constructs a new RowInBatchWriteRowRequest.
             * @memberof main.proto
             * @classdesc Represents a RowInBatchWriteRowRequest.
             * @implements IRowInBatchWriteRowRequest
             * @constructor
             * @param {main.proto.IRowInBatchWriteRowRequest=} [properties] Properties to set
             */
            function RowInBatchWriteRowRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RowInBatchWriteRowRequest type.
             * @member {main.proto.OperationType} type
             * @memberof main.proto.RowInBatchWriteRowRequest
             * @instance
             */
            RowInBatchWriteRowRequest.prototype.type = 1;

            /**
             * RowInBatchWriteRowRequest rowChange.
             * @member {Uint8Array} rowChange
             * @memberof main.proto.RowInBatchWriteRowRequest
             * @instance
             */
            RowInBatchWriteRowRequest.prototype.rowChange = $util.newBuffer([]);

            /**
             * RowInBatchWriteRowRequest condition.
             * @member {main.proto.ICondition} condition
             * @memberof main.proto.RowInBatchWriteRowRequest
             * @instance
             */
            RowInBatchWriteRowRequest.prototype.condition = null;

            /**
             * RowInBatchWriteRowRequest returnContent.
             * @member {main.proto.IReturnContent|null|undefined} returnContent
             * @memberof main.proto.RowInBatchWriteRowRequest
             * @instance
             */
            RowInBatchWriteRowRequest.prototype.returnContent = null;

            /**
             * Creates a new RowInBatchWriteRowRequest instance using the specified properties.
             * @function create
             * @memberof main.proto.RowInBatchWriteRowRequest
             * @static
             * @param {main.proto.IRowInBatchWriteRowRequest=} [properties] Properties to set
             * @returns {main.proto.RowInBatchWriteRowRequest} RowInBatchWriteRowRequest instance
             */
            RowInBatchWriteRowRequest.create = function create(properties) {
                return new RowInBatchWriteRowRequest(properties);
            };

            /**
             * Encodes the specified RowInBatchWriteRowRequest message. Does not implicitly {@link main.proto.RowInBatchWriteRowRequest.verify|verify} messages.
             * @function encode
             * @memberof main.proto.RowInBatchWriteRowRequest
             * @static
             * @param {main.proto.IRowInBatchWriteRowRequest} message RowInBatchWriteRowRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RowInBatchWriteRowRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.rowChange);
                $root.main.proto.Condition.encode(message.condition, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.returnContent != null && Object.hasOwnProperty.call(message, "returnContent"))
                    $root.main.proto.ReturnContent.encode(message.returnContent, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RowInBatchWriteRowRequest message, length delimited. Does not implicitly {@link main.proto.RowInBatchWriteRowRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.RowInBatchWriteRowRequest
             * @static
             * @param {main.proto.IRowInBatchWriteRowRequest} message RowInBatchWriteRowRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RowInBatchWriteRowRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RowInBatchWriteRowRequest message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.RowInBatchWriteRowRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.RowInBatchWriteRowRequest} RowInBatchWriteRowRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RowInBatchWriteRowRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.RowInBatchWriteRowRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.rowChange = reader.bytes();
                        break;
                    case 3:
                        message.condition = $root.main.proto.Condition.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.returnContent = $root.main.proto.ReturnContent.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("type"))
                    throw $util.ProtocolError("missing required 'type'", { instance: message });
                if (!message.hasOwnProperty("rowChange"))
                    throw $util.ProtocolError("missing required 'rowChange'", { instance: message });
                if (!message.hasOwnProperty("condition"))
                    throw $util.ProtocolError("missing required 'condition'", { instance: message });
                return message;
            };

            /**
             * Decodes a RowInBatchWriteRowRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.RowInBatchWriteRowRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.RowInBatchWriteRowRequest} RowInBatchWriteRowRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RowInBatchWriteRowRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RowInBatchWriteRowRequest message.
             * @function verify
             * @memberof main.proto.RowInBatchWriteRowRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RowInBatchWriteRowRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 1:
                case 2:
                case 3:
                    break;
                }
                if (!(message.rowChange && typeof message.rowChange.length === "number" || $util.isString(message.rowChange)))
                    return "rowChange: buffer expected";
                {
                    var error = $root.main.proto.Condition.verify(message.condition);
                    if (error)
                        return "condition." + error;
                }
                if (message.returnContent != null && message.hasOwnProperty("returnContent")) {
                    var error = $root.main.proto.ReturnContent.verify(message.returnContent);
                    if (error)
                        return "returnContent." + error;
                }
                return null;
            };

            /**
             * Creates a RowInBatchWriteRowRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.RowInBatchWriteRowRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.RowInBatchWriteRowRequest} RowInBatchWriteRowRequest
             */
            RowInBatchWriteRowRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.RowInBatchWriteRowRequest)
                    return object;
                var message = new $root.main.proto.RowInBatchWriteRowRequest();
                switch (object.type) {
                case "PUT":
                case 1:
                    message.type = 1;
                    break;
                case "UPDATE":
                case 2:
                    message.type = 2;
                    break;
                case "DELETE":
                case 3:
                    message.type = 3;
                    break;
                }
                if (object.rowChange != null)
                    if (typeof object.rowChange === "string")
                        $util.base64.decode(object.rowChange, message.rowChange = $util.newBuffer($util.base64.length(object.rowChange)), 0);
                    else if (object.rowChange.length)
                        message.rowChange = object.rowChange;
                if (object.condition != null) {
                    if (typeof object.condition !== "object")
                        throw TypeError(".main.proto.RowInBatchWriteRowRequest.condition: object expected");
                    message.condition = $root.main.proto.Condition.fromObject(object.condition);
                }
                if (object.returnContent != null) {
                    if (typeof object.returnContent !== "object")
                        throw TypeError(".main.proto.RowInBatchWriteRowRequest.returnContent: object expected");
                    message.returnContent = $root.main.proto.ReturnContent.fromObject(object.returnContent);
                }
                return message;
            };

            /**
             * Creates a plain object from a RowInBatchWriteRowRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.RowInBatchWriteRowRequest
             * @static
             * @param {main.proto.RowInBatchWriteRowRequest} message RowInBatchWriteRowRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RowInBatchWriteRowRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type = options.enums === String ? "PUT" : 1;
                    if (options.bytes === String)
                        object.rowChange = "";
                    else {
                        object.rowChange = [];
                        if (options.bytes !== Array)
                            object.rowChange = $util.newBuffer(object.rowChange);
                    }
                    object.condition = null;
                    object.returnContent = null;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.main.proto.OperationType[message.type] : message.type;
                if (message.rowChange != null && message.hasOwnProperty("rowChange"))
                    object.rowChange = options.bytes === String ? $util.base64.encode(message.rowChange, 0, message.rowChange.length) : options.bytes === Array ? Array.prototype.slice.call(message.rowChange) : message.rowChange;
                if (message.condition != null && message.hasOwnProperty("condition"))
                    object.condition = $root.main.proto.Condition.toObject(message.condition, options);
                if (message.returnContent != null && message.hasOwnProperty("returnContent"))
                    object.returnContent = $root.main.proto.ReturnContent.toObject(message.returnContent, options);
                return object;
            };

            /**
             * Converts this RowInBatchWriteRowRequest to JSON.
             * @function toJSON
             * @memberof main.proto.RowInBatchWriteRowRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RowInBatchWriteRowRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RowInBatchWriteRowRequest;
        })();

        proto.TableInBatchWriteRowRequest = (function() {

            /**
             * Properties of a TableInBatchWriteRowRequest.
             * @memberof main.proto
             * @interface ITableInBatchWriteRowRequest
             * @property {string} tableName TableInBatchWriteRowRequest tableName
             * @property {Array.<main.proto.IRowInBatchWriteRowRequest>|null} [rows] TableInBatchWriteRowRequest rows
             */

            /**
             * Constructs a new TableInBatchWriteRowRequest.
             * @memberof main.proto
             * @classdesc Represents a TableInBatchWriteRowRequest.
             * @implements ITableInBatchWriteRowRequest
             * @constructor
             * @param {main.proto.ITableInBatchWriteRowRequest=} [properties] Properties to set
             */
            function TableInBatchWriteRowRequest(properties) {
                this.rows = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TableInBatchWriteRowRequest tableName.
             * @member {string} tableName
             * @memberof main.proto.TableInBatchWriteRowRequest
             * @instance
             */
            TableInBatchWriteRowRequest.prototype.tableName = "";

            /**
             * TableInBatchWriteRowRequest rows.
             * @member {Array.<main.proto.IRowInBatchWriteRowRequest>} rows
             * @memberof main.proto.TableInBatchWriteRowRequest
             * @instance
             */
            TableInBatchWriteRowRequest.prototype.rows = $util.emptyArray;

            /**
             * Creates a new TableInBatchWriteRowRequest instance using the specified properties.
             * @function create
             * @memberof main.proto.TableInBatchWriteRowRequest
             * @static
             * @param {main.proto.ITableInBatchWriteRowRequest=} [properties] Properties to set
             * @returns {main.proto.TableInBatchWriteRowRequest} TableInBatchWriteRowRequest instance
             */
            TableInBatchWriteRowRequest.create = function create(properties) {
                return new TableInBatchWriteRowRequest(properties);
            };

            /**
             * Encodes the specified TableInBatchWriteRowRequest message. Does not implicitly {@link main.proto.TableInBatchWriteRowRequest.verify|verify} messages.
             * @function encode
             * @memberof main.proto.TableInBatchWriteRowRequest
             * @static
             * @param {main.proto.ITableInBatchWriteRowRequest} message TableInBatchWriteRowRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TableInBatchWriteRowRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.tableName);
                if (message.rows != null && message.rows.length)
                    for (var i = 0; i < message.rows.length; ++i)
                        $root.main.proto.RowInBatchWriteRowRequest.encode(message.rows[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified TableInBatchWriteRowRequest message, length delimited. Does not implicitly {@link main.proto.TableInBatchWriteRowRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.TableInBatchWriteRowRequest
             * @static
             * @param {main.proto.ITableInBatchWriteRowRequest} message TableInBatchWriteRowRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TableInBatchWriteRowRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TableInBatchWriteRowRequest message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.TableInBatchWriteRowRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.TableInBatchWriteRowRequest} TableInBatchWriteRowRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TableInBatchWriteRowRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.TableInBatchWriteRowRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tableName = reader.string();
                        break;
                    case 2:
                        if (!(message.rows && message.rows.length))
                            message.rows = [];
                        message.rows.push($root.main.proto.RowInBatchWriteRowRequest.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("tableName"))
                    throw $util.ProtocolError("missing required 'tableName'", { instance: message });
                return message;
            };

            /**
             * Decodes a TableInBatchWriteRowRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.TableInBatchWriteRowRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.TableInBatchWriteRowRequest} TableInBatchWriteRowRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TableInBatchWriteRowRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TableInBatchWriteRowRequest message.
             * @function verify
             * @memberof main.proto.TableInBatchWriteRowRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TableInBatchWriteRowRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.tableName))
                    return "tableName: string expected";
                if (message.rows != null && message.hasOwnProperty("rows")) {
                    if (!Array.isArray(message.rows))
                        return "rows: array expected";
                    for (var i = 0; i < message.rows.length; ++i) {
                        var error = $root.main.proto.RowInBatchWriteRowRequest.verify(message.rows[i]);
                        if (error)
                            return "rows." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a TableInBatchWriteRowRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.TableInBatchWriteRowRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.TableInBatchWriteRowRequest} TableInBatchWriteRowRequest
             */
            TableInBatchWriteRowRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.TableInBatchWriteRowRequest)
                    return object;
                var message = new $root.main.proto.TableInBatchWriteRowRequest();
                if (object.tableName != null)
                    message.tableName = String(object.tableName);
                if (object.rows) {
                    if (!Array.isArray(object.rows))
                        throw TypeError(".main.proto.TableInBatchWriteRowRequest.rows: array expected");
                    message.rows = [];
                    for (var i = 0; i < object.rows.length; ++i) {
                        if (typeof object.rows[i] !== "object")
                            throw TypeError(".main.proto.TableInBatchWriteRowRequest.rows: object expected");
                        message.rows[i] = $root.main.proto.RowInBatchWriteRowRequest.fromObject(object.rows[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a TableInBatchWriteRowRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.TableInBatchWriteRowRequest
             * @static
             * @param {main.proto.TableInBatchWriteRowRequest} message TableInBatchWriteRowRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TableInBatchWriteRowRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.rows = [];
                if (options.defaults)
                    object.tableName = "";
                if (message.tableName != null && message.hasOwnProperty("tableName"))
                    object.tableName = message.tableName;
                if (message.rows && message.rows.length) {
                    object.rows = [];
                    for (var j = 0; j < message.rows.length; ++j)
                        object.rows[j] = $root.main.proto.RowInBatchWriteRowRequest.toObject(message.rows[j], options);
                }
                return object;
            };

            /**
             * Converts this TableInBatchWriteRowRequest to JSON.
             * @function toJSON
             * @memberof main.proto.TableInBatchWriteRowRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TableInBatchWriteRowRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TableInBatchWriteRowRequest;
        })();

        proto.BatchWriteRowRequest = (function() {

            /**
             * Properties of a BatchWriteRowRequest.
             * @memberof main.proto
             * @interface IBatchWriteRowRequest
             * @property {Array.<main.proto.ITableInBatchWriteRowRequest>|null} [tables] BatchWriteRowRequest tables
             * @property {string|null} [transactionId] BatchWriteRowRequest transactionId
             */

            /**
             * Constructs a new BatchWriteRowRequest.
             * @memberof main.proto
             * @classdesc Represents a BatchWriteRowRequest.
             * @implements IBatchWriteRowRequest
             * @constructor
             * @param {main.proto.IBatchWriteRowRequest=} [properties] Properties to set
             */
            function BatchWriteRowRequest(properties) {
                this.tables = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BatchWriteRowRequest tables.
             * @member {Array.<main.proto.ITableInBatchWriteRowRequest>} tables
             * @memberof main.proto.BatchWriteRowRequest
             * @instance
             */
            BatchWriteRowRequest.prototype.tables = $util.emptyArray;

            /**
             * BatchWriteRowRequest transactionId.
             * @member {string} transactionId
             * @memberof main.proto.BatchWriteRowRequest
             * @instance
             */
            BatchWriteRowRequest.prototype.transactionId = "";

            /**
             * Creates a new BatchWriteRowRequest instance using the specified properties.
             * @function create
             * @memberof main.proto.BatchWriteRowRequest
             * @static
             * @param {main.proto.IBatchWriteRowRequest=} [properties] Properties to set
             * @returns {main.proto.BatchWriteRowRequest} BatchWriteRowRequest instance
             */
            BatchWriteRowRequest.create = function create(properties) {
                return new BatchWriteRowRequest(properties);
            };

            /**
             * Encodes the specified BatchWriteRowRequest message. Does not implicitly {@link main.proto.BatchWriteRowRequest.verify|verify} messages.
             * @function encode
             * @memberof main.proto.BatchWriteRowRequest
             * @static
             * @param {main.proto.IBatchWriteRowRequest} message BatchWriteRowRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchWriteRowRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tables != null && message.tables.length)
                    for (var i = 0; i < message.tables.length; ++i)
                        $root.main.proto.TableInBatchWriteRowRequest.encode(message.tables[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.transactionId != null && Object.hasOwnProperty.call(message, "transactionId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.transactionId);
                return writer;
            };

            /**
             * Encodes the specified BatchWriteRowRequest message, length delimited. Does not implicitly {@link main.proto.BatchWriteRowRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.BatchWriteRowRequest
             * @static
             * @param {main.proto.IBatchWriteRowRequest} message BatchWriteRowRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchWriteRowRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BatchWriteRowRequest message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.BatchWriteRowRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.BatchWriteRowRequest} BatchWriteRowRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchWriteRowRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.BatchWriteRowRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.tables && message.tables.length))
                            message.tables = [];
                        message.tables.push($root.main.proto.TableInBatchWriteRowRequest.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.transactionId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BatchWriteRowRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.BatchWriteRowRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.BatchWriteRowRequest} BatchWriteRowRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchWriteRowRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BatchWriteRowRequest message.
             * @function verify
             * @memberof main.proto.BatchWriteRowRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BatchWriteRowRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tables != null && message.hasOwnProperty("tables")) {
                    if (!Array.isArray(message.tables))
                        return "tables: array expected";
                    for (var i = 0; i < message.tables.length; ++i) {
                        var error = $root.main.proto.TableInBatchWriteRowRequest.verify(message.tables[i]);
                        if (error)
                            return "tables." + error;
                    }
                }
                if (message.transactionId != null && message.hasOwnProperty("transactionId"))
                    if (!$util.isString(message.transactionId))
                        return "transactionId: string expected";
                return null;
            };

            /**
             * Creates a BatchWriteRowRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.BatchWriteRowRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.BatchWriteRowRequest} BatchWriteRowRequest
             */
            BatchWriteRowRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.BatchWriteRowRequest)
                    return object;
                var message = new $root.main.proto.BatchWriteRowRequest();
                if (object.tables) {
                    if (!Array.isArray(object.tables))
                        throw TypeError(".main.proto.BatchWriteRowRequest.tables: array expected");
                    message.tables = [];
                    for (var i = 0; i < object.tables.length; ++i) {
                        if (typeof object.tables[i] !== "object")
                            throw TypeError(".main.proto.BatchWriteRowRequest.tables: object expected");
                        message.tables[i] = $root.main.proto.TableInBatchWriteRowRequest.fromObject(object.tables[i]);
                    }
                }
                if (object.transactionId != null)
                    message.transactionId = String(object.transactionId);
                return message;
            };

            /**
             * Creates a plain object from a BatchWriteRowRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.BatchWriteRowRequest
             * @static
             * @param {main.proto.BatchWriteRowRequest} message BatchWriteRowRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BatchWriteRowRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.tables = [];
                if (options.defaults)
                    object.transactionId = "";
                if (message.tables && message.tables.length) {
                    object.tables = [];
                    for (var j = 0; j < message.tables.length; ++j)
                        object.tables[j] = $root.main.proto.TableInBatchWriteRowRequest.toObject(message.tables[j], options);
                }
                if (message.transactionId != null && message.hasOwnProperty("transactionId"))
                    object.transactionId = message.transactionId;
                return object;
            };

            /**
             * Converts this BatchWriteRowRequest to JSON.
             * @function toJSON
             * @memberof main.proto.BatchWriteRowRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BatchWriteRowRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BatchWriteRowRequest;
        })();

        proto.RowInBatchWriteRowResponse = (function() {

            /**
             * Properties of a RowInBatchWriteRowResponse.
             * @memberof main.proto
             * @interface IRowInBatchWriteRowResponse
             * @property {boolean} isOk RowInBatchWriteRowResponse isOk
             * @property {main.proto.IError|null} [error] RowInBatchWriteRowResponse error
             * @property {main.proto.IConsumedCapacity|null} [consumed] RowInBatchWriteRowResponse consumed
             * @property {Uint8Array|null} [row] RowInBatchWriteRowResponse row
             */

            /**
             * Constructs a new RowInBatchWriteRowResponse.
             * @memberof main.proto
             * @classdesc Represents a RowInBatchWriteRowResponse.
             * @implements IRowInBatchWriteRowResponse
             * @constructor
             * @param {main.proto.IRowInBatchWriteRowResponse=} [properties] Properties to set
             */
            function RowInBatchWriteRowResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RowInBatchWriteRowResponse isOk.
             * @member {boolean} isOk
             * @memberof main.proto.RowInBatchWriteRowResponse
             * @instance
             */
            RowInBatchWriteRowResponse.prototype.isOk = false;

            /**
             * RowInBatchWriteRowResponse error.
             * @member {main.proto.IError|null|undefined} error
             * @memberof main.proto.RowInBatchWriteRowResponse
             * @instance
             */
            RowInBatchWriteRowResponse.prototype.error = null;

            /**
             * RowInBatchWriteRowResponse consumed.
             * @member {main.proto.IConsumedCapacity|null|undefined} consumed
             * @memberof main.proto.RowInBatchWriteRowResponse
             * @instance
             */
            RowInBatchWriteRowResponse.prototype.consumed = null;

            /**
             * RowInBatchWriteRowResponse row.
             * @member {Uint8Array} row
             * @memberof main.proto.RowInBatchWriteRowResponse
             * @instance
             */
            RowInBatchWriteRowResponse.prototype.row = $util.newBuffer([]);

            /**
             * Creates a new RowInBatchWriteRowResponse instance using the specified properties.
             * @function create
             * @memberof main.proto.RowInBatchWriteRowResponse
             * @static
             * @param {main.proto.IRowInBatchWriteRowResponse=} [properties] Properties to set
             * @returns {main.proto.RowInBatchWriteRowResponse} RowInBatchWriteRowResponse instance
             */
            RowInBatchWriteRowResponse.create = function create(properties) {
                return new RowInBatchWriteRowResponse(properties);
            };

            /**
             * Encodes the specified RowInBatchWriteRowResponse message. Does not implicitly {@link main.proto.RowInBatchWriteRowResponse.verify|verify} messages.
             * @function encode
             * @memberof main.proto.RowInBatchWriteRowResponse
             * @static
             * @param {main.proto.IRowInBatchWriteRowResponse} message RowInBatchWriteRowResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RowInBatchWriteRowResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isOk);
                if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                    $root.main.proto.Error.encode(message.error, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.consumed != null && Object.hasOwnProperty.call(message, "consumed"))
                    $root.main.proto.ConsumedCapacity.encode(message.consumed, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.row != null && Object.hasOwnProperty.call(message, "row"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.row);
                return writer;
            };

            /**
             * Encodes the specified RowInBatchWriteRowResponse message, length delimited. Does not implicitly {@link main.proto.RowInBatchWriteRowResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.RowInBatchWriteRowResponse
             * @static
             * @param {main.proto.IRowInBatchWriteRowResponse} message RowInBatchWriteRowResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RowInBatchWriteRowResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RowInBatchWriteRowResponse message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.RowInBatchWriteRowResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.RowInBatchWriteRowResponse} RowInBatchWriteRowResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RowInBatchWriteRowResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.RowInBatchWriteRowResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.isOk = reader.bool();
                        break;
                    case 2:
                        message.error = $root.main.proto.Error.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.consumed = $root.main.proto.ConsumedCapacity.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.row = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("isOk"))
                    throw $util.ProtocolError("missing required 'isOk'", { instance: message });
                return message;
            };

            /**
             * Decodes a RowInBatchWriteRowResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.RowInBatchWriteRowResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.RowInBatchWriteRowResponse} RowInBatchWriteRowResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RowInBatchWriteRowResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RowInBatchWriteRowResponse message.
             * @function verify
             * @memberof main.proto.RowInBatchWriteRowResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RowInBatchWriteRowResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (typeof message.isOk !== "boolean")
                    return "isOk: boolean expected";
                if (message.error != null && message.hasOwnProperty("error")) {
                    var error = $root.main.proto.Error.verify(message.error);
                    if (error)
                        return "error." + error;
                }
                if (message.consumed != null && message.hasOwnProperty("consumed")) {
                    var error = $root.main.proto.ConsumedCapacity.verify(message.consumed);
                    if (error)
                        return "consumed." + error;
                }
                if (message.row != null && message.hasOwnProperty("row"))
                    if (!(message.row && typeof message.row.length === "number" || $util.isString(message.row)))
                        return "row: buffer expected";
                return null;
            };

            /**
             * Creates a RowInBatchWriteRowResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.RowInBatchWriteRowResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.RowInBatchWriteRowResponse} RowInBatchWriteRowResponse
             */
            RowInBatchWriteRowResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.RowInBatchWriteRowResponse)
                    return object;
                var message = new $root.main.proto.RowInBatchWriteRowResponse();
                if (object.isOk != null)
                    message.isOk = Boolean(object.isOk);
                if (object.error != null) {
                    if (typeof object.error !== "object")
                        throw TypeError(".main.proto.RowInBatchWriteRowResponse.error: object expected");
                    message.error = $root.main.proto.Error.fromObject(object.error);
                }
                if (object.consumed != null) {
                    if (typeof object.consumed !== "object")
                        throw TypeError(".main.proto.RowInBatchWriteRowResponse.consumed: object expected");
                    message.consumed = $root.main.proto.ConsumedCapacity.fromObject(object.consumed);
                }
                if (object.row != null)
                    if (typeof object.row === "string")
                        $util.base64.decode(object.row, message.row = $util.newBuffer($util.base64.length(object.row)), 0);
                    else if (object.row.length)
                        message.row = object.row;
                return message;
            };

            /**
             * Creates a plain object from a RowInBatchWriteRowResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.RowInBatchWriteRowResponse
             * @static
             * @param {main.proto.RowInBatchWriteRowResponse} message RowInBatchWriteRowResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RowInBatchWriteRowResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.isOk = false;
                    object.error = null;
                    object.consumed = null;
                    if (options.bytes === String)
                        object.row = "";
                    else {
                        object.row = [];
                        if (options.bytes !== Array)
                            object.row = $util.newBuffer(object.row);
                    }
                }
                if (message.isOk != null && message.hasOwnProperty("isOk"))
                    object.isOk = message.isOk;
                if (message.error != null && message.hasOwnProperty("error"))
                    object.error = $root.main.proto.Error.toObject(message.error, options);
                if (message.consumed != null && message.hasOwnProperty("consumed"))
                    object.consumed = $root.main.proto.ConsumedCapacity.toObject(message.consumed, options);
                if (message.row != null && message.hasOwnProperty("row"))
                    object.row = options.bytes === String ? $util.base64.encode(message.row, 0, message.row.length) : options.bytes === Array ? Array.prototype.slice.call(message.row) : message.row;
                return object;
            };

            /**
             * Converts this RowInBatchWriteRowResponse to JSON.
             * @function toJSON
             * @memberof main.proto.RowInBatchWriteRowResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RowInBatchWriteRowResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RowInBatchWriteRowResponse;
        })();

        proto.TableInBatchWriteRowResponse = (function() {

            /**
             * Properties of a TableInBatchWriteRowResponse.
             * @memberof main.proto
             * @interface ITableInBatchWriteRowResponse
             * @property {string} tableName TableInBatchWriteRowResponse tableName
             * @property {Array.<main.proto.IRowInBatchWriteRowResponse>|null} [rows] TableInBatchWriteRowResponse rows
             */

            /**
             * Constructs a new TableInBatchWriteRowResponse.
             * @memberof main.proto
             * @classdesc Represents a TableInBatchWriteRowResponse.
             * @implements ITableInBatchWriteRowResponse
             * @constructor
             * @param {main.proto.ITableInBatchWriteRowResponse=} [properties] Properties to set
             */
            function TableInBatchWriteRowResponse(properties) {
                this.rows = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TableInBatchWriteRowResponse tableName.
             * @member {string} tableName
             * @memberof main.proto.TableInBatchWriteRowResponse
             * @instance
             */
            TableInBatchWriteRowResponse.prototype.tableName = "";

            /**
             * TableInBatchWriteRowResponse rows.
             * @member {Array.<main.proto.IRowInBatchWriteRowResponse>} rows
             * @memberof main.proto.TableInBatchWriteRowResponse
             * @instance
             */
            TableInBatchWriteRowResponse.prototype.rows = $util.emptyArray;

            /**
             * Creates a new TableInBatchWriteRowResponse instance using the specified properties.
             * @function create
             * @memberof main.proto.TableInBatchWriteRowResponse
             * @static
             * @param {main.proto.ITableInBatchWriteRowResponse=} [properties] Properties to set
             * @returns {main.proto.TableInBatchWriteRowResponse} TableInBatchWriteRowResponse instance
             */
            TableInBatchWriteRowResponse.create = function create(properties) {
                return new TableInBatchWriteRowResponse(properties);
            };

            /**
             * Encodes the specified TableInBatchWriteRowResponse message. Does not implicitly {@link main.proto.TableInBatchWriteRowResponse.verify|verify} messages.
             * @function encode
             * @memberof main.proto.TableInBatchWriteRowResponse
             * @static
             * @param {main.proto.ITableInBatchWriteRowResponse} message TableInBatchWriteRowResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TableInBatchWriteRowResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.tableName);
                if (message.rows != null && message.rows.length)
                    for (var i = 0; i < message.rows.length; ++i)
                        $root.main.proto.RowInBatchWriteRowResponse.encode(message.rows[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified TableInBatchWriteRowResponse message, length delimited. Does not implicitly {@link main.proto.TableInBatchWriteRowResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.TableInBatchWriteRowResponse
             * @static
             * @param {main.proto.ITableInBatchWriteRowResponse} message TableInBatchWriteRowResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TableInBatchWriteRowResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TableInBatchWriteRowResponse message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.TableInBatchWriteRowResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.TableInBatchWriteRowResponse} TableInBatchWriteRowResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TableInBatchWriteRowResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.TableInBatchWriteRowResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tableName = reader.string();
                        break;
                    case 2:
                        if (!(message.rows && message.rows.length))
                            message.rows = [];
                        message.rows.push($root.main.proto.RowInBatchWriteRowResponse.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("tableName"))
                    throw $util.ProtocolError("missing required 'tableName'", { instance: message });
                return message;
            };

            /**
             * Decodes a TableInBatchWriteRowResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.TableInBatchWriteRowResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.TableInBatchWriteRowResponse} TableInBatchWriteRowResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TableInBatchWriteRowResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TableInBatchWriteRowResponse message.
             * @function verify
             * @memberof main.proto.TableInBatchWriteRowResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TableInBatchWriteRowResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.tableName))
                    return "tableName: string expected";
                if (message.rows != null && message.hasOwnProperty("rows")) {
                    if (!Array.isArray(message.rows))
                        return "rows: array expected";
                    for (var i = 0; i < message.rows.length; ++i) {
                        var error = $root.main.proto.RowInBatchWriteRowResponse.verify(message.rows[i]);
                        if (error)
                            return "rows." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a TableInBatchWriteRowResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.TableInBatchWriteRowResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.TableInBatchWriteRowResponse} TableInBatchWriteRowResponse
             */
            TableInBatchWriteRowResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.TableInBatchWriteRowResponse)
                    return object;
                var message = new $root.main.proto.TableInBatchWriteRowResponse();
                if (object.tableName != null)
                    message.tableName = String(object.tableName);
                if (object.rows) {
                    if (!Array.isArray(object.rows))
                        throw TypeError(".main.proto.TableInBatchWriteRowResponse.rows: array expected");
                    message.rows = [];
                    for (var i = 0; i < object.rows.length; ++i) {
                        if (typeof object.rows[i] !== "object")
                            throw TypeError(".main.proto.TableInBatchWriteRowResponse.rows: object expected");
                        message.rows[i] = $root.main.proto.RowInBatchWriteRowResponse.fromObject(object.rows[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a TableInBatchWriteRowResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.TableInBatchWriteRowResponse
             * @static
             * @param {main.proto.TableInBatchWriteRowResponse} message TableInBatchWriteRowResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TableInBatchWriteRowResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.rows = [];
                if (options.defaults)
                    object.tableName = "";
                if (message.tableName != null && message.hasOwnProperty("tableName"))
                    object.tableName = message.tableName;
                if (message.rows && message.rows.length) {
                    object.rows = [];
                    for (var j = 0; j < message.rows.length; ++j)
                        object.rows[j] = $root.main.proto.RowInBatchWriteRowResponse.toObject(message.rows[j], options);
                }
                return object;
            };

            /**
             * Converts this TableInBatchWriteRowResponse to JSON.
             * @function toJSON
             * @memberof main.proto.TableInBatchWriteRowResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TableInBatchWriteRowResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TableInBatchWriteRowResponse;
        })();

        proto.BatchWriteRowResponse = (function() {

            /**
             * Properties of a BatchWriteRowResponse.
             * @memberof main.proto
             * @interface IBatchWriteRowResponse
             * @property {Array.<main.proto.ITableInBatchWriteRowResponse>|null} [tables] BatchWriteRowResponse tables
             */

            /**
             * Constructs a new BatchWriteRowResponse.
             * @memberof main.proto
             * @classdesc Represents a BatchWriteRowResponse.
             * @implements IBatchWriteRowResponse
             * @constructor
             * @param {main.proto.IBatchWriteRowResponse=} [properties] Properties to set
             */
            function BatchWriteRowResponse(properties) {
                this.tables = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BatchWriteRowResponse tables.
             * @member {Array.<main.proto.ITableInBatchWriteRowResponse>} tables
             * @memberof main.proto.BatchWriteRowResponse
             * @instance
             */
            BatchWriteRowResponse.prototype.tables = $util.emptyArray;

            /**
             * Creates a new BatchWriteRowResponse instance using the specified properties.
             * @function create
             * @memberof main.proto.BatchWriteRowResponse
             * @static
             * @param {main.proto.IBatchWriteRowResponse=} [properties] Properties to set
             * @returns {main.proto.BatchWriteRowResponse} BatchWriteRowResponse instance
             */
            BatchWriteRowResponse.create = function create(properties) {
                return new BatchWriteRowResponse(properties);
            };

            /**
             * Encodes the specified BatchWriteRowResponse message. Does not implicitly {@link main.proto.BatchWriteRowResponse.verify|verify} messages.
             * @function encode
             * @memberof main.proto.BatchWriteRowResponse
             * @static
             * @param {main.proto.IBatchWriteRowResponse} message BatchWriteRowResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchWriteRowResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tables != null && message.tables.length)
                    for (var i = 0; i < message.tables.length; ++i)
                        $root.main.proto.TableInBatchWriteRowResponse.encode(message.tables[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified BatchWriteRowResponse message, length delimited. Does not implicitly {@link main.proto.BatchWriteRowResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.BatchWriteRowResponse
             * @static
             * @param {main.proto.IBatchWriteRowResponse} message BatchWriteRowResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchWriteRowResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BatchWriteRowResponse message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.BatchWriteRowResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.BatchWriteRowResponse} BatchWriteRowResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchWriteRowResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.BatchWriteRowResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.tables && message.tables.length))
                            message.tables = [];
                        message.tables.push($root.main.proto.TableInBatchWriteRowResponse.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BatchWriteRowResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.BatchWriteRowResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.BatchWriteRowResponse} BatchWriteRowResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchWriteRowResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BatchWriteRowResponse message.
             * @function verify
             * @memberof main.proto.BatchWriteRowResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BatchWriteRowResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tables != null && message.hasOwnProperty("tables")) {
                    if (!Array.isArray(message.tables))
                        return "tables: array expected";
                    for (var i = 0; i < message.tables.length; ++i) {
                        var error = $root.main.proto.TableInBatchWriteRowResponse.verify(message.tables[i]);
                        if (error)
                            return "tables." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a BatchWriteRowResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.BatchWriteRowResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.BatchWriteRowResponse} BatchWriteRowResponse
             */
            BatchWriteRowResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.BatchWriteRowResponse)
                    return object;
                var message = new $root.main.proto.BatchWriteRowResponse();
                if (object.tables) {
                    if (!Array.isArray(object.tables))
                        throw TypeError(".main.proto.BatchWriteRowResponse.tables: array expected");
                    message.tables = [];
                    for (var i = 0; i < object.tables.length; ++i) {
                        if (typeof object.tables[i] !== "object")
                            throw TypeError(".main.proto.BatchWriteRowResponse.tables: object expected");
                        message.tables[i] = $root.main.proto.TableInBatchWriteRowResponse.fromObject(object.tables[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a BatchWriteRowResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.BatchWriteRowResponse
             * @static
             * @param {main.proto.BatchWriteRowResponse} message BatchWriteRowResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BatchWriteRowResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.tables = [];
                if (message.tables && message.tables.length) {
                    object.tables = [];
                    for (var j = 0; j < message.tables.length; ++j)
                        object.tables[j] = $root.main.proto.TableInBatchWriteRowResponse.toObject(message.tables[j], options);
                }
                return object;
            };

            /**
             * Converts this BatchWriteRowResponse to JSON.
             * @function toJSON
             * @memberof main.proto.BatchWriteRowResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BatchWriteRowResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BatchWriteRowResponse;
        })();

        /**
         * Direction enum.
         * @name main.proto.Direction
         * @enum {number}
         * @property {number} FORWARD=0 FORWARD value
         * @property {number} BACKWARD=1 BACKWARD value
         */
        proto.Direction = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "FORWARD"] = 0;
            values[valuesById[1] = "BACKWARD"] = 1;
            return values;
        })();

        proto.GetRangeRequest = (function() {

            /**
             * Properties of a GetRangeRequest.
             * @memberof main.proto
             * @interface IGetRangeRequest
             * @property {string} tableName GetRangeRequest tableName
             * @property {main.proto.Direction} direction GetRangeRequest direction
             * @property {Array.<string>|null} [columnsToGet] GetRangeRequest columnsToGet
             * @property {main.proto.ITimeRange|null} [timeRange] GetRangeRequest timeRange
             * @property {number|null} [maxVersions] GetRangeRequest maxVersions
             * @property {number|null} [limit] GetRangeRequest limit
             * @property {Uint8Array} inclusiveStartPrimaryKey GetRangeRequest inclusiveStartPrimaryKey
             * @property {Uint8Array} exclusiveEndPrimaryKey GetRangeRequest exclusiveEndPrimaryKey
             * @property {boolean|null} [cacheBlocks] GetRangeRequest cacheBlocks
             * @property {Uint8Array|null} [filter] GetRangeRequest filter
             * @property {string|null} [startColumn] GetRangeRequest startColumn
             * @property {string|null} [endColumn] GetRangeRequest endColumn
             * @property {Uint8Array|null} [token] GetRangeRequest token
             * @property {string|null} [transactionId] GetRangeRequest transactionId
             * @property {main.proto.DataBlockType|null} [dataBlockTypeHint] GetRangeRequest dataBlockTypeHint
             * @property {boolean|null} [returnEntirePrimaryKeys] GetRangeRequest returnEntirePrimaryKeys
             * @property {main.proto.CompressType|null} [compressTypeHint] GetRangeRequest compressTypeHint
             */

            /**
             * Constructs a new GetRangeRequest.
             * @memberof main.proto
             * @classdesc HBase支持以下参数：
             * 1. TimeRange或指定time
             * 2. Filter（根据列值或列名来过滤）
             * 我们只支持给同版本的选择条件。
             * @implements IGetRangeRequest
             * @constructor
             * @param {main.proto.IGetRangeRequest=} [properties] Properties to set
             */
            function GetRangeRequest(properties) {
                this.columnsToGet = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetRangeRequest tableName.
             * @member {string} tableName
             * @memberof main.proto.GetRangeRequest
             * @instance
             */
            GetRangeRequest.prototype.tableName = "";

            /**
             * GetRangeRequest direction.
             * @member {main.proto.Direction} direction
             * @memberof main.proto.GetRangeRequest
             * @instance
             */
            GetRangeRequest.prototype.direction = 0;

            /**
             * GetRangeRequest columnsToGet.
             * @member {Array.<string>} columnsToGet
             * @memberof main.proto.GetRangeRequest
             * @instance
             */
            GetRangeRequest.prototype.columnsToGet = $util.emptyArray;

            /**
             * GetRangeRequest timeRange.
             * @member {main.proto.ITimeRange|null|undefined} timeRange
             * @memberof main.proto.GetRangeRequest
             * @instance
             */
            GetRangeRequest.prototype.timeRange = null;

            /**
             * GetRangeRequest maxVersions.
             * @member {number} maxVersions
             * @memberof main.proto.GetRangeRequest
             * @instance
             */
            GetRangeRequest.prototype.maxVersions = 0;

            /**
             * GetRangeRequest limit.
             * @member {number} limit
             * @memberof main.proto.GetRangeRequest
             * @instance
             */
            GetRangeRequest.prototype.limit = 0;

            /**
             * GetRangeRequest inclusiveStartPrimaryKey.
             * @member {Uint8Array} inclusiveStartPrimaryKey
             * @memberof main.proto.GetRangeRequest
             * @instance
             */
            GetRangeRequest.prototype.inclusiveStartPrimaryKey = $util.newBuffer([]);

            /**
             * GetRangeRequest exclusiveEndPrimaryKey.
             * @member {Uint8Array} exclusiveEndPrimaryKey
             * @memberof main.proto.GetRangeRequest
             * @instance
             */
            GetRangeRequest.prototype.exclusiveEndPrimaryKey = $util.newBuffer([]);

            /**
             * GetRangeRequest cacheBlocks.
             * @member {boolean} cacheBlocks
             * @memberof main.proto.GetRangeRequest
             * @instance
             */
            GetRangeRequest.prototype.cacheBlocks = true;

            /**
             * GetRangeRequest filter.
             * @member {Uint8Array} filter
             * @memberof main.proto.GetRangeRequest
             * @instance
             */
            GetRangeRequest.prototype.filter = $util.newBuffer([]);

            /**
             * GetRangeRequest startColumn.
             * @member {string} startColumn
             * @memberof main.proto.GetRangeRequest
             * @instance
             */
            GetRangeRequest.prototype.startColumn = "";

            /**
             * GetRangeRequest endColumn.
             * @member {string} endColumn
             * @memberof main.proto.GetRangeRequest
             * @instance
             */
            GetRangeRequest.prototype.endColumn = "";

            /**
             * GetRangeRequest token.
             * @member {Uint8Array} token
             * @memberof main.proto.GetRangeRequest
             * @instance
             */
            GetRangeRequest.prototype.token = $util.newBuffer([]);

            /**
             * GetRangeRequest transactionId.
             * @member {string} transactionId
             * @memberof main.proto.GetRangeRequest
             * @instance
             */
            GetRangeRequest.prototype.transactionId = "";

            /**
             * GetRangeRequest dataBlockTypeHint.
             * @member {main.proto.DataBlockType} dataBlockTypeHint
             * @memberof main.proto.GetRangeRequest
             * @instance
             */
            GetRangeRequest.prototype.dataBlockTypeHint = 0;

            /**
             * GetRangeRequest returnEntirePrimaryKeys.
             * @member {boolean} returnEntirePrimaryKeys
             * @memberof main.proto.GetRangeRequest
             * @instance
             */
            GetRangeRequest.prototype.returnEntirePrimaryKeys = true;

            /**
             * GetRangeRequest compressTypeHint.
             * @member {main.proto.CompressType} compressTypeHint
             * @memberof main.proto.GetRangeRequest
             * @instance
             */
            GetRangeRequest.prototype.compressTypeHint = 0;

            /**
             * Creates a new GetRangeRequest instance using the specified properties.
             * @function create
             * @memberof main.proto.GetRangeRequest
             * @static
             * @param {main.proto.IGetRangeRequest=} [properties] Properties to set
             * @returns {main.proto.GetRangeRequest} GetRangeRequest instance
             */
            GetRangeRequest.create = function create(properties) {
                return new GetRangeRequest(properties);
            };

            /**
             * Encodes the specified GetRangeRequest message. Does not implicitly {@link main.proto.GetRangeRequest.verify|verify} messages.
             * @function encode
             * @memberof main.proto.GetRangeRequest
             * @static
             * @param {main.proto.IGetRangeRequest} message GetRangeRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetRangeRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.tableName);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.direction);
                if (message.columnsToGet != null && message.columnsToGet.length)
                    for (var i = 0; i < message.columnsToGet.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.columnsToGet[i]);
                if (message.timeRange != null && Object.hasOwnProperty.call(message, "timeRange"))
                    $root.main.proto.TimeRange.encode(message.timeRange, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.maxVersions != null && Object.hasOwnProperty.call(message, "maxVersions"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.maxVersions);
                if (message.limit != null && Object.hasOwnProperty.call(message, "limit"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.limit);
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.inclusiveStartPrimaryKey);
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.exclusiveEndPrimaryKey);
                if (message.cacheBlocks != null && Object.hasOwnProperty.call(message, "cacheBlocks"))
                    writer.uint32(/* id 9, wireType 0 =*/72).bool(message.cacheBlocks);
                if (message.filter != null && Object.hasOwnProperty.call(message, "filter"))
                    writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.filter);
                if (message.startColumn != null && Object.hasOwnProperty.call(message, "startColumn"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.startColumn);
                if (message.endColumn != null && Object.hasOwnProperty.call(message, "endColumn"))
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.endColumn);
                if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                    writer.uint32(/* id 13, wireType 2 =*/106).bytes(message.token);
                if (message.transactionId != null && Object.hasOwnProperty.call(message, "transactionId"))
                    writer.uint32(/* id 14, wireType 2 =*/114).string(message.transactionId);
                if (message.dataBlockTypeHint != null && Object.hasOwnProperty.call(message, "dataBlockTypeHint"))
                    writer.uint32(/* id 15, wireType 0 =*/120).int32(message.dataBlockTypeHint);
                if (message.returnEntirePrimaryKeys != null && Object.hasOwnProperty.call(message, "returnEntirePrimaryKeys"))
                    writer.uint32(/* id 16, wireType 0 =*/128).bool(message.returnEntirePrimaryKeys);
                if (message.compressTypeHint != null && Object.hasOwnProperty.call(message, "compressTypeHint"))
                    writer.uint32(/* id 17, wireType 0 =*/136).int32(message.compressTypeHint);
                return writer;
            };

            /**
             * Encodes the specified GetRangeRequest message, length delimited. Does not implicitly {@link main.proto.GetRangeRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.GetRangeRequest
             * @static
             * @param {main.proto.IGetRangeRequest} message GetRangeRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetRangeRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetRangeRequest message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.GetRangeRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.GetRangeRequest} GetRangeRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetRangeRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.GetRangeRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tableName = reader.string();
                        break;
                    case 2:
                        message.direction = reader.int32();
                        break;
                    case 3:
                        if (!(message.columnsToGet && message.columnsToGet.length))
                            message.columnsToGet = [];
                        message.columnsToGet.push(reader.string());
                        break;
                    case 4:
                        message.timeRange = $root.main.proto.TimeRange.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.maxVersions = reader.int32();
                        break;
                    case 6:
                        message.limit = reader.int32();
                        break;
                    case 7:
                        message.inclusiveStartPrimaryKey = reader.bytes();
                        break;
                    case 8:
                        message.exclusiveEndPrimaryKey = reader.bytes();
                        break;
                    case 9:
                        message.cacheBlocks = reader.bool();
                        break;
                    case 10:
                        message.filter = reader.bytes();
                        break;
                    case 11:
                        message.startColumn = reader.string();
                        break;
                    case 12:
                        message.endColumn = reader.string();
                        break;
                    case 13:
                        message.token = reader.bytes();
                        break;
                    case 14:
                        message.transactionId = reader.string();
                        break;
                    case 15:
                        message.dataBlockTypeHint = reader.int32();
                        break;
                    case 16:
                        message.returnEntirePrimaryKeys = reader.bool();
                        break;
                    case 17:
                        message.compressTypeHint = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("tableName"))
                    throw $util.ProtocolError("missing required 'tableName'", { instance: message });
                if (!message.hasOwnProperty("direction"))
                    throw $util.ProtocolError("missing required 'direction'", { instance: message });
                if (!message.hasOwnProperty("inclusiveStartPrimaryKey"))
                    throw $util.ProtocolError("missing required 'inclusiveStartPrimaryKey'", { instance: message });
                if (!message.hasOwnProperty("exclusiveEndPrimaryKey"))
                    throw $util.ProtocolError("missing required 'exclusiveEndPrimaryKey'", { instance: message });
                return message;
            };

            /**
             * Decodes a GetRangeRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.GetRangeRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.GetRangeRequest} GetRangeRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetRangeRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetRangeRequest message.
             * @function verify
             * @memberof main.proto.GetRangeRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetRangeRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.tableName))
                    return "tableName: string expected";
                switch (message.direction) {
                default:
                    return "direction: enum value expected";
                case 0:
                case 1:
                    break;
                }
                if (message.columnsToGet != null && message.hasOwnProperty("columnsToGet")) {
                    if (!Array.isArray(message.columnsToGet))
                        return "columnsToGet: array expected";
                    for (var i = 0; i < message.columnsToGet.length; ++i)
                        if (!$util.isString(message.columnsToGet[i]))
                            return "columnsToGet: string[] expected";
                }
                if (message.timeRange != null && message.hasOwnProperty("timeRange")) {
                    var error = $root.main.proto.TimeRange.verify(message.timeRange);
                    if (error)
                        return "timeRange." + error;
                }
                if (message.maxVersions != null && message.hasOwnProperty("maxVersions"))
                    if (!$util.isInteger(message.maxVersions))
                        return "maxVersions: integer expected";
                if (message.limit != null && message.hasOwnProperty("limit"))
                    if (!$util.isInteger(message.limit))
                        return "limit: integer expected";
                if (!(message.inclusiveStartPrimaryKey && typeof message.inclusiveStartPrimaryKey.length === "number" || $util.isString(message.inclusiveStartPrimaryKey)))
                    return "inclusiveStartPrimaryKey: buffer expected";
                if (!(message.exclusiveEndPrimaryKey && typeof message.exclusiveEndPrimaryKey.length === "number" || $util.isString(message.exclusiveEndPrimaryKey)))
                    return "exclusiveEndPrimaryKey: buffer expected";
                if (message.cacheBlocks != null && message.hasOwnProperty("cacheBlocks"))
                    if (typeof message.cacheBlocks !== "boolean")
                        return "cacheBlocks: boolean expected";
                if (message.filter != null && message.hasOwnProperty("filter"))
                    if (!(message.filter && typeof message.filter.length === "number" || $util.isString(message.filter)))
                        return "filter: buffer expected";
                if (message.startColumn != null && message.hasOwnProperty("startColumn"))
                    if (!$util.isString(message.startColumn))
                        return "startColumn: string expected";
                if (message.endColumn != null && message.hasOwnProperty("endColumn"))
                    if (!$util.isString(message.endColumn))
                        return "endColumn: string expected";
                if (message.token != null && message.hasOwnProperty("token"))
                    if (!(message.token && typeof message.token.length === "number" || $util.isString(message.token)))
                        return "token: buffer expected";
                if (message.transactionId != null && message.hasOwnProperty("transactionId"))
                    if (!$util.isString(message.transactionId))
                        return "transactionId: string expected";
                if (message.dataBlockTypeHint != null && message.hasOwnProperty("dataBlockTypeHint"))
                    switch (message.dataBlockTypeHint) {
                    default:
                        return "dataBlockTypeHint: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.returnEntirePrimaryKeys != null && message.hasOwnProperty("returnEntirePrimaryKeys"))
                    if (typeof message.returnEntirePrimaryKeys !== "boolean")
                        return "returnEntirePrimaryKeys: boolean expected";
                if (message.compressTypeHint != null && message.hasOwnProperty("compressTypeHint"))
                    switch (message.compressTypeHint) {
                    default:
                        return "compressTypeHint: enum value expected";
                    case 0:
                        break;
                    }
                return null;
            };

            /**
             * Creates a GetRangeRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.GetRangeRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.GetRangeRequest} GetRangeRequest
             */
            GetRangeRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.GetRangeRequest)
                    return object;
                var message = new $root.main.proto.GetRangeRequest();
                if (object.tableName != null)
                    message.tableName = String(object.tableName);
                switch (object.direction) {
                case "FORWARD":
                case 0:
                    message.direction = 0;
                    break;
                case "BACKWARD":
                case 1:
                    message.direction = 1;
                    break;
                }
                if (object.columnsToGet) {
                    if (!Array.isArray(object.columnsToGet))
                        throw TypeError(".main.proto.GetRangeRequest.columnsToGet: array expected");
                    message.columnsToGet = [];
                    for (var i = 0; i < object.columnsToGet.length; ++i)
                        message.columnsToGet[i] = String(object.columnsToGet[i]);
                }
                if (object.timeRange != null) {
                    if (typeof object.timeRange !== "object")
                        throw TypeError(".main.proto.GetRangeRequest.timeRange: object expected");
                    message.timeRange = $root.main.proto.TimeRange.fromObject(object.timeRange);
                }
                if (object.maxVersions != null)
                    message.maxVersions = object.maxVersions | 0;
                if (object.limit != null)
                    message.limit = object.limit | 0;
                if (object.inclusiveStartPrimaryKey != null)
                    if (typeof object.inclusiveStartPrimaryKey === "string")
                        $util.base64.decode(object.inclusiveStartPrimaryKey, message.inclusiveStartPrimaryKey = $util.newBuffer($util.base64.length(object.inclusiveStartPrimaryKey)), 0);
                    else if (object.inclusiveStartPrimaryKey.length)
                        message.inclusiveStartPrimaryKey = object.inclusiveStartPrimaryKey;
                if (object.exclusiveEndPrimaryKey != null)
                    if (typeof object.exclusiveEndPrimaryKey === "string")
                        $util.base64.decode(object.exclusiveEndPrimaryKey, message.exclusiveEndPrimaryKey = $util.newBuffer($util.base64.length(object.exclusiveEndPrimaryKey)), 0);
                    else if (object.exclusiveEndPrimaryKey.length)
                        message.exclusiveEndPrimaryKey = object.exclusiveEndPrimaryKey;
                if (object.cacheBlocks != null)
                    message.cacheBlocks = Boolean(object.cacheBlocks);
                if (object.filter != null)
                    if (typeof object.filter === "string")
                        $util.base64.decode(object.filter, message.filter = $util.newBuffer($util.base64.length(object.filter)), 0);
                    else if (object.filter.length)
                        message.filter = object.filter;
                if (object.startColumn != null)
                    message.startColumn = String(object.startColumn);
                if (object.endColumn != null)
                    message.endColumn = String(object.endColumn);
                if (object.token != null)
                    if (typeof object.token === "string")
                        $util.base64.decode(object.token, message.token = $util.newBuffer($util.base64.length(object.token)), 0);
                    else if (object.token.length)
                        message.token = object.token;
                if (object.transactionId != null)
                    message.transactionId = String(object.transactionId);
                switch (object.dataBlockTypeHint) {
                case "DBT_PLAIN_BUFFER":
                case 0:
                    message.dataBlockTypeHint = 0;
                    break;
                case "DBT_SIMPLE_ROW_MATRIX":
                case 1:
                    message.dataBlockTypeHint = 1;
                    break;
                }
                if (object.returnEntirePrimaryKeys != null)
                    message.returnEntirePrimaryKeys = Boolean(object.returnEntirePrimaryKeys);
                switch (object.compressTypeHint) {
                case "CPT_NONE":
                case 0:
                    message.compressTypeHint = 0;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a GetRangeRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.GetRangeRequest
             * @static
             * @param {main.proto.GetRangeRequest} message GetRangeRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetRangeRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.columnsToGet = [];
                if (options.defaults) {
                    object.tableName = "";
                    object.direction = options.enums === String ? "FORWARD" : 0;
                    object.timeRange = null;
                    object.maxVersions = 0;
                    object.limit = 0;
                    if (options.bytes === String)
                        object.inclusiveStartPrimaryKey = "";
                    else {
                        object.inclusiveStartPrimaryKey = [];
                        if (options.bytes !== Array)
                            object.inclusiveStartPrimaryKey = $util.newBuffer(object.inclusiveStartPrimaryKey);
                    }
                    if (options.bytes === String)
                        object.exclusiveEndPrimaryKey = "";
                    else {
                        object.exclusiveEndPrimaryKey = [];
                        if (options.bytes !== Array)
                            object.exclusiveEndPrimaryKey = $util.newBuffer(object.exclusiveEndPrimaryKey);
                    }
                    object.cacheBlocks = true;
                    if (options.bytes === String)
                        object.filter = "";
                    else {
                        object.filter = [];
                        if (options.bytes !== Array)
                            object.filter = $util.newBuffer(object.filter);
                    }
                    object.startColumn = "";
                    object.endColumn = "";
                    if (options.bytes === String)
                        object.token = "";
                    else {
                        object.token = [];
                        if (options.bytes !== Array)
                            object.token = $util.newBuffer(object.token);
                    }
                    object.transactionId = "";
                    object.dataBlockTypeHint = options.enums === String ? "DBT_PLAIN_BUFFER" : 0;
                    object.returnEntirePrimaryKeys = true;
                    object.compressTypeHint = options.enums === String ? "CPT_NONE" : 0;
                }
                if (message.tableName != null && message.hasOwnProperty("tableName"))
                    object.tableName = message.tableName;
                if (message.direction != null && message.hasOwnProperty("direction"))
                    object.direction = options.enums === String ? $root.main.proto.Direction[message.direction] : message.direction;
                if (message.columnsToGet && message.columnsToGet.length) {
                    object.columnsToGet = [];
                    for (var j = 0; j < message.columnsToGet.length; ++j)
                        object.columnsToGet[j] = message.columnsToGet[j];
                }
                if (message.timeRange != null && message.hasOwnProperty("timeRange"))
                    object.timeRange = $root.main.proto.TimeRange.toObject(message.timeRange, options);
                if (message.maxVersions != null && message.hasOwnProperty("maxVersions"))
                    object.maxVersions = message.maxVersions;
                if (message.limit != null && message.hasOwnProperty("limit"))
                    object.limit = message.limit;
                if (message.inclusiveStartPrimaryKey != null && message.hasOwnProperty("inclusiveStartPrimaryKey"))
                    object.inclusiveStartPrimaryKey = options.bytes === String ? $util.base64.encode(message.inclusiveStartPrimaryKey, 0, message.inclusiveStartPrimaryKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.inclusiveStartPrimaryKey) : message.inclusiveStartPrimaryKey;
                if (message.exclusiveEndPrimaryKey != null && message.hasOwnProperty("exclusiveEndPrimaryKey"))
                    object.exclusiveEndPrimaryKey = options.bytes === String ? $util.base64.encode(message.exclusiveEndPrimaryKey, 0, message.exclusiveEndPrimaryKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.exclusiveEndPrimaryKey) : message.exclusiveEndPrimaryKey;
                if (message.cacheBlocks != null && message.hasOwnProperty("cacheBlocks"))
                    object.cacheBlocks = message.cacheBlocks;
                if (message.filter != null && message.hasOwnProperty("filter"))
                    object.filter = options.bytes === String ? $util.base64.encode(message.filter, 0, message.filter.length) : options.bytes === Array ? Array.prototype.slice.call(message.filter) : message.filter;
                if (message.startColumn != null && message.hasOwnProperty("startColumn"))
                    object.startColumn = message.startColumn;
                if (message.endColumn != null && message.hasOwnProperty("endColumn"))
                    object.endColumn = message.endColumn;
                if (message.token != null && message.hasOwnProperty("token"))
                    object.token = options.bytes === String ? $util.base64.encode(message.token, 0, message.token.length) : options.bytes === Array ? Array.prototype.slice.call(message.token) : message.token;
                if (message.transactionId != null && message.hasOwnProperty("transactionId"))
                    object.transactionId = message.transactionId;
                if (message.dataBlockTypeHint != null && message.hasOwnProperty("dataBlockTypeHint"))
                    object.dataBlockTypeHint = options.enums === String ? $root.main.proto.DataBlockType[message.dataBlockTypeHint] : message.dataBlockTypeHint;
                if (message.returnEntirePrimaryKeys != null && message.hasOwnProperty("returnEntirePrimaryKeys"))
                    object.returnEntirePrimaryKeys = message.returnEntirePrimaryKeys;
                if (message.compressTypeHint != null && message.hasOwnProperty("compressTypeHint"))
                    object.compressTypeHint = options.enums === String ? $root.main.proto.CompressType[message.compressTypeHint] : message.compressTypeHint;
                return object;
            };

            /**
             * Converts this GetRangeRequest to JSON.
             * @function toJSON
             * @memberof main.proto.GetRangeRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetRangeRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GetRangeRequest;
        })();

        proto.GetRangeResponse = (function() {

            /**
             * Properties of a GetRangeResponse.
             * @memberof main.proto
             * @interface IGetRangeResponse
             * @property {main.proto.IConsumedCapacity} consumed GetRangeResponse consumed
             * @property {Uint8Array} rows GetRangeResponse rows
             * @property {Uint8Array|null} [nextStartPrimaryKey] GetRangeResponse nextStartPrimaryKey
             * @property {Uint8Array|null} [nextToken] GetRangeResponse nextToken
             * @property {main.proto.DataBlockType|null} [dataBlockType] GetRangeResponse dataBlockType
             * @property {main.proto.CompressType|null} [compressType] GetRangeResponse compressType
             */

            /**
             * Constructs a new GetRangeResponse.
             * @memberof main.proto
             * @classdesc Represents a GetRangeResponse.
             * @implements IGetRangeResponse
             * @constructor
             * @param {main.proto.IGetRangeResponse=} [properties] Properties to set
             */
            function GetRangeResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetRangeResponse consumed.
             * @member {main.proto.IConsumedCapacity} consumed
             * @memberof main.proto.GetRangeResponse
             * @instance
             */
            GetRangeResponse.prototype.consumed = null;

            /**
             * GetRangeResponse rows.
             * @member {Uint8Array} rows
             * @memberof main.proto.GetRangeResponse
             * @instance
             */
            GetRangeResponse.prototype.rows = $util.newBuffer([]);

            /**
             * GetRangeResponse nextStartPrimaryKey.
             * @member {Uint8Array} nextStartPrimaryKey
             * @memberof main.proto.GetRangeResponse
             * @instance
             */
            GetRangeResponse.prototype.nextStartPrimaryKey = $util.newBuffer([]);

            /**
             * GetRangeResponse nextToken.
             * @member {Uint8Array} nextToken
             * @memberof main.proto.GetRangeResponse
             * @instance
             */
            GetRangeResponse.prototype.nextToken = $util.newBuffer([]);

            /**
             * GetRangeResponse dataBlockType.
             * @member {main.proto.DataBlockType} dataBlockType
             * @memberof main.proto.GetRangeResponse
             * @instance
             */
            GetRangeResponse.prototype.dataBlockType = 0;

            /**
             * GetRangeResponse compressType.
             * @member {main.proto.CompressType} compressType
             * @memberof main.proto.GetRangeResponse
             * @instance
             */
            GetRangeResponse.prototype.compressType = 0;

            /**
             * Creates a new GetRangeResponse instance using the specified properties.
             * @function create
             * @memberof main.proto.GetRangeResponse
             * @static
             * @param {main.proto.IGetRangeResponse=} [properties] Properties to set
             * @returns {main.proto.GetRangeResponse} GetRangeResponse instance
             */
            GetRangeResponse.create = function create(properties) {
                return new GetRangeResponse(properties);
            };

            /**
             * Encodes the specified GetRangeResponse message. Does not implicitly {@link main.proto.GetRangeResponse.verify|verify} messages.
             * @function encode
             * @memberof main.proto.GetRangeResponse
             * @static
             * @param {main.proto.IGetRangeResponse} message GetRangeResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetRangeResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                $root.main.proto.ConsumedCapacity.encode(message.consumed, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.rows);
                if (message.nextStartPrimaryKey != null && Object.hasOwnProperty.call(message, "nextStartPrimaryKey"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.nextStartPrimaryKey);
                if (message.nextToken != null && Object.hasOwnProperty.call(message, "nextToken"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.nextToken);
                if (message.dataBlockType != null && Object.hasOwnProperty.call(message, "dataBlockType"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.dataBlockType);
                if (message.compressType != null && Object.hasOwnProperty.call(message, "compressType"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.compressType);
                return writer;
            };

            /**
             * Encodes the specified GetRangeResponse message, length delimited. Does not implicitly {@link main.proto.GetRangeResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.GetRangeResponse
             * @static
             * @param {main.proto.IGetRangeResponse} message GetRangeResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetRangeResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetRangeResponse message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.GetRangeResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.GetRangeResponse} GetRangeResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetRangeResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.GetRangeResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.consumed = $root.main.proto.ConsumedCapacity.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.rows = reader.bytes();
                        break;
                    case 3:
                        message.nextStartPrimaryKey = reader.bytes();
                        break;
                    case 4:
                        message.nextToken = reader.bytes();
                        break;
                    case 5:
                        message.dataBlockType = reader.int32();
                        break;
                    case 6:
                        message.compressType = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("consumed"))
                    throw $util.ProtocolError("missing required 'consumed'", { instance: message });
                if (!message.hasOwnProperty("rows"))
                    throw $util.ProtocolError("missing required 'rows'", { instance: message });
                return message;
            };

            /**
             * Decodes a GetRangeResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.GetRangeResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.GetRangeResponse} GetRangeResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetRangeResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetRangeResponse message.
             * @function verify
             * @memberof main.proto.GetRangeResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetRangeResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                {
                    var error = $root.main.proto.ConsumedCapacity.verify(message.consumed);
                    if (error)
                        return "consumed." + error;
                }
                if (!(message.rows && typeof message.rows.length === "number" || $util.isString(message.rows)))
                    return "rows: buffer expected";
                if (message.nextStartPrimaryKey != null && message.hasOwnProperty("nextStartPrimaryKey"))
                    if (!(message.nextStartPrimaryKey && typeof message.nextStartPrimaryKey.length === "number" || $util.isString(message.nextStartPrimaryKey)))
                        return "nextStartPrimaryKey: buffer expected";
                if (message.nextToken != null && message.hasOwnProperty("nextToken"))
                    if (!(message.nextToken && typeof message.nextToken.length === "number" || $util.isString(message.nextToken)))
                        return "nextToken: buffer expected";
                if (message.dataBlockType != null && message.hasOwnProperty("dataBlockType"))
                    switch (message.dataBlockType) {
                    default:
                        return "dataBlockType: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.compressType != null && message.hasOwnProperty("compressType"))
                    switch (message.compressType) {
                    default:
                        return "compressType: enum value expected";
                    case 0:
                        break;
                    }
                return null;
            };

            /**
             * Creates a GetRangeResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.GetRangeResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.GetRangeResponse} GetRangeResponse
             */
            GetRangeResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.GetRangeResponse)
                    return object;
                var message = new $root.main.proto.GetRangeResponse();
                if (object.consumed != null) {
                    if (typeof object.consumed !== "object")
                        throw TypeError(".main.proto.GetRangeResponse.consumed: object expected");
                    message.consumed = $root.main.proto.ConsumedCapacity.fromObject(object.consumed);
                }
                if (object.rows != null)
                    if (typeof object.rows === "string")
                        $util.base64.decode(object.rows, message.rows = $util.newBuffer($util.base64.length(object.rows)), 0);
                    else if (object.rows.length)
                        message.rows = object.rows;
                if (object.nextStartPrimaryKey != null)
                    if (typeof object.nextStartPrimaryKey === "string")
                        $util.base64.decode(object.nextStartPrimaryKey, message.nextStartPrimaryKey = $util.newBuffer($util.base64.length(object.nextStartPrimaryKey)), 0);
                    else if (object.nextStartPrimaryKey.length)
                        message.nextStartPrimaryKey = object.nextStartPrimaryKey;
                if (object.nextToken != null)
                    if (typeof object.nextToken === "string")
                        $util.base64.decode(object.nextToken, message.nextToken = $util.newBuffer($util.base64.length(object.nextToken)), 0);
                    else if (object.nextToken.length)
                        message.nextToken = object.nextToken;
                switch (object.dataBlockType) {
                case "DBT_PLAIN_BUFFER":
                case 0:
                    message.dataBlockType = 0;
                    break;
                case "DBT_SIMPLE_ROW_MATRIX":
                case 1:
                    message.dataBlockType = 1;
                    break;
                }
                switch (object.compressType) {
                case "CPT_NONE":
                case 0:
                    message.compressType = 0;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a GetRangeResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.GetRangeResponse
             * @static
             * @param {main.proto.GetRangeResponse} message GetRangeResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetRangeResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.consumed = null;
                    if (options.bytes === String)
                        object.rows = "";
                    else {
                        object.rows = [];
                        if (options.bytes !== Array)
                            object.rows = $util.newBuffer(object.rows);
                    }
                    if (options.bytes === String)
                        object.nextStartPrimaryKey = "";
                    else {
                        object.nextStartPrimaryKey = [];
                        if (options.bytes !== Array)
                            object.nextStartPrimaryKey = $util.newBuffer(object.nextStartPrimaryKey);
                    }
                    if (options.bytes === String)
                        object.nextToken = "";
                    else {
                        object.nextToken = [];
                        if (options.bytes !== Array)
                            object.nextToken = $util.newBuffer(object.nextToken);
                    }
                    object.dataBlockType = options.enums === String ? "DBT_PLAIN_BUFFER" : 0;
                    object.compressType = options.enums === String ? "CPT_NONE" : 0;
                }
                if (message.consumed != null && message.hasOwnProperty("consumed"))
                    object.consumed = $root.main.proto.ConsumedCapacity.toObject(message.consumed, options);
                if (message.rows != null && message.hasOwnProperty("rows"))
                    object.rows = options.bytes === String ? $util.base64.encode(message.rows, 0, message.rows.length) : options.bytes === Array ? Array.prototype.slice.call(message.rows) : message.rows;
                if (message.nextStartPrimaryKey != null && message.hasOwnProperty("nextStartPrimaryKey"))
                    object.nextStartPrimaryKey = options.bytes === String ? $util.base64.encode(message.nextStartPrimaryKey, 0, message.nextStartPrimaryKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.nextStartPrimaryKey) : message.nextStartPrimaryKey;
                if (message.nextToken != null && message.hasOwnProperty("nextToken"))
                    object.nextToken = options.bytes === String ? $util.base64.encode(message.nextToken, 0, message.nextToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.nextToken) : message.nextToken;
                if (message.dataBlockType != null && message.hasOwnProperty("dataBlockType"))
                    object.dataBlockType = options.enums === String ? $root.main.proto.DataBlockType[message.dataBlockType] : message.dataBlockType;
                if (message.compressType != null && message.hasOwnProperty("compressType"))
                    object.compressType = options.enums === String ? $root.main.proto.CompressType[message.compressType] : message.compressType;
                return object;
            };

            /**
             * Converts this GetRangeResponse to JSON.
             * @function toJSON
             * @memberof main.proto.GetRangeResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetRangeResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GetRangeResponse;
        })();

        proto.StartLocalTransactionRequest = (function() {

            /**
             * Properties of a StartLocalTransactionRequest.
             * @memberof main.proto
             * @interface IStartLocalTransactionRequest
             * @property {string} tableName StartLocalTransactionRequest tableName
             * @property {Uint8Array} key StartLocalTransactionRequest key
             */

            /**
             * Constructs a new StartLocalTransactionRequest.
             * @memberof main.proto
             * @classdesc Represents a StartLocalTransactionRequest.
             * @implements IStartLocalTransactionRequest
             * @constructor
             * @param {main.proto.IStartLocalTransactionRequest=} [properties] Properties to set
             */
            function StartLocalTransactionRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StartLocalTransactionRequest tableName.
             * @member {string} tableName
             * @memberof main.proto.StartLocalTransactionRequest
             * @instance
             */
            StartLocalTransactionRequest.prototype.tableName = "";

            /**
             * StartLocalTransactionRequest key.
             * @member {Uint8Array} key
             * @memberof main.proto.StartLocalTransactionRequest
             * @instance
             */
            StartLocalTransactionRequest.prototype.key = $util.newBuffer([]);

            /**
             * Creates a new StartLocalTransactionRequest instance using the specified properties.
             * @function create
             * @memberof main.proto.StartLocalTransactionRequest
             * @static
             * @param {main.proto.IStartLocalTransactionRequest=} [properties] Properties to set
             * @returns {main.proto.StartLocalTransactionRequest} StartLocalTransactionRequest instance
             */
            StartLocalTransactionRequest.create = function create(properties) {
                return new StartLocalTransactionRequest(properties);
            };

            /**
             * Encodes the specified StartLocalTransactionRequest message. Does not implicitly {@link main.proto.StartLocalTransactionRequest.verify|verify} messages.
             * @function encode
             * @memberof main.proto.StartLocalTransactionRequest
             * @static
             * @param {main.proto.IStartLocalTransactionRequest} message StartLocalTransactionRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StartLocalTransactionRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.tableName);
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.key);
                return writer;
            };

            /**
             * Encodes the specified StartLocalTransactionRequest message, length delimited. Does not implicitly {@link main.proto.StartLocalTransactionRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.StartLocalTransactionRequest
             * @static
             * @param {main.proto.IStartLocalTransactionRequest} message StartLocalTransactionRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StartLocalTransactionRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StartLocalTransactionRequest message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.StartLocalTransactionRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.StartLocalTransactionRequest} StartLocalTransactionRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StartLocalTransactionRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.StartLocalTransactionRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tableName = reader.string();
                        break;
                    case 2:
                        message.key = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("tableName"))
                    throw $util.ProtocolError("missing required 'tableName'", { instance: message });
                if (!message.hasOwnProperty("key"))
                    throw $util.ProtocolError("missing required 'key'", { instance: message });
                return message;
            };

            /**
             * Decodes a StartLocalTransactionRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.StartLocalTransactionRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.StartLocalTransactionRequest} StartLocalTransactionRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StartLocalTransactionRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StartLocalTransactionRequest message.
             * @function verify
             * @memberof main.proto.StartLocalTransactionRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StartLocalTransactionRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.tableName))
                    return "tableName: string expected";
                if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                    return "key: buffer expected";
                return null;
            };

            /**
             * Creates a StartLocalTransactionRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.StartLocalTransactionRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.StartLocalTransactionRequest} StartLocalTransactionRequest
             */
            StartLocalTransactionRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.StartLocalTransactionRequest)
                    return object;
                var message = new $root.main.proto.StartLocalTransactionRequest();
                if (object.tableName != null)
                    message.tableName = String(object.tableName);
                if (object.key != null)
                    if (typeof object.key === "string")
                        $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                    else if (object.key.length)
                        message.key = object.key;
                return message;
            };

            /**
             * Creates a plain object from a StartLocalTransactionRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.StartLocalTransactionRequest
             * @static
             * @param {main.proto.StartLocalTransactionRequest} message StartLocalTransactionRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StartLocalTransactionRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.tableName = "";
                    if (options.bytes === String)
                        object.key = "";
                    else {
                        object.key = [];
                        if (options.bytes !== Array)
                            object.key = $util.newBuffer(object.key);
                    }
                }
                if (message.tableName != null && message.hasOwnProperty("tableName"))
                    object.tableName = message.tableName;
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
                return object;
            };

            /**
             * Converts this StartLocalTransactionRequest to JSON.
             * @function toJSON
             * @memberof main.proto.StartLocalTransactionRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StartLocalTransactionRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StartLocalTransactionRequest;
        })();

        proto.StartLocalTransactionResponse = (function() {

            /**
             * Properties of a StartLocalTransactionResponse.
             * @memberof main.proto
             * @interface IStartLocalTransactionResponse
             * @property {string} transactionId StartLocalTransactionResponse transactionId
             */

            /**
             * Constructs a new StartLocalTransactionResponse.
             * @memberof main.proto
             * @classdesc Represents a StartLocalTransactionResponse.
             * @implements IStartLocalTransactionResponse
             * @constructor
             * @param {main.proto.IStartLocalTransactionResponse=} [properties] Properties to set
             */
            function StartLocalTransactionResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StartLocalTransactionResponse transactionId.
             * @member {string} transactionId
             * @memberof main.proto.StartLocalTransactionResponse
             * @instance
             */
            StartLocalTransactionResponse.prototype.transactionId = "";

            /**
             * Creates a new StartLocalTransactionResponse instance using the specified properties.
             * @function create
             * @memberof main.proto.StartLocalTransactionResponse
             * @static
             * @param {main.proto.IStartLocalTransactionResponse=} [properties] Properties to set
             * @returns {main.proto.StartLocalTransactionResponse} StartLocalTransactionResponse instance
             */
            StartLocalTransactionResponse.create = function create(properties) {
                return new StartLocalTransactionResponse(properties);
            };

            /**
             * Encodes the specified StartLocalTransactionResponse message. Does not implicitly {@link main.proto.StartLocalTransactionResponse.verify|verify} messages.
             * @function encode
             * @memberof main.proto.StartLocalTransactionResponse
             * @static
             * @param {main.proto.IStartLocalTransactionResponse} message StartLocalTransactionResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StartLocalTransactionResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.transactionId);
                return writer;
            };

            /**
             * Encodes the specified StartLocalTransactionResponse message, length delimited. Does not implicitly {@link main.proto.StartLocalTransactionResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.StartLocalTransactionResponse
             * @static
             * @param {main.proto.IStartLocalTransactionResponse} message StartLocalTransactionResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StartLocalTransactionResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StartLocalTransactionResponse message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.StartLocalTransactionResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.StartLocalTransactionResponse} StartLocalTransactionResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StartLocalTransactionResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.StartLocalTransactionResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.transactionId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("transactionId"))
                    throw $util.ProtocolError("missing required 'transactionId'", { instance: message });
                return message;
            };

            /**
             * Decodes a StartLocalTransactionResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.StartLocalTransactionResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.StartLocalTransactionResponse} StartLocalTransactionResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StartLocalTransactionResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StartLocalTransactionResponse message.
             * @function verify
             * @memberof main.proto.StartLocalTransactionResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StartLocalTransactionResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.transactionId))
                    return "transactionId: string expected";
                return null;
            };

            /**
             * Creates a StartLocalTransactionResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.StartLocalTransactionResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.StartLocalTransactionResponse} StartLocalTransactionResponse
             */
            StartLocalTransactionResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.StartLocalTransactionResponse)
                    return object;
                var message = new $root.main.proto.StartLocalTransactionResponse();
                if (object.transactionId != null)
                    message.transactionId = String(object.transactionId);
                return message;
            };

            /**
             * Creates a plain object from a StartLocalTransactionResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.StartLocalTransactionResponse
             * @static
             * @param {main.proto.StartLocalTransactionResponse} message StartLocalTransactionResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StartLocalTransactionResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.transactionId = "";
                if (message.transactionId != null && message.hasOwnProperty("transactionId"))
                    object.transactionId = message.transactionId;
                return object;
            };

            /**
             * Converts this StartLocalTransactionResponse to JSON.
             * @function toJSON
             * @memberof main.proto.StartLocalTransactionResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StartLocalTransactionResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StartLocalTransactionResponse;
        })();

        proto.CommitTransactionRequest = (function() {

            /**
             * Properties of a CommitTransactionRequest.
             * @memberof main.proto
             * @interface ICommitTransactionRequest
             * @property {string} transactionId CommitTransactionRequest transactionId
             */

            /**
             * Constructs a new CommitTransactionRequest.
             * @memberof main.proto
             * @classdesc Represents a CommitTransactionRequest.
             * @implements ICommitTransactionRequest
             * @constructor
             * @param {main.proto.ICommitTransactionRequest=} [properties] Properties to set
             */
            function CommitTransactionRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CommitTransactionRequest transactionId.
             * @member {string} transactionId
             * @memberof main.proto.CommitTransactionRequest
             * @instance
             */
            CommitTransactionRequest.prototype.transactionId = "";

            /**
             * Creates a new CommitTransactionRequest instance using the specified properties.
             * @function create
             * @memberof main.proto.CommitTransactionRequest
             * @static
             * @param {main.proto.ICommitTransactionRequest=} [properties] Properties to set
             * @returns {main.proto.CommitTransactionRequest} CommitTransactionRequest instance
             */
            CommitTransactionRequest.create = function create(properties) {
                return new CommitTransactionRequest(properties);
            };

            /**
             * Encodes the specified CommitTransactionRequest message. Does not implicitly {@link main.proto.CommitTransactionRequest.verify|verify} messages.
             * @function encode
             * @memberof main.proto.CommitTransactionRequest
             * @static
             * @param {main.proto.ICommitTransactionRequest} message CommitTransactionRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CommitTransactionRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.transactionId);
                return writer;
            };

            /**
             * Encodes the specified CommitTransactionRequest message, length delimited. Does not implicitly {@link main.proto.CommitTransactionRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.CommitTransactionRequest
             * @static
             * @param {main.proto.ICommitTransactionRequest} message CommitTransactionRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CommitTransactionRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CommitTransactionRequest message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.CommitTransactionRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.CommitTransactionRequest} CommitTransactionRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CommitTransactionRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.CommitTransactionRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.transactionId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("transactionId"))
                    throw $util.ProtocolError("missing required 'transactionId'", { instance: message });
                return message;
            };

            /**
             * Decodes a CommitTransactionRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.CommitTransactionRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.CommitTransactionRequest} CommitTransactionRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CommitTransactionRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CommitTransactionRequest message.
             * @function verify
             * @memberof main.proto.CommitTransactionRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CommitTransactionRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.transactionId))
                    return "transactionId: string expected";
                return null;
            };

            /**
             * Creates a CommitTransactionRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.CommitTransactionRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.CommitTransactionRequest} CommitTransactionRequest
             */
            CommitTransactionRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.CommitTransactionRequest)
                    return object;
                var message = new $root.main.proto.CommitTransactionRequest();
                if (object.transactionId != null)
                    message.transactionId = String(object.transactionId);
                return message;
            };

            /**
             * Creates a plain object from a CommitTransactionRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.CommitTransactionRequest
             * @static
             * @param {main.proto.CommitTransactionRequest} message CommitTransactionRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CommitTransactionRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.transactionId = "";
                if (message.transactionId != null && message.hasOwnProperty("transactionId"))
                    object.transactionId = message.transactionId;
                return object;
            };

            /**
             * Converts this CommitTransactionRequest to JSON.
             * @function toJSON
             * @memberof main.proto.CommitTransactionRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CommitTransactionRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CommitTransactionRequest;
        })();

        proto.CommitTransactionResponse = (function() {

            /**
             * Properties of a CommitTransactionResponse.
             * @memberof main.proto
             * @interface ICommitTransactionResponse
             */

            /**
             * Constructs a new CommitTransactionResponse.
             * @memberof main.proto
             * @classdesc Represents a CommitTransactionResponse.
             * @implements ICommitTransactionResponse
             * @constructor
             * @param {main.proto.ICommitTransactionResponse=} [properties] Properties to set
             */
            function CommitTransactionResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new CommitTransactionResponse instance using the specified properties.
             * @function create
             * @memberof main.proto.CommitTransactionResponse
             * @static
             * @param {main.proto.ICommitTransactionResponse=} [properties] Properties to set
             * @returns {main.proto.CommitTransactionResponse} CommitTransactionResponse instance
             */
            CommitTransactionResponse.create = function create(properties) {
                return new CommitTransactionResponse(properties);
            };

            /**
             * Encodes the specified CommitTransactionResponse message. Does not implicitly {@link main.proto.CommitTransactionResponse.verify|verify} messages.
             * @function encode
             * @memberof main.proto.CommitTransactionResponse
             * @static
             * @param {main.proto.ICommitTransactionResponse} message CommitTransactionResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CommitTransactionResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified CommitTransactionResponse message, length delimited. Does not implicitly {@link main.proto.CommitTransactionResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.CommitTransactionResponse
             * @static
             * @param {main.proto.ICommitTransactionResponse} message CommitTransactionResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CommitTransactionResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CommitTransactionResponse message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.CommitTransactionResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.CommitTransactionResponse} CommitTransactionResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CommitTransactionResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.CommitTransactionResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CommitTransactionResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.CommitTransactionResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.CommitTransactionResponse} CommitTransactionResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CommitTransactionResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CommitTransactionResponse message.
             * @function verify
             * @memberof main.proto.CommitTransactionResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CommitTransactionResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a CommitTransactionResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.CommitTransactionResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.CommitTransactionResponse} CommitTransactionResponse
             */
            CommitTransactionResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.CommitTransactionResponse)
                    return object;
                return new $root.main.proto.CommitTransactionResponse();
            };

            /**
             * Creates a plain object from a CommitTransactionResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.CommitTransactionResponse
             * @static
             * @param {main.proto.CommitTransactionResponse} message CommitTransactionResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CommitTransactionResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this CommitTransactionResponse to JSON.
             * @function toJSON
             * @memberof main.proto.CommitTransactionResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CommitTransactionResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CommitTransactionResponse;
        })();

        proto.AbortTransactionRequest = (function() {

            /**
             * Properties of an AbortTransactionRequest.
             * @memberof main.proto
             * @interface IAbortTransactionRequest
             * @property {string} transactionId AbortTransactionRequest transactionId
             */

            /**
             * Constructs a new AbortTransactionRequest.
             * @memberof main.proto
             * @classdesc Represents an AbortTransactionRequest.
             * @implements IAbortTransactionRequest
             * @constructor
             * @param {main.proto.IAbortTransactionRequest=} [properties] Properties to set
             */
            function AbortTransactionRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AbortTransactionRequest transactionId.
             * @member {string} transactionId
             * @memberof main.proto.AbortTransactionRequest
             * @instance
             */
            AbortTransactionRequest.prototype.transactionId = "";

            /**
             * Creates a new AbortTransactionRequest instance using the specified properties.
             * @function create
             * @memberof main.proto.AbortTransactionRequest
             * @static
             * @param {main.proto.IAbortTransactionRequest=} [properties] Properties to set
             * @returns {main.proto.AbortTransactionRequest} AbortTransactionRequest instance
             */
            AbortTransactionRequest.create = function create(properties) {
                return new AbortTransactionRequest(properties);
            };

            /**
             * Encodes the specified AbortTransactionRequest message. Does not implicitly {@link main.proto.AbortTransactionRequest.verify|verify} messages.
             * @function encode
             * @memberof main.proto.AbortTransactionRequest
             * @static
             * @param {main.proto.IAbortTransactionRequest} message AbortTransactionRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AbortTransactionRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.transactionId);
                return writer;
            };

            /**
             * Encodes the specified AbortTransactionRequest message, length delimited. Does not implicitly {@link main.proto.AbortTransactionRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.AbortTransactionRequest
             * @static
             * @param {main.proto.IAbortTransactionRequest} message AbortTransactionRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AbortTransactionRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AbortTransactionRequest message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.AbortTransactionRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.AbortTransactionRequest} AbortTransactionRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AbortTransactionRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.AbortTransactionRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.transactionId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("transactionId"))
                    throw $util.ProtocolError("missing required 'transactionId'", { instance: message });
                return message;
            };

            /**
             * Decodes an AbortTransactionRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.AbortTransactionRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.AbortTransactionRequest} AbortTransactionRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AbortTransactionRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AbortTransactionRequest message.
             * @function verify
             * @memberof main.proto.AbortTransactionRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AbortTransactionRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.transactionId))
                    return "transactionId: string expected";
                return null;
            };

            /**
             * Creates an AbortTransactionRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.AbortTransactionRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.AbortTransactionRequest} AbortTransactionRequest
             */
            AbortTransactionRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.AbortTransactionRequest)
                    return object;
                var message = new $root.main.proto.AbortTransactionRequest();
                if (object.transactionId != null)
                    message.transactionId = String(object.transactionId);
                return message;
            };

            /**
             * Creates a plain object from an AbortTransactionRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.AbortTransactionRequest
             * @static
             * @param {main.proto.AbortTransactionRequest} message AbortTransactionRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AbortTransactionRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.transactionId = "";
                if (message.transactionId != null && message.hasOwnProperty("transactionId"))
                    object.transactionId = message.transactionId;
                return object;
            };

            /**
             * Converts this AbortTransactionRequest to JSON.
             * @function toJSON
             * @memberof main.proto.AbortTransactionRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AbortTransactionRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AbortTransactionRequest;
        })();

        proto.AbortTransactionResponse = (function() {

            /**
             * Properties of an AbortTransactionResponse.
             * @memberof main.proto
             * @interface IAbortTransactionResponse
             */

            /**
             * Constructs a new AbortTransactionResponse.
             * @memberof main.proto
             * @classdesc Represents an AbortTransactionResponse.
             * @implements IAbortTransactionResponse
             * @constructor
             * @param {main.proto.IAbortTransactionResponse=} [properties] Properties to set
             */
            function AbortTransactionResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new AbortTransactionResponse instance using the specified properties.
             * @function create
             * @memberof main.proto.AbortTransactionResponse
             * @static
             * @param {main.proto.IAbortTransactionResponse=} [properties] Properties to set
             * @returns {main.proto.AbortTransactionResponse} AbortTransactionResponse instance
             */
            AbortTransactionResponse.create = function create(properties) {
                return new AbortTransactionResponse(properties);
            };

            /**
             * Encodes the specified AbortTransactionResponse message. Does not implicitly {@link main.proto.AbortTransactionResponse.verify|verify} messages.
             * @function encode
             * @memberof main.proto.AbortTransactionResponse
             * @static
             * @param {main.proto.IAbortTransactionResponse} message AbortTransactionResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AbortTransactionResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified AbortTransactionResponse message, length delimited. Does not implicitly {@link main.proto.AbortTransactionResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.AbortTransactionResponse
             * @static
             * @param {main.proto.IAbortTransactionResponse} message AbortTransactionResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AbortTransactionResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AbortTransactionResponse message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.AbortTransactionResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.AbortTransactionResponse} AbortTransactionResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AbortTransactionResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.AbortTransactionResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AbortTransactionResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.AbortTransactionResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.AbortTransactionResponse} AbortTransactionResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AbortTransactionResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AbortTransactionResponse message.
             * @function verify
             * @memberof main.proto.AbortTransactionResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AbortTransactionResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an AbortTransactionResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.AbortTransactionResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.AbortTransactionResponse} AbortTransactionResponse
             */
            AbortTransactionResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.AbortTransactionResponse)
                    return object;
                return new $root.main.proto.AbortTransactionResponse();
            };

            /**
             * Creates a plain object from an AbortTransactionResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.AbortTransactionResponse
             * @static
             * @param {main.proto.AbortTransactionResponse} message AbortTransactionResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AbortTransactionResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this AbortTransactionResponse to JSON.
             * @function toJSON
             * @memberof main.proto.AbortTransactionResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AbortTransactionResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AbortTransactionResponse;
        })();

        proto.ListStreamRequest = (function() {

            /**
             * Properties of a ListStreamRequest.
             * @memberof main.proto
             * @interface IListStreamRequest
             * @property {string|null} [tableName] ListStreamRequest tableName
             */

            /**
             * Constructs a new ListStreamRequest.
             * @memberof main.proto
             * @classdesc Represents a ListStreamRequest.
             * @implements IListStreamRequest
             * @constructor
             * @param {main.proto.IListStreamRequest=} [properties] Properties to set
             */
            function ListStreamRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListStreamRequest tableName.
             * @member {string} tableName
             * @memberof main.proto.ListStreamRequest
             * @instance
             */
            ListStreamRequest.prototype.tableName = "";

            /**
             * Creates a new ListStreamRequest instance using the specified properties.
             * @function create
             * @memberof main.proto.ListStreamRequest
             * @static
             * @param {main.proto.IListStreamRequest=} [properties] Properties to set
             * @returns {main.proto.ListStreamRequest} ListStreamRequest instance
             */
            ListStreamRequest.create = function create(properties) {
                return new ListStreamRequest(properties);
            };

            /**
             * Encodes the specified ListStreamRequest message. Does not implicitly {@link main.proto.ListStreamRequest.verify|verify} messages.
             * @function encode
             * @memberof main.proto.ListStreamRequest
             * @static
             * @param {main.proto.IListStreamRequest} message ListStreamRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListStreamRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tableName != null && Object.hasOwnProperty.call(message, "tableName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.tableName);
                return writer;
            };

            /**
             * Encodes the specified ListStreamRequest message, length delimited. Does not implicitly {@link main.proto.ListStreamRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.ListStreamRequest
             * @static
             * @param {main.proto.IListStreamRequest} message ListStreamRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListStreamRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListStreamRequest message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.ListStreamRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.ListStreamRequest} ListStreamRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListStreamRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.ListStreamRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tableName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListStreamRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.ListStreamRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.ListStreamRequest} ListStreamRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListStreamRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListStreamRequest message.
             * @function verify
             * @memberof main.proto.ListStreamRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListStreamRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tableName != null && message.hasOwnProperty("tableName"))
                    if (!$util.isString(message.tableName))
                        return "tableName: string expected";
                return null;
            };

            /**
             * Creates a ListStreamRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.ListStreamRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.ListStreamRequest} ListStreamRequest
             */
            ListStreamRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.ListStreamRequest)
                    return object;
                var message = new $root.main.proto.ListStreamRequest();
                if (object.tableName != null)
                    message.tableName = String(object.tableName);
                return message;
            };

            /**
             * Creates a plain object from a ListStreamRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.ListStreamRequest
             * @static
             * @param {main.proto.ListStreamRequest} message ListStreamRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListStreamRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.tableName = "";
                if (message.tableName != null && message.hasOwnProperty("tableName"))
                    object.tableName = message.tableName;
                return object;
            };

            /**
             * Converts this ListStreamRequest to JSON.
             * @function toJSON
             * @memberof main.proto.ListStreamRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListStreamRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListStreamRequest;
        })();

        proto.Stream = (function() {

            /**
             * Properties of a Stream.
             * @memberof main.proto
             * @interface IStream
             * @property {string} streamId Stream streamId
             * @property {string} tableName Stream tableName
             * @property {number|Long} creationTime Stream creationTime
             */

            /**
             * Constructs a new Stream.
             * @memberof main.proto
             * @classdesc Represents a Stream.
             * @implements IStream
             * @constructor
             * @param {main.proto.IStream=} [properties] Properties to set
             */
            function Stream(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Stream streamId.
             * @member {string} streamId
             * @memberof main.proto.Stream
             * @instance
             */
            Stream.prototype.streamId = "";

            /**
             * Stream tableName.
             * @member {string} tableName
             * @memberof main.proto.Stream
             * @instance
             */
            Stream.prototype.tableName = "";

            /**
             * Stream creationTime.
             * @member {number|Long} creationTime
             * @memberof main.proto.Stream
             * @instance
             */
            Stream.prototype.creationTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new Stream instance using the specified properties.
             * @function create
             * @memberof main.proto.Stream
             * @static
             * @param {main.proto.IStream=} [properties] Properties to set
             * @returns {main.proto.Stream} Stream instance
             */
            Stream.create = function create(properties) {
                return new Stream(properties);
            };

            /**
             * Encodes the specified Stream message. Does not implicitly {@link main.proto.Stream.verify|verify} messages.
             * @function encode
             * @memberof main.proto.Stream
             * @static
             * @param {main.proto.IStream} message Stream message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Stream.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.streamId);
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.tableName);
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.creationTime);
                return writer;
            };

            /**
             * Encodes the specified Stream message, length delimited. Does not implicitly {@link main.proto.Stream.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.Stream
             * @static
             * @param {main.proto.IStream} message Stream message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Stream.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Stream message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.Stream
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.Stream} Stream
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Stream.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.Stream();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.streamId = reader.string();
                        break;
                    case 2:
                        message.tableName = reader.string();
                        break;
                    case 3:
                        message.creationTime = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("streamId"))
                    throw $util.ProtocolError("missing required 'streamId'", { instance: message });
                if (!message.hasOwnProperty("tableName"))
                    throw $util.ProtocolError("missing required 'tableName'", { instance: message });
                if (!message.hasOwnProperty("creationTime"))
                    throw $util.ProtocolError("missing required 'creationTime'", { instance: message });
                return message;
            };

            /**
             * Decodes a Stream message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.Stream
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.Stream} Stream
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Stream.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Stream message.
             * @function verify
             * @memberof main.proto.Stream
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Stream.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.streamId))
                    return "streamId: string expected";
                if (!$util.isString(message.tableName))
                    return "tableName: string expected";
                if (!$util.isInteger(message.creationTime) && !(message.creationTime && $util.isInteger(message.creationTime.low) && $util.isInteger(message.creationTime.high)))
                    return "creationTime: integer|Long expected";
                return null;
            };

            /**
             * Creates a Stream message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.Stream
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.Stream} Stream
             */
            Stream.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.Stream)
                    return object;
                var message = new $root.main.proto.Stream();
                if (object.streamId != null)
                    message.streamId = String(object.streamId);
                if (object.tableName != null)
                    message.tableName = String(object.tableName);
                if (object.creationTime != null)
                    if ($util.Long)
                        (message.creationTime = $util.Long.fromValue(object.creationTime)).unsigned = false;
                    else if (typeof object.creationTime === "string")
                        message.creationTime = parseInt(object.creationTime, 10);
                    else if (typeof object.creationTime === "number")
                        message.creationTime = object.creationTime;
                    else if (typeof object.creationTime === "object")
                        message.creationTime = new $util.LongBits(object.creationTime.low >>> 0, object.creationTime.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a Stream message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.Stream
             * @static
             * @param {main.proto.Stream} message Stream
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Stream.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.streamId = "";
                    object.tableName = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.creationTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.creationTime = options.longs === String ? "0" : 0;
                }
                if (message.streamId != null && message.hasOwnProperty("streamId"))
                    object.streamId = message.streamId;
                if (message.tableName != null && message.hasOwnProperty("tableName"))
                    object.tableName = message.tableName;
                if (message.creationTime != null && message.hasOwnProperty("creationTime"))
                    if (typeof message.creationTime === "number")
                        object.creationTime = options.longs === String ? String(message.creationTime) : message.creationTime;
                    else
                        object.creationTime = options.longs === String ? $util.Long.prototype.toString.call(message.creationTime) : options.longs === Number ? new $util.LongBits(message.creationTime.low >>> 0, message.creationTime.high >>> 0).toNumber() : message.creationTime;
                return object;
            };

            /**
             * Converts this Stream to JSON.
             * @function toJSON
             * @memberof main.proto.Stream
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Stream.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Stream;
        })();

        proto.ListStreamResponse = (function() {

            /**
             * Properties of a ListStreamResponse.
             * @memberof main.proto
             * @interface IListStreamResponse
             * @property {Array.<main.proto.IStream>|null} [streams] ListStreamResponse streams
             */

            /**
             * Constructs a new ListStreamResponse.
             * @memberof main.proto
             * @classdesc Represents a ListStreamResponse.
             * @implements IListStreamResponse
             * @constructor
             * @param {main.proto.IListStreamResponse=} [properties] Properties to set
             */
            function ListStreamResponse(properties) {
                this.streams = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListStreamResponse streams.
             * @member {Array.<main.proto.IStream>} streams
             * @memberof main.proto.ListStreamResponse
             * @instance
             */
            ListStreamResponse.prototype.streams = $util.emptyArray;

            /**
             * Creates a new ListStreamResponse instance using the specified properties.
             * @function create
             * @memberof main.proto.ListStreamResponse
             * @static
             * @param {main.proto.IListStreamResponse=} [properties] Properties to set
             * @returns {main.proto.ListStreamResponse} ListStreamResponse instance
             */
            ListStreamResponse.create = function create(properties) {
                return new ListStreamResponse(properties);
            };

            /**
             * Encodes the specified ListStreamResponse message. Does not implicitly {@link main.proto.ListStreamResponse.verify|verify} messages.
             * @function encode
             * @memberof main.proto.ListStreamResponse
             * @static
             * @param {main.proto.IListStreamResponse} message ListStreamResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListStreamResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.streams != null && message.streams.length)
                    for (var i = 0; i < message.streams.length; ++i)
                        $root.main.proto.Stream.encode(message.streams[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ListStreamResponse message, length delimited. Does not implicitly {@link main.proto.ListStreamResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.ListStreamResponse
             * @static
             * @param {main.proto.IListStreamResponse} message ListStreamResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListStreamResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListStreamResponse message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.ListStreamResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.ListStreamResponse} ListStreamResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListStreamResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.ListStreamResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.streams && message.streams.length))
                            message.streams = [];
                        message.streams.push($root.main.proto.Stream.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListStreamResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.ListStreamResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.ListStreamResponse} ListStreamResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListStreamResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListStreamResponse message.
             * @function verify
             * @memberof main.proto.ListStreamResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListStreamResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.streams != null && message.hasOwnProperty("streams")) {
                    if (!Array.isArray(message.streams))
                        return "streams: array expected";
                    for (var i = 0; i < message.streams.length; ++i) {
                        var error = $root.main.proto.Stream.verify(message.streams[i]);
                        if (error)
                            return "streams." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ListStreamResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.ListStreamResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.ListStreamResponse} ListStreamResponse
             */
            ListStreamResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.ListStreamResponse)
                    return object;
                var message = new $root.main.proto.ListStreamResponse();
                if (object.streams) {
                    if (!Array.isArray(object.streams))
                        throw TypeError(".main.proto.ListStreamResponse.streams: array expected");
                    message.streams = [];
                    for (var i = 0; i < object.streams.length; ++i) {
                        if (typeof object.streams[i] !== "object")
                            throw TypeError(".main.proto.ListStreamResponse.streams: object expected");
                        message.streams[i] = $root.main.proto.Stream.fromObject(object.streams[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a ListStreamResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.ListStreamResponse
             * @static
             * @param {main.proto.ListStreamResponse} message ListStreamResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListStreamResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.streams = [];
                if (message.streams && message.streams.length) {
                    object.streams = [];
                    for (var j = 0; j < message.streams.length; ++j)
                        object.streams[j] = $root.main.proto.Stream.toObject(message.streams[j], options);
                }
                return object;
            };

            /**
             * Converts this ListStreamResponse to JSON.
             * @function toJSON
             * @memberof main.proto.ListStreamResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListStreamResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListStreamResponse;
        })();

        proto.StreamShard = (function() {

            /**
             * Properties of a StreamShard.
             * @memberof main.proto
             * @interface IStreamShard
             * @property {string} shardId StreamShard shardId
             * @property {string|null} [parentId] StreamShard parentId
             * @property {string|null} [parentSiblingId] StreamShard parentSiblingId
             */

            /**
             * Constructs a new StreamShard.
             * @memberof main.proto
             * @classdesc Represents a StreamShard.
             * @implements IStreamShard
             * @constructor
             * @param {main.proto.IStreamShard=} [properties] Properties to set
             */
            function StreamShard(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StreamShard shardId.
             * @member {string} shardId
             * @memberof main.proto.StreamShard
             * @instance
             */
            StreamShard.prototype.shardId = "";

            /**
             * StreamShard parentId.
             * @member {string} parentId
             * @memberof main.proto.StreamShard
             * @instance
             */
            StreamShard.prototype.parentId = "";

            /**
             * StreamShard parentSiblingId.
             * @member {string} parentSiblingId
             * @memberof main.proto.StreamShard
             * @instance
             */
            StreamShard.prototype.parentSiblingId = "";

            /**
             * Creates a new StreamShard instance using the specified properties.
             * @function create
             * @memberof main.proto.StreamShard
             * @static
             * @param {main.proto.IStreamShard=} [properties] Properties to set
             * @returns {main.proto.StreamShard} StreamShard instance
             */
            StreamShard.create = function create(properties) {
                return new StreamShard(properties);
            };

            /**
             * Encodes the specified StreamShard message. Does not implicitly {@link main.proto.StreamShard.verify|verify} messages.
             * @function encode
             * @memberof main.proto.StreamShard
             * @static
             * @param {main.proto.IStreamShard} message StreamShard message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StreamShard.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.shardId);
                if (message.parentId != null && Object.hasOwnProperty.call(message, "parentId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.parentId);
                if (message.parentSiblingId != null && Object.hasOwnProperty.call(message, "parentSiblingId"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.parentSiblingId);
                return writer;
            };

            /**
             * Encodes the specified StreamShard message, length delimited. Does not implicitly {@link main.proto.StreamShard.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.StreamShard
             * @static
             * @param {main.proto.IStreamShard} message StreamShard message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StreamShard.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StreamShard message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.StreamShard
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.StreamShard} StreamShard
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StreamShard.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.StreamShard();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.shardId = reader.string();
                        break;
                    case 2:
                        message.parentId = reader.string();
                        break;
                    case 3:
                        message.parentSiblingId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("shardId"))
                    throw $util.ProtocolError("missing required 'shardId'", { instance: message });
                return message;
            };

            /**
             * Decodes a StreamShard message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.StreamShard
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.StreamShard} StreamShard
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StreamShard.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StreamShard message.
             * @function verify
             * @memberof main.proto.StreamShard
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StreamShard.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.shardId))
                    return "shardId: string expected";
                if (message.parentId != null && message.hasOwnProperty("parentId"))
                    if (!$util.isString(message.parentId))
                        return "parentId: string expected";
                if (message.parentSiblingId != null && message.hasOwnProperty("parentSiblingId"))
                    if (!$util.isString(message.parentSiblingId))
                        return "parentSiblingId: string expected";
                return null;
            };

            /**
             * Creates a StreamShard message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.StreamShard
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.StreamShard} StreamShard
             */
            StreamShard.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.StreamShard)
                    return object;
                var message = new $root.main.proto.StreamShard();
                if (object.shardId != null)
                    message.shardId = String(object.shardId);
                if (object.parentId != null)
                    message.parentId = String(object.parentId);
                if (object.parentSiblingId != null)
                    message.parentSiblingId = String(object.parentSiblingId);
                return message;
            };

            /**
             * Creates a plain object from a StreamShard message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.StreamShard
             * @static
             * @param {main.proto.StreamShard} message StreamShard
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StreamShard.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.shardId = "";
                    object.parentId = "";
                    object.parentSiblingId = "";
                }
                if (message.shardId != null && message.hasOwnProperty("shardId"))
                    object.shardId = message.shardId;
                if (message.parentId != null && message.hasOwnProperty("parentId"))
                    object.parentId = message.parentId;
                if (message.parentSiblingId != null && message.hasOwnProperty("parentSiblingId"))
                    object.parentSiblingId = message.parentSiblingId;
                return object;
            };

            /**
             * Converts this StreamShard to JSON.
             * @function toJSON
             * @memberof main.proto.StreamShard
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StreamShard.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StreamShard;
        })();

        /**
         * StreamStatus enum.
         * @name main.proto.StreamStatus
         * @enum {number}
         * @property {number} STREAM_ENABLING=1 STREAM_ENABLING value
         * @property {number} STREAM_ACTIVE=2 STREAM_ACTIVE value
         */
        proto.StreamStatus = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "STREAM_ENABLING"] = 1;
            values[valuesById[2] = "STREAM_ACTIVE"] = 2;
            return values;
        })();

        proto.DescribeStreamRequest = (function() {

            /**
             * Properties of a DescribeStreamRequest.
             * @memberof main.proto
             * @interface IDescribeStreamRequest
             * @property {string} streamId DescribeStreamRequest streamId
             * @property {string|null} [inclusiveStartShardId] DescribeStreamRequest inclusiveStartShardId
             * @property {number|null} [shardLimit] DescribeStreamRequest shardLimit
             */

            /**
             * Constructs a new DescribeStreamRequest.
             * @memberof main.proto
             * @classdesc Represents a DescribeStreamRequest.
             * @implements IDescribeStreamRequest
             * @constructor
             * @param {main.proto.IDescribeStreamRequest=} [properties] Properties to set
             */
            function DescribeStreamRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DescribeStreamRequest streamId.
             * @member {string} streamId
             * @memberof main.proto.DescribeStreamRequest
             * @instance
             */
            DescribeStreamRequest.prototype.streamId = "";

            /**
             * DescribeStreamRequest inclusiveStartShardId.
             * @member {string} inclusiveStartShardId
             * @memberof main.proto.DescribeStreamRequest
             * @instance
             */
            DescribeStreamRequest.prototype.inclusiveStartShardId = "";

            /**
             * DescribeStreamRequest shardLimit.
             * @member {number} shardLimit
             * @memberof main.proto.DescribeStreamRequest
             * @instance
             */
            DescribeStreamRequest.prototype.shardLimit = 0;

            /**
             * Creates a new DescribeStreamRequest instance using the specified properties.
             * @function create
             * @memberof main.proto.DescribeStreamRequest
             * @static
             * @param {main.proto.IDescribeStreamRequest=} [properties] Properties to set
             * @returns {main.proto.DescribeStreamRequest} DescribeStreamRequest instance
             */
            DescribeStreamRequest.create = function create(properties) {
                return new DescribeStreamRequest(properties);
            };

            /**
             * Encodes the specified DescribeStreamRequest message. Does not implicitly {@link main.proto.DescribeStreamRequest.verify|verify} messages.
             * @function encode
             * @memberof main.proto.DescribeStreamRequest
             * @static
             * @param {main.proto.IDescribeStreamRequest} message DescribeStreamRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeStreamRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.streamId);
                if (message.inclusiveStartShardId != null && Object.hasOwnProperty.call(message, "inclusiveStartShardId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.inclusiveStartShardId);
                if (message.shardLimit != null && Object.hasOwnProperty.call(message, "shardLimit"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.shardLimit);
                return writer;
            };

            /**
             * Encodes the specified DescribeStreamRequest message, length delimited. Does not implicitly {@link main.proto.DescribeStreamRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.DescribeStreamRequest
             * @static
             * @param {main.proto.IDescribeStreamRequest} message DescribeStreamRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeStreamRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DescribeStreamRequest message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.DescribeStreamRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.DescribeStreamRequest} DescribeStreamRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeStreamRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.DescribeStreamRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.streamId = reader.string();
                        break;
                    case 2:
                        message.inclusiveStartShardId = reader.string();
                        break;
                    case 3:
                        message.shardLimit = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("streamId"))
                    throw $util.ProtocolError("missing required 'streamId'", { instance: message });
                return message;
            };

            /**
             * Decodes a DescribeStreamRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.DescribeStreamRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.DescribeStreamRequest} DescribeStreamRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeStreamRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DescribeStreamRequest message.
             * @function verify
             * @memberof main.proto.DescribeStreamRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DescribeStreamRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.streamId))
                    return "streamId: string expected";
                if (message.inclusiveStartShardId != null && message.hasOwnProperty("inclusiveStartShardId"))
                    if (!$util.isString(message.inclusiveStartShardId))
                        return "inclusiveStartShardId: string expected";
                if (message.shardLimit != null && message.hasOwnProperty("shardLimit"))
                    if (!$util.isInteger(message.shardLimit))
                        return "shardLimit: integer expected";
                return null;
            };

            /**
             * Creates a DescribeStreamRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.DescribeStreamRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.DescribeStreamRequest} DescribeStreamRequest
             */
            DescribeStreamRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.DescribeStreamRequest)
                    return object;
                var message = new $root.main.proto.DescribeStreamRequest();
                if (object.streamId != null)
                    message.streamId = String(object.streamId);
                if (object.inclusiveStartShardId != null)
                    message.inclusiveStartShardId = String(object.inclusiveStartShardId);
                if (object.shardLimit != null)
                    message.shardLimit = object.shardLimit | 0;
                return message;
            };

            /**
             * Creates a plain object from a DescribeStreamRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.DescribeStreamRequest
             * @static
             * @param {main.proto.DescribeStreamRequest} message DescribeStreamRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescribeStreamRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.streamId = "";
                    object.inclusiveStartShardId = "";
                    object.shardLimit = 0;
                }
                if (message.streamId != null && message.hasOwnProperty("streamId"))
                    object.streamId = message.streamId;
                if (message.inclusiveStartShardId != null && message.hasOwnProperty("inclusiveStartShardId"))
                    object.inclusiveStartShardId = message.inclusiveStartShardId;
                if (message.shardLimit != null && message.hasOwnProperty("shardLimit"))
                    object.shardLimit = message.shardLimit;
                return object;
            };

            /**
             * Converts this DescribeStreamRequest to JSON.
             * @function toJSON
             * @memberof main.proto.DescribeStreamRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DescribeStreamRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DescribeStreamRequest;
        })();

        proto.DescribeStreamResponse = (function() {

            /**
             * Properties of a DescribeStreamResponse.
             * @memberof main.proto
             * @interface IDescribeStreamResponse
             * @property {string} streamId DescribeStreamResponse streamId
             * @property {number} expirationTime DescribeStreamResponse expirationTime
             * @property {string} tableName DescribeStreamResponse tableName
             * @property {number|Long} creationTime DescribeStreamResponse creationTime
             * @property {main.proto.StreamStatus} streamStatus DescribeStreamResponse streamStatus
             * @property {Array.<main.proto.IStreamShard>|null} [shards] DescribeStreamResponse shards
             * @property {string|null} [nextShardId] DescribeStreamResponse nextShardId
             */

            /**
             * Constructs a new DescribeStreamResponse.
             * @memberof main.proto
             * @classdesc Represents a DescribeStreamResponse.
             * @implements IDescribeStreamResponse
             * @constructor
             * @param {main.proto.IDescribeStreamResponse=} [properties] Properties to set
             */
            function DescribeStreamResponse(properties) {
                this.shards = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DescribeStreamResponse streamId.
             * @member {string} streamId
             * @memberof main.proto.DescribeStreamResponse
             * @instance
             */
            DescribeStreamResponse.prototype.streamId = "";

            /**
             * DescribeStreamResponse expirationTime.
             * @member {number} expirationTime
             * @memberof main.proto.DescribeStreamResponse
             * @instance
             */
            DescribeStreamResponse.prototype.expirationTime = 0;

            /**
             * DescribeStreamResponse tableName.
             * @member {string} tableName
             * @memberof main.proto.DescribeStreamResponse
             * @instance
             */
            DescribeStreamResponse.prototype.tableName = "";

            /**
             * DescribeStreamResponse creationTime.
             * @member {number|Long} creationTime
             * @memberof main.proto.DescribeStreamResponse
             * @instance
             */
            DescribeStreamResponse.prototype.creationTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * DescribeStreamResponse streamStatus.
             * @member {main.proto.StreamStatus} streamStatus
             * @memberof main.proto.DescribeStreamResponse
             * @instance
             */
            DescribeStreamResponse.prototype.streamStatus = 1;

            /**
             * DescribeStreamResponse shards.
             * @member {Array.<main.proto.IStreamShard>} shards
             * @memberof main.proto.DescribeStreamResponse
             * @instance
             */
            DescribeStreamResponse.prototype.shards = $util.emptyArray;

            /**
             * DescribeStreamResponse nextShardId.
             * @member {string} nextShardId
             * @memberof main.proto.DescribeStreamResponse
             * @instance
             */
            DescribeStreamResponse.prototype.nextShardId = "";

            /**
             * Creates a new DescribeStreamResponse instance using the specified properties.
             * @function create
             * @memberof main.proto.DescribeStreamResponse
             * @static
             * @param {main.proto.IDescribeStreamResponse=} [properties] Properties to set
             * @returns {main.proto.DescribeStreamResponse} DescribeStreamResponse instance
             */
            DescribeStreamResponse.create = function create(properties) {
                return new DescribeStreamResponse(properties);
            };

            /**
             * Encodes the specified DescribeStreamResponse message. Does not implicitly {@link main.proto.DescribeStreamResponse.verify|verify} messages.
             * @function encode
             * @memberof main.proto.DescribeStreamResponse
             * @static
             * @param {main.proto.IDescribeStreamResponse} message DescribeStreamResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeStreamResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.streamId);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.expirationTime);
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.tableName);
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.creationTime);
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.streamStatus);
                if (message.shards != null && message.shards.length)
                    for (var i = 0; i < message.shards.length; ++i)
                        $root.main.proto.StreamShard.encode(message.shards[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.nextShardId != null && Object.hasOwnProperty.call(message, "nextShardId"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.nextShardId);
                return writer;
            };

            /**
             * Encodes the specified DescribeStreamResponse message, length delimited. Does not implicitly {@link main.proto.DescribeStreamResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.DescribeStreamResponse
             * @static
             * @param {main.proto.IDescribeStreamResponse} message DescribeStreamResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeStreamResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DescribeStreamResponse message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.DescribeStreamResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.DescribeStreamResponse} DescribeStreamResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeStreamResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.DescribeStreamResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.streamId = reader.string();
                        break;
                    case 2:
                        message.expirationTime = reader.int32();
                        break;
                    case 3:
                        message.tableName = reader.string();
                        break;
                    case 4:
                        message.creationTime = reader.int64();
                        break;
                    case 5:
                        message.streamStatus = reader.int32();
                        break;
                    case 6:
                        if (!(message.shards && message.shards.length))
                            message.shards = [];
                        message.shards.push($root.main.proto.StreamShard.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        message.nextShardId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("streamId"))
                    throw $util.ProtocolError("missing required 'streamId'", { instance: message });
                if (!message.hasOwnProperty("expirationTime"))
                    throw $util.ProtocolError("missing required 'expirationTime'", { instance: message });
                if (!message.hasOwnProperty("tableName"))
                    throw $util.ProtocolError("missing required 'tableName'", { instance: message });
                if (!message.hasOwnProperty("creationTime"))
                    throw $util.ProtocolError("missing required 'creationTime'", { instance: message });
                if (!message.hasOwnProperty("streamStatus"))
                    throw $util.ProtocolError("missing required 'streamStatus'", { instance: message });
                return message;
            };

            /**
             * Decodes a DescribeStreamResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.DescribeStreamResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.DescribeStreamResponse} DescribeStreamResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeStreamResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DescribeStreamResponse message.
             * @function verify
             * @memberof main.proto.DescribeStreamResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DescribeStreamResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.streamId))
                    return "streamId: string expected";
                if (!$util.isInteger(message.expirationTime))
                    return "expirationTime: integer expected";
                if (!$util.isString(message.tableName))
                    return "tableName: string expected";
                if (!$util.isInteger(message.creationTime) && !(message.creationTime && $util.isInteger(message.creationTime.low) && $util.isInteger(message.creationTime.high)))
                    return "creationTime: integer|Long expected";
                switch (message.streamStatus) {
                default:
                    return "streamStatus: enum value expected";
                case 1:
                case 2:
                    break;
                }
                if (message.shards != null && message.hasOwnProperty("shards")) {
                    if (!Array.isArray(message.shards))
                        return "shards: array expected";
                    for (var i = 0; i < message.shards.length; ++i) {
                        var error = $root.main.proto.StreamShard.verify(message.shards[i]);
                        if (error)
                            return "shards." + error;
                    }
                }
                if (message.nextShardId != null && message.hasOwnProperty("nextShardId"))
                    if (!$util.isString(message.nextShardId))
                        return "nextShardId: string expected";
                return null;
            };

            /**
             * Creates a DescribeStreamResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.DescribeStreamResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.DescribeStreamResponse} DescribeStreamResponse
             */
            DescribeStreamResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.DescribeStreamResponse)
                    return object;
                var message = new $root.main.proto.DescribeStreamResponse();
                if (object.streamId != null)
                    message.streamId = String(object.streamId);
                if (object.expirationTime != null)
                    message.expirationTime = object.expirationTime | 0;
                if (object.tableName != null)
                    message.tableName = String(object.tableName);
                if (object.creationTime != null)
                    if ($util.Long)
                        (message.creationTime = $util.Long.fromValue(object.creationTime)).unsigned = false;
                    else if (typeof object.creationTime === "string")
                        message.creationTime = parseInt(object.creationTime, 10);
                    else if (typeof object.creationTime === "number")
                        message.creationTime = object.creationTime;
                    else if (typeof object.creationTime === "object")
                        message.creationTime = new $util.LongBits(object.creationTime.low >>> 0, object.creationTime.high >>> 0).toNumber();
                switch (object.streamStatus) {
                case "STREAM_ENABLING":
                case 1:
                    message.streamStatus = 1;
                    break;
                case "STREAM_ACTIVE":
                case 2:
                    message.streamStatus = 2;
                    break;
                }
                if (object.shards) {
                    if (!Array.isArray(object.shards))
                        throw TypeError(".main.proto.DescribeStreamResponse.shards: array expected");
                    message.shards = [];
                    for (var i = 0; i < object.shards.length; ++i) {
                        if (typeof object.shards[i] !== "object")
                            throw TypeError(".main.proto.DescribeStreamResponse.shards: object expected");
                        message.shards[i] = $root.main.proto.StreamShard.fromObject(object.shards[i]);
                    }
                }
                if (object.nextShardId != null)
                    message.nextShardId = String(object.nextShardId);
                return message;
            };

            /**
             * Creates a plain object from a DescribeStreamResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.DescribeStreamResponse
             * @static
             * @param {main.proto.DescribeStreamResponse} message DescribeStreamResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescribeStreamResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.shards = [];
                if (options.defaults) {
                    object.streamId = "";
                    object.expirationTime = 0;
                    object.tableName = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.creationTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.creationTime = options.longs === String ? "0" : 0;
                    object.streamStatus = options.enums === String ? "STREAM_ENABLING" : 1;
                    object.nextShardId = "";
                }
                if (message.streamId != null && message.hasOwnProperty("streamId"))
                    object.streamId = message.streamId;
                if (message.expirationTime != null && message.hasOwnProperty("expirationTime"))
                    object.expirationTime = message.expirationTime;
                if (message.tableName != null && message.hasOwnProperty("tableName"))
                    object.tableName = message.tableName;
                if (message.creationTime != null && message.hasOwnProperty("creationTime"))
                    if (typeof message.creationTime === "number")
                        object.creationTime = options.longs === String ? String(message.creationTime) : message.creationTime;
                    else
                        object.creationTime = options.longs === String ? $util.Long.prototype.toString.call(message.creationTime) : options.longs === Number ? new $util.LongBits(message.creationTime.low >>> 0, message.creationTime.high >>> 0).toNumber() : message.creationTime;
                if (message.streamStatus != null && message.hasOwnProperty("streamStatus"))
                    object.streamStatus = options.enums === String ? $root.main.proto.StreamStatus[message.streamStatus] : message.streamStatus;
                if (message.shards && message.shards.length) {
                    object.shards = [];
                    for (var j = 0; j < message.shards.length; ++j)
                        object.shards[j] = $root.main.proto.StreamShard.toObject(message.shards[j], options);
                }
                if (message.nextShardId != null && message.hasOwnProperty("nextShardId"))
                    object.nextShardId = message.nextShardId;
                return object;
            };

            /**
             * Converts this DescribeStreamResponse to JSON.
             * @function toJSON
             * @memberof main.proto.DescribeStreamResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DescribeStreamResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DescribeStreamResponse;
        })();

        proto.GetShardIteratorRequest = (function() {

            /**
             * Properties of a GetShardIteratorRequest.
             * @memberof main.proto
             * @interface IGetShardIteratorRequest
             * @property {string} streamId GetShardIteratorRequest streamId
             * @property {string} shardId GetShardIteratorRequest shardId
             */

            /**
             * Constructs a new GetShardIteratorRequest.
             * @memberof main.proto
             * @classdesc Represents a GetShardIteratorRequest.
             * @implements IGetShardIteratorRequest
             * @constructor
             * @param {main.proto.IGetShardIteratorRequest=} [properties] Properties to set
             */
            function GetShardIteratorRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetShardIteratorRequest streamId.
             * @member {string} streamId
             * @memberof main.proto.GetShardIteratorRequest
             * @instance
             */
            GetShardIteratorRequest.prototype.streamId = "";

            /**
             * GetShardIteratorRequest shardId.
             * @member {string} shardId
             * @memberof main.proto.GetShardIteratorRequest
             * @instance
             */
            GetShardIteratorRequest.prototype.shardId = "";

            /**
             * Creates a new GetShardIteratorRequest instance using the specified properties.
             * @function create
             * @memberof main.proto.GetShardIteratorRequest
             * @static
             * @param {main.proto.IGetShardIteratorRequest=} [properties] Properties to set
             * @returns {main.proto.GetShardIteratorRequest} GetShardIteratorRequest instance
             */
            GetShardIteratorRequest.create = function create(properties) {
                return new GetShardIteratorRequest(properties);
            };

            /**
             * Encodes the specified GetShardIteratorRequest message. Does not implicitly {@link main.proto.GetShardIteratorRequest.verify|verify} messages.
             * @function encode
             * @memberof main.proto.GetShardIteratorRequest
             * @static
             * @param {main.proto.IGetShardIteratorRequest} message GetShardIteratorRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetShardIteratorRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.streamId);
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.shardId);
                return writer;
            };

            /**
             * Encodes the specified GetShardIteratorRequest message, length delimited. Does not implicitly {@link main.proto.GetShardIteratorRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.GetShardIteratorRequest
             * @static
             * @param {main.proto.IGetShardIteratorRequest} message GetShardIteratorRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetShardIteratorRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetShardIteratorRequest message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.GetShardIteratorRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.GetShardIteratorRequest} GetShardIteratorRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetShardIteratorRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.GetShardIteratorRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.streamId = reader.string();
                        break;
                    case 2:
                        message.shardId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("streamId"))
                    throw $util.ProtocolError("missing required 'streamId'", { instance: message });
                if (!message.hasOwnProperty("shardId"))
                    throw $util.ProtocolError("missing required 'shardId'", { instance: message });
                return message;
            };

            /**
             * Decodes a GetShardIteratorRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.GetShardIteratorRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.GetShardIteratorRequest} GetShardIteratorRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetShardIteratorRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetShardIteratorRequest message.
             * @function verify
             * @memberof main.proto.GetShardIteratorRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetShardIteratorRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.streamId))
                    return "streamId: string expected";
                if (!$util.isString(message.shardId))
                    return "shardId: string expected";
                return null;
            };

            /**
             * Creates a GetShardIteratorRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.GetShardIteratorRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.GetShardIteratorRequest} GetShardIteratorRequest
             */
            GetShardIteratorRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.GetShardIteratorRequest)
                    return object;
                var message = new $root.main.proto.GetShardIteratorRequest();
                if (object.streamId != null)
                    message.streamId = String(object.streamId);
                if (object.shardId != null)
                    message.shardId = String(object.shardId);
                return message;
            };

            /**
             * Creates a plain object from a GetShardIteratorRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.GetShardIteratorRequest
             * @static
             * @param {main.proto.GetShardIteratorRequest} message GetShardIteratorRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetShardIteratorRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.streamId = "";
                    object.shardId = "";
                }
                if (message.streamId != null && message.hasOwnProperty("streamId"))
                    object.streamId = message.streamId;
                if (message.shardId != null && message.hasOwnProperty("shardId"))
                    object.shardId = message.shardId;
                return object;
            };

            /**
             * Converts this GetShardIteratorRequest to JSON.
             * @function toJSON
             * @memberof main.proto.GetShardIteratorRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetShardIteratorRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GetShardIteratorRequest;
        })();

        proto.GetShardIteratorResponse = (function() {

            /**
             * Properties of a GetShardIteratorResponse.
             * @memberof main.proto
             * @interface IGetShardIteratorResponse
             * @property {string} shardIterator GetShardIteratorResponse shardIterator
             */

            /**
             * Constructs a new GetShardIteratorResponse.
             * @memberof main.proto
             * @classdesc Represents a GetShardIteratorResponse.
             * @implements IGetShardIteratorResponse
             * @constructor
             * @param {main.proto.IGetShardIteratorResponse=} [properties] Properties to set
             */
            function GetShardIteratorResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetShardIteratorResponse shardIterator.
             * @member {string} shardIterator
             * @memberof main.proto.GetShardIteratorResponse
             * @instance
             */
            GetShardIteratorResponse.prototype.shardIterator = "";

            /**
             * Creates a new GetShardIteratorResponse instance using the specified properties.
             * @function create
             * @memberof main.proto.GetShardIteratorResponse
             * @static
             * @param {main.proto.IGetShardIteratorResponse=} [properties] Properties to set
             * @returns {main.proto.GetShardIteratorResponse} GetShardIteratorResponse instance
             */
            GetShardIteratorResponse.create = function create(properties) {
                return new GetShardIteratorResponse(properties);
            };

            /**
             * Encodes the specified GetShardIteratorResponse message. Does not implicitly {@link main.proto.GetShardIteratorResponse.verify|verify} messages.
             * @function encode
             * @memberof main.proto.GetShardIteratorResponse
             * @static
             * @param {main.proto.IGetShardIteratorResponse} message GetShardIteratorResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetShardIteratorResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.shardIterator);
                return writer;
            };

            /**
             * Encodes the specified GetShardIteratorResponse message, length delimited. Does not implicitly {@link main.proto.GetShardIteratorResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.GetShardIteratorResponse
             * @static
             * @param {main.proto.IGetShardIteratorResponse} message GetShardIteratorResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetShardIteratorResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetShardIteratorResponse message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.GetShardIteratorResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.GetShardIteratorResponse} GetShardIteratorResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetShardIteratorResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.GetShardIteratorResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.shardIterator = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("shardIterator"))
                    throw $util.ProtocolError("missing required 'shardIterator'", { instance: message });
                return message;
            };

            /**
             * Decodes a GetShardIteratorResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.GetShardIteratorResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.GetShardIteratorResponse} GetShardIteratorResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetShardIteratorResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetShardIteratorResponse message.
             * @function verify
             * @memberof main.proto.GetShardIteratorResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetShardIteratorResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.shardIterator))
                    return "shardIterator: string expected";
                return null;
            };

            /**
             * Creates a GetShardIteratorResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.GetShardIteratorResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.GetShardIteratorResponse} GetShardIteratorResponse
             */
            GetShardIteratorResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.GetShardIteratorResponse)
                    return object;
                var message = new $root.main.proto.GetShardIteratorResponse();
                if (object.shardIterator != null)
                    message.shardIterator = String(object.shardIterator);
                return message;
            };

            /**
             * Creates a plain object from a GetShardIteratorResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.GetShardIteratorResponse
             * @static
             * @param {main.proto.GetShardIteratorResponse} message GetShardIteratorResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetShardIteratorResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.shardIterator = "";
                if (message.shardIterator != null && message.hasOwnProperty("shardIterator"))
                    object.shardIterator = message.shardIterator;
                return object;
            };

            /**
             * Converts this GetShardIteratorResponse to JSON.
             * @function toJSON
             * @memberof main.proto.GetShardIteratorResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetShardIteratorResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GetShardIteratorResponse;
        })();

        proto.GetStreamRecordRequest = (function() {

            /**
             * Properties of a GetStreamRecordRequest.
             * @memberof main.proto
             * @interface IGetStreamRecordRequest
             * @property {string} shardIterator GetStreamRecordRequest shardIterator
             * @property {number|null} [limit] GetStreamRecordRequest limit
             */

            /**
             * Constructs a new GetStreamRecordRequest.
             * @memberof main.proto
             * @classdesc Represents a GetStreamRecordRequest.
             * @implements IGetStreamRecordRequest
             * @constructor
             * @param {main.proto.IGetStreamRecordRequest=} [properties] Properties to set
             */
            function GetStreamRecordRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetStreamRecordRequest shardIterator.
             * @member {string} shardIterator
             * @memberof main.proto.GetStreamRecordRequest
             * @instance
             */
            GetStreamRecordRequest.prototype.shardIterator = "";

            /**
             * GetStreamRecordRequest limit.
             * @member {number} limit
             * @memberof main.proto.GetStreamRecordRequest
             * @instance
             */
            GetStreamRecordRequest.prototype.limit = 0;

            /**
             * Creates a new GetStreamRecordRequest instance using the specified properties.
             * @function create
             * @memberof main.proto.GetStreamRecordRequest
             * @static
             * @param {main.proto.IGetStreamRecordRequest=} [properties] Properties to set
             * @returns {main.proto.GetStreamRecordRequest} GetStreamRecordRequest instance
             */
            GetStreamRecordRequest.create = function create(properties) {
                return new GetStreamRecordRequest(properties);
            };

            /**
             * Encodes the specified GetStreamRecordRequest message. Does not implicitly {@link main.proto.GetStreamRecordRequest.verify|verify} messages.
             * @function encode
             * @memberof main.proto.GetStreamRecordRequest
             * @static
             * @param {main.proto.IGetStreamRecordRequest} message GetStreamRecordRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetStreamRecordRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.shardIterator);
                if (message.limit != null && Object.hasOwnProperty.call(message, "limit"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.limit);
                return writer;
            };

            /**
             * Encodes the specified GetStreamRecordRequest message, length delimited. Does not implicitly {@link main.proto.GetStreamRecordRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.GetStreamRecordRequest
             * @static
             * @param {main.proto.IGetStreamRecordRequest} message GetStreamRecordRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetStreamRecordRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetStreamRecordRequest message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.GetStreamRecordRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.GetStreamRecordRequest} GetStreamRecordRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetStreamRecordRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.GetStreamRecordRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.shardIterator = reader.string();
                        break;
                    case 2:
                        message.limit = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("shardIterator"))
                    throw $util.ProtocolError("missing required 'shardIterator'", { instance: message });
                return message;
            };

            /**
             * Decodes a GetStreamRecordRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.GetStreamRecordRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.GetStreamRecordRequest} GetStreamRecordRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetStreamRecordRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetStreamRecordRequest message.
             * @function verify
             * @memberof main.proto.GetStreamRecordRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetStreamRecordRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.shardIterator))
                    return "shardIterator: string expected";
                if (message.limit != null && message.hasOwnProperty("limit"))
                    if (!$util.isInteger(message.limit))
                        return "limit: integer expected";
                return null;
            };

            /**
             * Creates a GetStreamRecordRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.GetStreamRecordRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.GetStreamRecordRequest} GetStreamRecordRequest
             */
            GetStreamRecordRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.GetStreamRecordRequest)
                    return object;
                var message = new $root.main.proto.GetStreamRecordRequest();
                if (object.shardIterator != null)
                    message.shardIterator = String(object.shardIterator);
                if (object.limit != null)
                    message.limit = object.limit | 0;
                return message;
            };

            /**
             * Creates a plain object from a GetStreamRecordRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.GetStreamRecordRequest
             * @static
             * @param {main.proto.GetStreamRecordRequest} message GetStreamRecordRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetStreamRecordRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.shardIterator = "";
                    object.limit = 0;
                }
                if (message.shardIterator != null && message.hasOwnProperty("shardIterator"))
                    object.shardIterator = message.shardIterator;
                if (message.limit != null && message.hasOwnProperty("limit"))
                    object.limit = message.limit;
                return object;
            };

            /**
             * Converts this GetStreamRecordRequest to JSON.
             * @function toJSON
             * @memberof main.proto.GetStreamRecordRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetStreamRecordRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GetStreamRecordRequest;
        })();

        /**
         * ActionType enum.
         * @name main.proto.ActionType
         * @enum {number}
         * @property {number} PUT_ROW=1 PUT_ROW value
         * @property {number} UPDATE_ROW=2 UPDATE_ROW value
         * @property {number} DELETE_ROW=3 DELETE_ROW value
         */
        proto.ActionType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "PUT_ROW"] = 1;
            values[valuesById[2] = "UPDATE_ROW"] = 2;
            values[valuesById[3] = "DELETE_ROW"] = 3;
            return values;
        })();

        proto.GetStreamRecordResponse = (function() {

            /**
             * Properties of a GetStreamRecordResponse.
             * @memberof main.proto
             * @interface IGetStreamRecordResponse
             * @property {Array.<main.proto.GetStreamRecordResponse.IStreamRecord>|null} [streamRecords] GetStreamRecordResponse streamRecords
             * @property {string|null} [nextShardIterator] GetStreamRecordResponse nextShardIterator
             */

            /**
             * Constructs a new GetStreamRecordResponse.
             * @memberof main.proto
             * @classdesc Represents a GetStreamRecordResponse.
             * @implements IGetStreamRecordResponse
             * @constructor
             * @param {main.proto.IGetStreamRecordResponse=} [properties] Properties to set
             */
            function GetStreamRecordResponse(properties) {
                this.streamRecords = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetStreamRecordResponse streamRecords.
             * @member {Array.<main.proto.GetStreamRecordResponse.IStreamRecord>} streamRecords
             * @memberof main.proto.GetStreamRecordResponse
             * @instance
             */
            GetStreamRecordResponse.prototype.streamRecords = $util.emptyArray;

            /**
             * GetStreamRecordResponse nextShardIterator.
             * @member {string} nextShardIterator
             * @memberof main.proto.GetStreamRecordResponse
             * @instance
             */
            GetStreamRecordResponse.prototype.nextShardIterator = "";

            /**
             * Creates a new GetStreamRecordResponse instance using the specified properties.
             * @function create
             * @memberof main.proto.GetStreamRecordResponse
             * @static
             * @param {main.proto.IGetStreamRecordResponse=} [properties] Properties to set
             * @returns {main.proto.GetStreamRecordResponse} GetStreamRecordResponse instance
             */
            GetStreamRecordResponse.create = function create(properties) {
                return new GetStreamRecordResponse(properties);
            };

            /**
             * Encodes the specified GetStreamRecordResponse message. Does not implicitly {@link main.proto.GetStreamRecordResponse.verify|verify} messages.
             * @function encode
             * @memberof main.proto.GetStreamRecordResponse
             * @static
             * @param {main.proto.IGetStreamRecordResponse} message GetStreamRecordResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetStreamRecordResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.streamRecords != null && message.streamRecords.length)
                    for (var i = 0; i < message.streamRecords.length; ++i)
                        $root.main.proto.GetStreamRecordResponse.StreamRecord.encode(message.streamRecords[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.nextShardIterator != null && Object.hasOwnProperty.call(message, "nextShardIterator"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.nextShardIterator);
                return writer;
            };

            /**
             * Encodes the specified GetStreamRecordResponse message, length delimited. Does not implicitly {@link main.proto.GetStreamRecordResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.GetStreamRecordResponse
             * @static
             * @param {main.proto.IGetStreamRecordResponse} message GetStreamRecordResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetStreamRecordResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetStreamRecordResponse message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.GetStreamRecordResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.GetStreamRecordResponse} GetStreamRecordResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetStreamRecordResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.GetStreamRecordResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.streamRecords && message.streamRecords.length))
                            message.streamRecords = [];
                        message.streamRecords.push($root.main.proto.GetStreamRecordResponse.StreamRecord.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.nextShardIterator = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetStreamRecordResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.GetStreamRecordResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.GetStreamRecordResponse} GetStreamRecordResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetStreamRecordResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetStreamRecordResponse message.
             * @function verify
             * @memberof main.proto.GetStreamRecordResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetStreamRecordResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.streamRecords != null && message.hasOwnProperty("streamRecords")) {
                    if (!Array.isArray(message.streamRecords))
                        return "streamRecords: array expected";
                    for (var i = 0; i < message.streamRecords.length; ++i) {
                        var error = $root.main.proto.GetStreamRecordResponse.StreamRecord.verify(message.streamRecords[i]);
                        if (error)
                            return "streamRecords." + error;
                    }
                }
                if (message.nextShardIterator != null && message.hasOwnProperty("nextShardIterator"))
                    if (!$util.isString(message.nextShardIterator))
                        return "nextShardIterator: string expected";
                return null;
            };

            /**
             * Creates a GetStreamRecordResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.GetStreamRecordResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.GetStreamRecordResponse} GetStreamRecordResponse
             */
            GetStreamRecordResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.GetStreamRecordResponse)
                    return object;
                var message = new $root.main.proto.GetStreamRecordResponse();
                if (object.streamRecords) {
                    if (!Array.isArray(object.streamRecords))
                        throw TypeError(".main.proto.GetStreamRecordResponse.streamRecords: array expected");
                    message.streamRecords = [];
                    for (var i = 0; i < object.streamRecords.length; ++i) {
                        if (typeof object.streamRecords[i] !== "object")
                            throw TypeError(".main.proto.GetStreamRecordResponse.streamRecords: object expected");
                        message.streamRecords[i] = $root.main.proto.GetStreamRecordResponse.StreamRecord.fromObject(object.streamRecords[i]);
                    }
                }
                if (object.nextShardIterator != null)
                    message.nextShardIterator = String(object.nextShardIterator);
                return message;
            };

            /**
             * Creates a plain object from a GetStreamRecordResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.GetStreamRecordResponse
             * @static
             * @param {main.proto.GetStreamRecordResponse} message GetStreamRecordResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetStreamRecordResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.streamRecords = [];
                if (options.defaults)
                    object.nextShardIterator = "";
                if (message.streamRecords && message.streamRecords.length) {
                    object.streamRecords = [];
                    for (var j = 0; j < message.streamRecords.length; ++j)
                        object.streamRecords[j] = $root.main.proto.GetStreamRecordResponse.StreamRecord.toObject(message.streamRecords[j], options);
                }
                if (message.nextShardIterator != null && message.hasOwnProperty("nextShardIterator"))
                    object.nextShardIterator = message.nextShardIterator;
                return object;
            };

            /**
             * Converts this GetStreamRecordResponse to JSON.
             * @function toJSON
             * @memberof main.proto.GetStreamRecordResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetStreamRecordResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            GetStreamRecordResponse.StreamRecord = (function() {

                /**
                 * Properties of a StreamRecord.
                 * @memberof main.proto.GetStreamRecordResponse
                 * @interface IStreamRecord
                 * @property {main.proto.ActionType} actionType StreamRecord actionType
                 * @property {Uint8Array} record StreamRecord record
                 */

                /**
                 * Constructs a new StreamRecord.
                 * @memberof main.proto.GetStreamRecordResponse
                 * @classdesc Represents a StreamRecord.
                 * @implements IStreamRecord
                 * @constructor
                 * @param {main.proto.GetStreamRecordResponse.IStreamRecord=} [properties] Properties to set
                 */
                function StreamRecord(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * StreamRecord actionType.
                 * @member {main.proto.ActionType} actionType
                 * @memberof main.proto.GetStreamRecordResponse.StreamRecord
                 * @instance
                 */
                StreamRecord.prototype.actionType = 1;

                /**
                 * StreamRecord record.
                 * @member {Uint8Array} record
                 * @memberof main.proto.GetStreamRecordResponse.StreamRecord
                 * @instance
                 */
                StreamRecord.prototype.record = $util.newBuffer([]);

                /**
                 * Creates a new StreamRecord instance using the specified properties.
                 * @function create
                 * @memberof main.proto.GetStreamRecordResponse.StreamRecord
                 * @static
                 * @param {main.proto.GetStreamRecordResponse.IStreamRecord=} [properties] Properties to set
                 * @returns {main.proto.GetStreamRecordResponse.StreamRecord} StreamRecord instance
                 */
                StreamRecord.create = function create(properties) {
                    return new StreamRecord(properties);
                };

                /**
                 * Encodes the specified StreamRecord message. Does not implicitly {@link main.proto.GetStreamRecordResponse.StreamRecord.verify|verify} messages.
                 * @function encode
                 * @memberof main.proto.GetStreamRecordResponse.StreamRecord
                 * @static
                 * @param {main.proto.GetStreamRecordResponse.IStreamRecord} message StreamRecord message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StreamRecord.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.actionType);
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.record);
                    return writer;
                };

                /**
                 * Encodes the specified StreamRecord message, length delimited. Does not implicitly {@link main.proto.GetStreamRecordResponse.StreamRecord.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof main.proto.GetStreamRecordResponse.StreamRecord
                 * @static
                 * @param {main.proto.GetStreamRecordResponse.IStreamRecord} message StreamRecord message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StreamRecord.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a StreamRecord message from the specified reader or buffer.
                 * @function decode
                 * @memberof main.proto.GetStreamRecordResponse.StreamRecord
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {main.proto.GetStreamRecordResponse.StreamRecord} StreamRecord
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StreamRecord.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.GetStreamRecordResponse.StreamRecord();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.actionType = reader.int32();
                            break;
                        case 2:
                            message.record = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("actionType"))
                        throw $util.ProtocolError("missing required 'actionType'", { instance: message });
                    if (!message.hasOwnProperty("record"))
                        throw $util.ProtocolError("missing required 'record'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a StreamRecord message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof main.proto.GetStreamRecordResponse.StreamRecord
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {main.proto.GetStreamRecordResponse.StreamRecord} StreamRecord
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StreamRecord.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a StreamRecord message.
                 * @function verify
                 * @memberof main.proto.GetStreamRecordResponse.StreamRecord
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                StreamRecord.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    switch (message.actionType) {
                    default:
                        return "actionType: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                    if (!(message.record && typeof message.record.length === "number" || $util.isString(message.record)))
                        return "record: buffer expected";
                    return null;
                };

                /**
                 * Creates a StreamRecord message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof main.proto.GetStreamRecordResponse.StreamRecord
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {main.proto.GetStreamRecordResponse.StreamRecord} StreamRecord
                 */
                StreamRecord.fromObject = function fromObject(object) {
                    if (object instanceof $root.main.proto.GetStreamRecordResponse.StreamRecord)
                        return object;
                    var message = new $root.main.proto.GetStreamRecordResponse.StreamRecord();
                    switch (object.actionType) {
                    case "PUT_ROW":
                    case 1:
                        message.actionType = 1;
                        break;
                    case "UPDATE_ROW":
                    case 2:
                        message.actionType = 2;
                        break;
                    case "DELETE_ROW":
                    case 3:
                        message.actionType = 3;
                        break;
                    }
                    if (object.record != null)
                        if (typeof object.record === "string")
                            $util.base64.decode(object.record, message.record = $util.newBuffer($util.base64.length(object.record)), 0);
                        else if (object.record.length)
                            message.record = object.record;
                    return message;
                };

                /**
                 * Creates a plain object from a StreamRecord message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof main.proto.GetStreamRecordResponse.StreamRecord
                 * @static
                 * @param {main.proto.GetStreamRecordResponse.StreamRecord} message StreamRecord
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                StreamRecord.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.actionType = options.enums === String ? "PUT_ROW" : 1;
                        if (options.bytes === String)
                            object.record = "";
                        else {
                            object.record = [];
                            if (options.bytes !== Array)
                                object.record = $util.newBuffer(object.record);
                        }
                    }
                    if (message.actionType != null && message.hasOwnProperty("actionType"))
                        object.actionType = options.enums === String ? $root.main.proto.ActionType[message.actionType] : message.actionType;
                    if (message.record != null && message.hasOwnProperty("record"))
                        object.record = options.bytes === String ? $util.base64.encode(message.record, 0, message.record.length) : options.bytes === Array ? Array.prototype.slice.call(message.record) : message.record;
                    return object;
                };

                /**
                 * Converts this StreamRecord to JSON.
                 * @function toJSON
                 * @memberof main.proto.GetStreamRecordResponse.StreamRecord
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                StreamRecord.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return StreamRecord;
            })();

            return GetStreamRecordResponse;
        })();

        proto.ComputeSplitPointsBySizeRequest = (function() {

            /**
             * Properties of a ComputeSplitPointsBySizeRequest.
             * @memberof main.proto
             * @interface IComputeSplitPointsBySizeRequest
             * @property {string} tableName ComputeSplitPointsBySizeRequest tableName
             * @property {number|Long} splitSize ComputeSplitPointsBySizeRequest splitSize
             * @property {number|Long|null} [splitSizeUnitInByte] ComputeSplitPointsBySizeRequest splitSizeUnitInByte
             */

            /**
             * Constructs a new ComputeSplitPointsBySizeRequest.
             * @memberof main.proto
             * @classdesc Represents a ComputeSplitPointsBySizeRequest.
             * @implements IComputeSplitPointsBySizeRequest
             * @constructor
             * @param {main.proto.IComputeSplitPointsBySizeRequest=} [properties] Properties to set
             */
            function ComputeSplitPointsBySizeRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ComputeSplitPointsBySizeRequest tableName.
             * @member {string} tableName
             * @memberof main.proto.ComputeSplitPointsBySizeRequest
             * @instance
             */
            ComputeSplitPointsBySizeRequest.prototype.tableName = "";

            /**
             * ComputeSplitPointsBySizeRequest splitSize.
             * @member {number|Long} splitSize
             * @memberof main.proto.ComputeSplitPointsBySizeRequest
             * @instance
             */
            ComputeSplitPointsBySizeRequest.prototype.splitSize = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * ComputeSplitPointsBySizeRequest splitSizeUnitInByte.
             * @member {number|Long} splitSizeUnitInByte
             * @memberof main.proto.ComputeSplitPointsBySizeRequest
             * @instance
             */
            ComputeSplitPointsBySizeRequest.prototype.splitSizeUnitInByte = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new ComputeSplitPointsBySizeRequest instance using the specified properties.
             * @function create
             * @memberof main.proto.ComputeSplitPointsBySizeRequest
             * @static
             * @param {main.proto.IComputeSplitPointsBySizeRequest=} [properties] Properties to set
             * @returns {main.proto.ComputeSplitPointsBySizeRequest} ComputeSplitPointsBySizeRequest instance
             */
            ComputeSplitPointsBySizeRequest.create = function create(properties) {
                return new ComputeSplitPointsBySizeRequest(properties);
            };

            /**
             * Encodes the specified ComputeSplitPointsBySizeRequest message. Does not implicitly {@link main.proto.ComputeSplitPointsBySizeRequest.verify|verify} messages.
             * @function encode
             * @memberof main.proto.ComputeSplitPointsBySizeRequest
             * @static
             * @param {main.proto.IComputeSplitPointsBySizeRequest} message ComputeSplitPointsBySizeRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ComputeSplitPointsBySizeRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.tableName);
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.splitSize);
                if (message.splitSizeUnitInByte != null && Object.hasOwnProperty.call(message, "splitSizeUnitInByte"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.splitSizeUnitInByte);
                return writer;
            };

            /**
             * Encodes the specified ComputeSplitPointsBySizeRequest message, length delimited. Does not implicitly {@link main.proto.ComputeSplitPointsBySizeRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.ComputeSplitPointsBySizeRequest
             * @static
             * @param {main.proto.IComputeSplitPointsBySizeRequest} message ComputeSplitPointsBySizeRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ComputeSplitPointsBySizeRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ComputeSplitPointsBySizeRequest message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.ComputeSplitPointsBySizeRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.ComputeSplitPointsBySizeRequest} ComputeSplitPointsBySizeRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ComputeSplitPointsBySizeRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.ComputeSplitPointsBySizeRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tableName = reader.string();
                        break;
                    case 2:
                        message.splitSize = reader.int64();
                        break;
                    case 3:
                        message.splitSizeUnitInByte = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("tableName"))
                    throw $util.ProtocolError("missing required 'tableName'", { instance: message });
                if (!message.hasOwnProperty("splitSize"))
                    throw $util.ProtocolError("missing required 'splitSize'", { instance: message });
                return message;
            };

            /**
             * Decodes a ComputeSplitPointsBySizeRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.ComputeSplitPointsBySizeRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.ComputeSplitPointsBySizeRequest} ComputeSplitPointsBySizeRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ComputeSplitPointsBySizeRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ComputeSplitPointsBySizeRequest message.
             * @function verify
             * @memberof main.proto.ComputeSplitPointsBySizeRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ComputeSplitPointsBySizeRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.tableName))
                    return "tableName: string expected";
                if (!$util.isInteger(message.splitSize) && !(message.splitSize && $util.isInteger(message.splitSize.low) && $util.isInteger(message.splitSize.high)))
                    return "splitSize: integer|Long expected";
                if (message.splitSizeUnitInByte != null && message.hasOwnProperty("splitSizeUnitInByte"))
                    if (!$util.isInteger(message.splitSizeUnitInByte) && !(message.splitSizeUnitInByte && $util.isInteger(message.splitSizeUnitInByte.low) && $util.isInteger(message.splitSizeUnitInByte.high)))
                        return "splitSizeUnitInByte: integer|Long expected";
                return null;
            };

            /**
             * Creates a ComputeSplitPointsBySizeRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.ComputeSplitPointsBySizeRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.ComputeSplitPointsBySizeRequest} ComputeSplitPointsBySizeRequest
             */
            ComputeSplitPointsBySizeRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.ComputeSplitPointsBySizeRequest)
                    return object;
                var message = new $root.main.proto.ComputeSplitPointsBySizeRequest();
                if (object.tableName != null)
                    message.tableName = String(object.tableName);
                if (object.splitSize != null)
                    if ($util.Long)
                        (message.splitSize = $util.Long.fromValue(object.splitSize)).unsigned = false;
                    else if (typeof object.splitSize === "string")
                        message.splitSize = parseInt(object.splitSize, 10);
                    else if (typeof object.splitSize === "number")
                        message.splitSize = object.splitSize;
                    else if (typeof object.splitSize === "object")
                        message.splitSize = new $util.LongBits(object.splitSize.low >>> 0, object.splitSize.high >>> 0).toNumber();
                if (object.splitSizeUnitInByte != null)
                    if ($util.Long)
                        (message.splitSizeUnitInByte = $util.Long.fromValue(object.splitSizeUnitInByte)).unsigned = false;
                    else if (typeof object.splitSizeUnitInByte === "string")
                        message.splitSizeUnitInByte = parseInt(object.splitSizeUnitInByte, 10);
                    else if (typeof object.splitSizeUnitInByte === "number")
                        message.splitSizeUnitInByte = object.splitSizeUnitInByte;
                    else if (typeof object.splitSizeUnitInByte === "object")
                        message.splitSizeUnitInByte = new $util.LongBits(object.splitSizeUnitInByte.low >>> 0, object.splitSizeUnitInByte.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a ComputeSplitPointsBySizeRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.ComputeSplitPointsBySizeRequest
             * @static
             * @param {main.proto.ComputeSplitPointsBySizeRequest} message ComputeSplitPointsBySizeRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ComputeSplitPointsBySizeRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.tableName = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.splitSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.splitSize = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.splitSizeUnitInByte = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.splitSizeUnitInByte = options.longs === String ? "0" : 0;
                }
                if (message.tableName != null && message.hasOwnProperty("tableName"))
                    object.tableName = message.tableName;
                if (message.splitSize != null && message.hasOwnProperty("splitSize"))
                    if (typeof message.splitSize === "number")
                        object.splitSize = options.longs === String ? String(message.splitSize) : message.splitSize;
                    else
                        object.splitSize = options.longs === String ? $util.Long.prototype.toString.call(message.splitSize) : options.longs === Number ? new $util.LongBits(message.splitSize.low >>> 0, message.splitSize.high >>> 0).toNumber() : message.splitSize;
                if (message.splitSizeUnitInByte != null && message.hasOwnProperty("splitSizeUnitInByte"))
                    if (typeof message.splitSizeUnitInByte === "number")
                        object.splitSizeUnitInByte = options.longs === String ? String(message.splitSizeUnitInByte) : message.splitSizeUnitInByte;
                    else
                        object.splitSizeUnitInByte = options.longs === String ? $util.Long.prototype.toString.call(message.splitSizeUnitInByte) : options.longs === Number ? new $util.LongBits(message.splitSizeUnitInByte.low >>> 0, message.splitSizeUnitInByte.high >>> 0).toNumber() : message.splitSizeUnitInByte;
                return object;
            };

            /**
             * Converts this ComputeSplitPointsBySizeRequest to JSON.
             * @function toJSON
             * @memberof main.proto.ComputeSplitPointsBySizeRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ComputeSplitPointsBySizeRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ComputeSplitPointsBySizeRequest;
        })();

        proto.ComputeSplitPointsBySizeResponse = (function() {

            /**
             * Properties of a ComputeSplitPointsBySizeResponse.
             * @memberof main.proto
             * @interface IComputeSplitPointsBySizeResponse
             * @property {main.proto.IConsumedCapacity} consumed ComputeSplitPointsBySizeResponse consumed
             * @property {Array.<main.proto.IPrimaryKeySchema>|null} [schema] ComputeSplitPointsBySizeResponse schema
             * @property {Array.<Uint8Array>|null} [splitPoints] Split points between splits, in the increasing order
             * 
             * A split is a consecutive range of primary keys,
             * whose data size is about split_size specified in the request.
             * The size could be hard to be precise.
             * 
             * A split point is an array of primary-key column w.r.t. table schema,
             * which is never longer than that of table schema.
             * Tailing -inf will be omitted to reduce transmission payloads.
             * @property {Array.<main.proto.ComputeSplitPointsBySizeResponse.ISplitLocation>|null} [locations] ComputeSplitPointsBySizeResponse locations
             */

            /**
             * Constructs a new ComputeSplitPointsBySizeResponse.
             * @memberof main.proto
             * @classdesc Represents a ComputeSplitPointsBySizeResponse.
             * @implements IComputeSplitPointsBySizeResponse
             * @constructor
             * @param {main.proto.IComputeSplitPointsBySizeResponse=} [properties] Properties to set
             */
            function ComputeSplitPointsBySizeResponse(properties) {
                this.schema = [];
                this.splitPoints = [];
                this.locations = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ComputeSplitPointsBySizeResponse consumed.
             * @member {main.proto.IConsumedCapacity} consumed
             * @memberof main.proto.ComputeSplitPointsBySizeResponse
             * @instance
             */
            ComputeSplitPointsBySizeResponse.prototype.consumed = null;

            /**
             * ComputeSplitPointsBySizeResponse schema.
             * @member {Array.<main.proto.IPrimaryKeySchema>} schema
             * @memberof main.proto.ComputeSplitPointsBySizeResponse
             * @instance
             */
            ComputeSplitPointsBySizeResponse.prototype.schema = $util.emptyArray;

            /**
             * Split points between splits, in the increasing order
             * 
             * A split is a consecutive range of primary keys,
             * whose data size is about split_size specified in the request.
             * The size could be hard to be precise.
             * 
             * A split point is an array of primary-key column w.r.t. table schema,
             * which is never longer than that of table schema.
             * Tailing -inf will be omitted to reduce transmission payloads.
             * @member {Array.<Uint8Array>} splitPoints
             * @memberof main.proto.ComputeSplitPointsBySizeResponse
             * @instance
             */
            ComputeSplitPointsBySizeResponse.prototype.splitPoints = $util.emptyArray;

            /**
             * ComputeSplitPointsBySizeResponse locations.
             * @member {Array.<main.proto.ComputeSplitPointsBySizeResponse.ISplitLocation>} locations
             * @memberof main.proto.ComputeSplitPointsBySizeResponse
             * @instance
             */
            ComputeSplitPointsBySizeResponse.prototype.locations = $util.emptyArray;

            /**
             * Creates a new ComputeSplitPointsBySizeResponse instance using the specified properties.
             * @function create
             * @memberof main.proto.ComputeSplitPointsBySizeResponse
             * @static
             * @param {main.proto.IComputeSplitPointsBySizeResponse=} [properties] Properties to set
             * @returns {main.proto.ComputeSplitPointsBySizeResponse} ComputeSplitPointsBySizeResponse instance
             */
            ComputeSplitPointsBySizeResponse.create = function create(properties) {
                return new ComputeSplitPointsBySizeResponse(properties);
            };

            /**
             * Encodes the specified ComputeSplitPointsBySizeResponse message. Does not implicitly {@link main.proto.ComputeSplitPointsBySizeResponse.verify|verify} messages.
             * @function encode
             * @memberof main.proto.ComputeSplitPointsBySizeResponse
             * @static
             * @param {main.proto.IComputeSplitPointsBySizeResponse} message ComputeSplitPointsBySizeResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ComputeSplitPointsBySizeResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                $root.main.proto.ConsumedCapacity.encode(message.consumed, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.schema != null && message.schema.length)
                    for (var i = 0; i < message.schema.length; ++i)
                        $root.main.proto.PrimaryKeySchema.encode(message.schema[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.splitPoints != null && message.splitPoints.length)
                    for (var i = 0; i < message.splitPoints.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.splitPoints[i]);
                if (message.locations != null && message.locations.length)
                    for (var i = 0; i < message.locations.length; ++i)
                        $root.main.proto.ComputeSplitPointsBySizeResponse.SplitLocation.encode(message.locations[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ComputeSplitPointsBySizeResponse message, length delimited. Does not implicitly {@link main.proto.ComputeSplitPointsBySizeResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.ComputeSplitPointsBySizeResponse
             * @static
             * @param {main.proto.IComputeSplitPointsBySizeResponse} message ComputeSplitPointsBySizeResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ComputeSplitPointsBySizeResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ComputeSplitPointsBySizeResponse message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.ComputeSplitPointsBySizeResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.ComputeSplitPointsBySizeResponse} ComputeSplitPointsBySizeResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ComputeSplitPointsBySizeResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.ComputeSplitPointsBySizeResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.consumed = $root.main.proto.ConsumedCapacity.decode(reader, reader.uint32());
                        break;
                    case 2:
                        if (!(message.schema && message.schema.length))
                            message.schema = [];
                        message.schema.push($root.main.proto.PrimaryKeySchema.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.splitPoints && message.splitPoints.length))
                            message.splitPoints = [];
                        message.splitPoints.push(reader.bytes());
                        break;
                    case 4:
                        if (!(message.locations && message.locations.length))
                            message.locations = [];
                        message.locations.push($root.main.proto.ComputeSplitPointsBySizeResponse.SplitLocation.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("consumed"))
                    throw $util.ProtocolError("missing required 'consumed'", { instance: message });
                return message;
            };

            /**
             * Decodes a ComputeSplitPointsBySizeResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.ComputeSplitPointsBySizeResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.ComputeSplitPointsBySizeResponse} ComputeSplitPointsBySizeResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ComputeSplitPointsBySizeResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ComputeSplitPointsBySizeResponse message.
             * @function verify
             * @memberof main.proto.ComputeSplitPointsBySizeResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ComputeSplitPointsBySizeResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                {
                    var error = $root.main.proto.ConsumedCapacity.verify(message.consumed);
                    if (error)
                        return "consumed." + error;
                }
                if (message.schema != null && message.hasOwnProperty("schema")) {
                    if (!Array.isArray(message.schema))
                        return "schema: array expected";
                    for (var i = 0; i < message.schema.length; ++i) {
                        var error = $root.main.proto.PrimaryKeySchema.verify(message.schema[i]);
                        if (error)
                            return "schema." + error;
                    }
                }
                if (message.splitPoints != null && message.hasOwnProperty("splitPoints")) {
                    if (!Array.isArray(message.splitPoints))
                        return "splitPoints: array expected";
                    for (var i = 0; i < message.splitPoints.length; ++i)
                        if (!(message.splitPoints[i] && typeof message.splitPoints[i].length === "number" || $util.isString(message.splitPoints[i])))
                            return "splitPoints: buffer[] expected";
                }
                if (message.locations != null && message.hasOwnProperty("locations")) {
                    if (!Array.isArray(message.locations))
                        return "locations: array expected";
                    for (var i = 0; i < message.locations.length; ++i) {
                        var error = $root.main.proto.ComputeSplitPointsBySizeResponse.SplitLocation.verify(message.locations[i]);
                        if (error)
                            return "locations." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ComputeSplitPointsBySizeResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.ComputeSplitPointsBySizeResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.ComputeSplitPointsBySizeResponse} ComputeSplitPointsBySizeResponse
             */
            ComputeSplitPointsBySizeResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.ComputeSplitPointsBySizeResponse)
                    return object;
                var message = new $root.main.proto.ComputeSplitPointsBySizeResponse();
                if (object.consumed != null) {
                    if (typeof object.consumed !== "object")
                        throw TypeError(".main.proto.ComputeSplitPointsBySizeResponse.consumed: object expected");
                    message.consumed = $root.main.proto.ConsumedCapacity.fromObject(object.consumed);
                }
                if (object.schema) {
                    if (!Array.isArray(object.schema))
                        throw TypeError(".main.proto.ComputeSplitPointsBySizeResponse.schema: array expected");
                    message.schema = [];
                    for (var i = 0; i < object.schema.length; ++i) {
                        if (typeof object.schema[i] !== "object")
                            throw TypeError(".main.proto.ComputeSplitPointsBySizeResponse.schema: object expected");
                        message.schema[i] = $root.main.proto.PrimaryKeySchema.fromObject(object.schema[i]);
                    }
                }
                if (object.splitPoints) {
                    if (!Array.isArray(object.splitPoints))
                        throw TypeError(".main.proto.ComputeSplitPointsBySizeResponse.splitPoints: array expected");
                    message.splitPoints = [];
                    for (var i = 0; i < object.splitPoints.length; ++i)
                        if (typeof object.splitPoints[i] === "string")
                            $util.base64.decode(object.splitPoints[i], message.splitPoints[i] = $util.newBuffer($util.base64.length(object.splitPoints[i])), 0);
                        else if (object.splitPoints[i].length)
                            message.splitPoints[i] = object.splitPoints[i];
                }
                if (object.locations) {
                    if (!Array.isArray(object.locations))
                        throw TypeError(".main.proto.ComputeSplitPointsBySizeResponse.locations: array expected");
                    message.locations = [];
                    for (var i = 0; i < object.locations.length; ++i) {
                        if (typeof object.locations[i] !== "object")
                            throw TypeError(".main.proto.ComputeSplitPointsBySizeResponse.locations: object expected");
                        message.locations[i] = $root.main.proto.ComputeSplitPointsBySizeResponse.SplitLocation.fromObject(object.locations[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a ComputeSplitPointsBySizeResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.ComputeSplitPointsBySizeResponse
             * @static
             * @param {main.proto.ComputeSplitPointsBySizeResponse} message ComputeSplitPointsBySizeResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ComputeSplitPointsBySizeResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.schema = [];
                    object.splitPoints = [];
                    object.locations = [];
                }
                if (options.defaults)
                    object.consumed = null;
                if (message.consumed != null && message.hasOwnProperty("consumed"))
                    object.consumed = $root.main.proto.ConsumedCapacity.toObject(message.consumed, options);
                if (message.schema && message.schema.length) {
                    object.schema = [];
                    for (var j = 0; j < message.schema.length; ++j)
                        object.schema[j] = $root.main.proto.PrimaryKeySchema.toObject(message.schema[j], options);
                }
                if (message.splitPoints && message.splitPoints.length) {
                    object.splitPoints = [];
                    for (var j = 0; j < message.splitPoints.length; ++j)
                        object.splitPoints[j] = options.bytes === String ? $util.base64.encode(message.splitPoints[j], 0, message.splitPoints[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.splitPoints[j]) : message.splitPoints[j];
                }
                if (message.locations && message.locations.length) {
                    object.locations = [];
                    for (var j = 0; j < message.locations.length; ++j)
                        object.locations[j] = $root.main.proto.ComputeSplitPointsBySizeResponse.SplitLocation.toObject(message.locations[j], options);
                }
                return object;
            };

            /**
             * Converts this ComputeSplitPointsBySizeResponse to JSON.
             * @function toJSON
             * @memberof main.proto.ComputeSplitPointsBySizeResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ComputeSplitPointsBySizeResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            ComputeSplitPointsBySizeResponse.SplitLocation = (function() {

                /**
                 * Properties of a SplitLocation.
                 * @memberof main.proto.ComputeSplitPointsBySizeResponse
                 * @interface ISplitLocation
                 * @property {string} location SplitLocation location
                 * @property {number|Long} repeat SplitLocation repeat
                 */

                /**
                 * Constructs a new SplitLocation.
                 * @memberof main.proto.ComputeSplitPointsBySizeResponse
                 * @classdesc Locations where splits lies in.
                 * 
                 * By the managed nature of TableStore, these locations are no more than hints.
                 * If a location is not suitable to be seen, an empty string will be placed.
                 * @implements ISplitLocation
                 * @constructor
                 * @param {main.proto.ComputeSplitPointsBySizeResponse.ISplitLocation=} [properties] Properties to set
                 */
                function SplitLocation(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SplitLocation location.
                 * @member {string} location
                 * @memberof main.proto.ComputeSplitPointsBySizeResponse.SplitLocation
                 * @instance
                 */
                SplitLocation.prototype.location = "";

                /**
                 * SplitLocation repeat.
                 * @member {number|Long} repeat
                 * @memberof main.proto.ComputeSplitPointsBySizeResponse.SplitLocation
                 * @instance
                 */
                SplitLocation.prototype.repeat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Creates a new SplitLocation instance using the specified properties.
                 * @function create
                 * @memberof main.proto.ComputeSplitPointsBySizeResponse.SplitLocation
                 * @static
                 * @param {main.proto.ComputeSplitPointsBySizeResponse.ISplitLocation=} [properties] Properties to set
                 * @returns {main.proto.ComputeSplitPointsBySizeResponse.SplitLocation} SplitLocation instance
                 */
                SplitLocation.create = function create(properties) {
                    return new SplitLocation(properties);
                };

                /**
                 * Encodes the specified SplitLocation message. Does not implicitly {@link main.proto.ComputeSplitPointsBySizeResponse.SplitLocation.verify|verify} messages.
                 * @function encode
                 * @memberof main.proto.ComputeSplitPointsBySizeResponse.SplitLocation
                 * @static
                 * @param {main.proto.ComputeSplitPointsBySizeResponse.ISplitLocation} message SplitLocation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SplitLocation.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.location);
                    writer.uint32(/* id 2, wireType 0 =*/16).sint64(message.repeat);
                    return writer;
                };

                /**
                 * Encodes the specified SplitLocation message, length delimited. Does not implicitly {@link main.proto.ComputeSplitPointsBySizeResponse.SplitLocation.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof main.proto.ComputeSplitPointsBySizeResponse.SplitLocation
                 * @static
                 * @param {main.proto.ComputeSplitPointsBySizeResponse.ISplitLocation} message SplitLocation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SplitLocation.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SplitLocation message from the specified reader or buffer.
                 * @function decode
                 * @memberof main.proto.ComputeSplitPointsBySizeResponse.SplitLocation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {main.proto.ComputeSplitPointsBySizeResponse.SplitLocation} SplitLocation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SplitLocation.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.ComputeSplitPointsBySizeResponse.SplitLocation();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.location = reader.string();
                            break;
                        case 2:
                            message.repeat = reader.sint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("location"))
                        throw $util.ProtocolError("missing required 'location'", { instance: message });
                    if (!message.hasOwnProperty("repeat"))
                        throw $util.ProtocolError("missing required 'repeat'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a SplitLocation message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof main.proto.ComputeSplitPointsBySizeResponse.SplitLocation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {main.proto.ComputeSplitPointsBySizeResponse.SplitLocation} SplitLocation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SplitLocation.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SplitLocation message.
                 * @function verify
                 * @memberof main.proto.ComputeSplitPointsBySizeResponse.SplitLocation
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SplitLocation.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (!$util.isString(message.location))
                        return "location: string expected";
                    if (!$util.isInteger(message.repeat) && !(message.repeat && $util.isInteger(message.repeat.low) && $util.isInteger(message.repeat.high)))
                        return "repeat: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a SplitLocation message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof main.proto.ComputeSplitPointsBySizeResponse.SplitLocation
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {main.proto.ComputeSplitPointsBySizeResponse.SplitLocation} SplitLocation
                 */
                SplitLocation.fromObject = function fromObject(object) {
                    if (object instanceof $root.main.proto.ComputeSplitPointsBySizeResponse.SplitLocation)
                        return object;
                    var message = new $root.main.proto.ComputeSplitPointsBySizeResponse.SplitLocation();
                    if (object.location != null)
                        message.location = String(object.location);
                    if (object.repeat != null)
                        if ($util.Long)
                            (message.repeat = $util.Long.fromValue(object.repeat)).unsigned = false;
                        else if (typeof object.repeat === "string")
                            message.repeat = parseInt(object.repeat, 10);
                        else if (typeof object.repeat === "number")
                            message.repeat = object.repeat;
                        else if (typeof object.repeat === "object")
                            message.repeat = new $util.LongBits(object.repeat.low >>> 0, object.repeat.high >>> 0).toNumber();
                    return message;
                };

                /**
                 * Creates a plain object from a SplitLocation message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof main.proto.ComputeSplitPointsBySizeResponse.SplitLocation
                 * @static
                 * @param {main.proto.ComputeSplitPointsBySizeResponse.SplitLocation} message SplitLocation
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SplitLocation.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.location = "";
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.repeat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.repeat = options.longs === String ? "0" : 0;
                    }
                    if (message.location != null && message.hasOwnProperty("location"))
                        object.location = message.location;
                    if (message.repeat != null && message.hasOwnProperty("repeat"))
                        if (typeof message.repeat === "number")
                            object.repeat = options.longs === String ? String(message.repeat) : message.repeat;
                        else
                            object.repeat = options.longs === String ? $util.Long.prototype.toString.call(message.repeat) : options.longs === Number ? new $util.LongBits(message.repeat.low >>> 0, message.repeat.high >>> 0).toNumber() : message.repeat;
                    return object;
                };

                /**
                 * Converts this SplitLocation to JSON.
                 * @function toJSON
                 * @memberof main.proto.ComputeSplitPointsBySizeResponse.SplitLocation
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SplitLocation.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SplitLocation;
            })();

            return ComputeSplitPointsBySizeResponse;
        })();

        /**
         * SQLPayloadVersion enum.
         * @name main.proto.SQLPayloadVersion
         * @enum {number}
         * @property {number} SQL_FLAT_BUFFERS=2 SQL_FLAT_BUFFERS value
         */
        proto.SQLPayloadVersion = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[2] = "SQL_FLAT_BUFFERS"] = 2;
            return values;
        })();

        /**
         * SQLStatementType enum.
         * @name main.proto.SQLStatementType
         * @enum {number}
         * @property {number} SQL_SELECT=1 SQL_SELECT value
         * @property {number} SQL_CREATE_TABLE=2 SQL_CREATE_TABLE value
         * @property {number} SQL_SHOW_TABLE=3 SQL_SHOW_TABLE value
         * @property {number} SQL_DESCRIBE_TABLE=4 SQL_DESCRIBE_TABLE value
         * @property {number} SQL_DROP_TABLE=5 SQL_DROP_TABLE value
         * @property {number} SQL_ALTER_TABLE=6 SQL_ALTER_TABLE value
         */
        proto.SQLStatementType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "SQL_SELECT"] = 1;
            values[valuesById[2] = "SQL_CREATE_TABLE"] = 2;
            values[valuesById[3] = "SQL_SHOW_TABLE"] = 3;
            values[valuesById[4] = "SQL_DESCRIBE_TABLE"] = 4;
            values[valuesById[5] = "SQL_DROP_TABLE"] = 5;
            values[valuesById[6] = "SQL_ALTER_TABLE"] = 6;
            return values;
        })();

        proto.SQLQueryRequest = (function() {

            /**
             * Properties of a SQLQueryRequest.
             * @memberof main.proto
             * @interface ISQLQueryRequest
             * @property {string} query SQLQueryRequest query
             * @property {main.proto.SQLPayloadVersion|null} [version] SQLQueryRequest version
             */

            /**
             * Constructs a new SQLQueryRequest.
             * @memberof main.proto
             * @classdesc Represents a SQLQueryRequest.
             * @implements ISQLQueryRequest
             * @constructor
             * @param {main.proto.ISQLQueryRequest=} [properties] Properties to set
             */
            function SQLQueryRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SQLQueryRequest query.
             * @member {string} query
             * @memberof main.proto.SQLQueryRequest
             * @instance
             */
            SQLQueryRequest.prototype.query = "";

            /**
             * SQLQueryRequest version.
             * @member {main.proto.SQLPayloadVersion} version
             * @memberof main.proto.SQLQueryRequest
             * @instance
             */
            SQLQueryRequest.prototype.version = 2;

            /**
             * Creates a new SQLQueryRequest instance using the specified properties.
             * @function create
             * @memberof main.proto.SQLQueryRequest
             * @static
             * @param {main.proto.ISQLQueryRequest=} [properties] Properties to set
             * @returns {main.proto.SQLQueryRequest} SQLQueryRequest instance
             */
            SQLQueryRequest.create = function create(properties) {
                return new SQLQueryRequest(properties);
            };

            /**
             * Encodes the specified SQLQueryRequest message. Does not implicitly {@link main.proto.SQLQueryRequest.verify|verify} messages.
             * @function encode
             * @memberof main.proto.SQLQueryRequest
             * @static
             * @param {main.proto.ISQLQueryRequest} message SQLQueryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SQLQueryRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.query);
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.version);
                return writer;
            };

            /**
             * Encodes the specified SQLQueryRequest message, length delimited. Does not implicitly {@link main.proto.SQLQueryRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.SQLQueryRequest
             * @static
             * @param {main.proto.ISQLQueryRequest} message SQLQueryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SQLQueryRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SQLQueryRequest message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.SQLQueryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.SQLQueryRequest} SQLQueryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SQLQueryRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.SQLQueryRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.query = reader.string();
                        break;
                    case 2:
                        message.version = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("query"))
                    throw $util.ProtocolError("missing required 'query'", { instance: message });
                return message;
            };

            /**
             * Decodes a SQLQueryRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.SQLQueryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.SQLQueryRequest} SQLQueryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SQLQueryRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SQLQueryRequest message.
             * @function verify
             * @memberof main.proto.SQLQueryRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SQLQueryRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.query))
                    return "query: string expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    switch (message.version) {
                    default:
                        return "version: enum value expected";
                    case 2:
                        break;
                    }
                return null;
            };

            /**
             * Creates a SQLQueryRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.SQLQueryRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.SQLQueryRequest} SQLQueryRequest
             */
            SQLQueryRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.SQLQueryRequest)
                    return object;
                var message = new $root.main.proto.SQLQueryRequest();
                if (object.query != null)
                    message.query = String(object.query);
                switch (object.version) {
                case "SQL_FLAT_BUFFERS":
                case 2:
                    message.version = 2;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a SQLQueryRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.SQLQueryRequest
             * @static
             * @param {main.proto.SQLQueryRequest} message SQLQueryRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SQLQueryRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.query = "";
                    object.version = options.enums === String ? "SQL_FLAT_BUFFERS" : 2;
                }
                if (message.query != null && message.hasOwnProperty("query"))
                    object.query = message.query;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = options.enums === String ? $root.main.proto.SQLPayloadVersion[message.version] : message.version;
                return object;
            };

            /**
             * Converts this SQLQueryRequest to JSON.
             * @function toJSON
             * @memberof main.proto.SQLQueryRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SQLQueryRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SQLQueryRequest;
        })();

        proto.TableConsumedCapacity = (function() {

            /**
             * Properties of a TableConsumedCapacity.
             * @memberof main.proto
             * @interface ITableConsumedCapacity
             * @property {string|null} [tableName] TableConsumedCapacity tableName
             * @property {main.proto.IConsumedCapacity|null} [consumed] TableConsumedCapacity consumed
             * @property {main.proto.IReservedThroughput|null} [reservedThroughput] TableConsumedCapacity reservedThroughput
             */

            /**
             * Constructs a new TableConsumedCapacity.
             * @memberof main.proto
             * @classdesc Represents a TableConsumedCapacity.
             * @implements ITableConsumedCapacity
             * @constructor
             * @param {main.proto.ITableConsumedCapacity=} [properties] Properties to set
             */
            function TableConsumedCapacity(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TableConsumedCapacity tableName.
             * @member {string} tableName
             * @memberof main.proto.TableConsumedCapacity
             * @instance
             */
            TableConsumedCapacity.prototype.tableName = "";

            /**
             * TableConsumedCapacity consumed.
             * @member {main.proto.IConsumedCapacity|null|undefined} consumed
             * @memberof main.proto.TableConsumedCapacity
             * @instance
             */
            TableConsumedCapacity.prototype.consumed = null;

            /**
             * TableConsumedCapacity reservedThroughput.
             * @member {main.proto.IReservedThroughput|null|undefined} reservedThroughput
             * @memberof main.proto.TableConsumedCapacity
             * @instance
             */
            TableConsumedCapacity.prototype.reservedThroughput = null;

            /**
             * Creates a new TableConsumedCapacity instance using the specified properties.
             * @function create
             * @memberof main.proto.TableConsumedCapacity
             * @static
             * @param {main.proto.ITableConsumedCapacity=} [properties] Properties to set
             * @returns {main.proto.TableConsumedCapacity} TableConsumedCapacity instance
             */
            TableConsumedCapacity.create = function create(properties) {
                return new TableConsumedCapacity(properties);
            };

            /**
             * Encodes the specified TableConsumedCapacity message. Does not implicitly {@link main.proto.TableConsumedCapacity.verify|verify} messages.
             * @function encode
             * @memberof main.proto.TableConsumedCapacity
             * @static
             * @param {main.proto.ITableConsumedCapacity} message TableConsumedCapacity message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TableConsumedCapacity.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tableName != null && Object.hasOwnProperty.call(message, "tableName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.tableName);
                if (message.consumed != null && Object.hasOwnProperty.call(message, "consumed"))
                    $root.main.proto.ConsumedCapacity.encode(message.consumed, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.reservedThroughput != null && Object.hasOwnProperty.call(message, "reservedThroughput"))
                    $root.main.proto.ReservedThroughput.encode(message.reservedThroughput, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified TableConsumedCapacity message, length delimited. Does not implicitly {@link main.proto.TableConsumedCapacity.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.TableConsumedCapacity
             * @static
             * @param {main.proto.ITableConsumedCapacity} message TableConsumedCapacity message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TableConsumedCapacity.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TableConsumedCapacity message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.TableConsumedCapacity
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.TableConsumedCapacity} TableConsumedCapacity
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TableConsumedCapacity.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.TableConsumedCapacity();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tableName = reader.string();
                        break;
                    case 2:
                        message.consumed = $root.main.proto.ConsumedCapacity.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.reservedThroughput = $root.main.proto.ReservedThroughput.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TableConsumedCapacity message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.TableConsumedCapacity
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.TableConsumedCapacity} TableConsumedCapacity
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TableConsumedCapacity.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TableConsumedCapacity message.
             * @function verify
             * @memberof main.proto.TableConsumedCapacity
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TableConsumedCapacity.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tableName != null && message.hasOwnProperty("tableName"))
                    if (!$util.isString(message.tableName))
                        return "tableName: string expected";
                if (message.consumed != null && message.hasOwnProperty("consumed")) {
                    var error = $root.main.proto.ConsumedCapacity.verify(message.consumed);
                    if (error)
                        return "consumed." + error;
                }
                if (message.reservedThroughput != null && message.hasOwnProperty("reservedThroughput")) {
                    var error = $root.main.proto.ReservedThroughput.verify(message.reservedThroughput);
                    if (error)
                        return "reservedThroughput." + error;
                }
                return null;
            };

            /**
             * Creates a TableConsumedCapacity message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.TableConsumedCapacity
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.TableConsumedCapacity} TableConsumedCapacity
             */
            TableConsumedCapacity.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.TableConsumedCapacity)
                    return object;
                var message = new $root.main.proto.TableConsumedCapacity();
                if (object.tableName != null)
                    message.tableName = String(object.tableName);
                if (object.consumed != null) {
                    if (typeof object.consumed !== "object")
                        throw TypeError(".main.proto.TableConsumedCapacity.consumed: object expected");
                    message.consumed = $root.main.proto.ConsumedCapacity.fromObject(object.consumed);
                }
                if (object.reservedThroughput != null) {
                    if (typeof object.reservedThroughput !== "object")
                        throw TypeError(".main.proto.TableConsumedCapacity.reservedThroughput: object expected");
                    message.reservedThroughput = $root.main.proto.ReservedThroughput.fromObject(object.reservedThroughput);
                }
                return message;
            };

            /**
             * Creates a plain object from a TableConsumedCapacity message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.TableConsumedCapacity
             * @static
             * @param {main.proto.TableConsumedCapacity} message TableConsumedCapacity
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TableConsumedCapacity.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.tableName = "";
                    object.consumed = null;
                    object.reservedThroughput = null;
                }
                if (message.tableName != null && message.hasOwnProperty("tableName"))
                    object.tableName = message.tableName;
                if (message.consumed != null && message.hasOwnProperty("consumed"))
                    object.consumed = $root.main.proto.ConsumedCapacity.toObject(message.consumed, options);
                if (message.reservedThroughput != null && message.hasOwnProperty("reservedThroughput"))
                    object.reservedThroughput = $root.main.proto.ReservedThroughput.toObject(message.reservedThroughput, options);
                return object;
            };

            /**
             * Converts this TableConsumedCapacity to JSON.
             * @function toJSON
             * @memberof main.proto.TableConsumedCapacity
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TableConsumedCapacity.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TableConsumedCapacity;
        })();

        proto.SQLQueryResponse = (function() {

            /**
             * Properties of a SQLQueryResponse.
             * @memberof main.proto
             * @interface ISQLQueryResponse
             * @property {Array.<main.proto.ITableConsumedCapacity>|null} [consumes] SQLQueryResponse consumes
             * @property {Uint8Array|null} [rows] SQLQueryResponse rows
             * @property {main.proto.SQLPayloadVersion|null} [version] SQLQueryResponse version
             * @property {main.proto.SQLStatementType|null} [type] SQLQueryResponse type
             */

            /**
             * Constructs a new SQLQueryResponse.
             * @memberof main.proto
             * @classdesc Represents a SQLQueryResponse.
             * @implements ISQLQueryResponse
             * @constructor
             * @param {main.proto.ISQLQueryResponse=} [properties] Properties to set
             */
            function SQLQueryResponse(properties) {
                this.consumes = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SQLQueryResponse consumes.
             * @member {Array.<main.proto.ITableConsumedCapacity>} consumes
             * @memberof main.proto.SQLQueryResponse
             * @instance
             */
            SQLQueryResponse.prototype.consumes = $util.emptyArray;

            /**
             * SQLQueryResponse rows.
             * @member {Uint8Array} rows
             * @memberof main.proto.SQLQueryResponse
             * @instance
             */
            SQLQueryResponse.prototype.rows = $util.newBuffer([]);

            /**
             * SQLQueryResponse version.
             * @member {main.proto.SQLPayloadVersion} version
             * @memberof main.proto.SQLQueryResponse
             * @instance
             */
            SQLQueryResponse.prototype.version = 2;

            /**
             * SQLQueryResponse type.
             * @member {main.proto.SQLStatementType} type
             * @memberof main.proto.SQLQueryResponse
             * @instance
             */
            SQLQueryResponse.prototype.type = 1;

            /**
             * Creates a new SQLQueryResponse instance using the specified properties.
             * @function create
             * @memberof main.proto.SQLQueryResponse
             * @static
             * @param {main.proto.ISQLQueryResponse=} [properties] Properties to set
             * @returns {main.proto.SQLQueryResponse} SQLQueryResponse instance
             */
            SQLQueryResponse.create = function create(properties) {
                return new SQLQueryResponse(properties);
            };

            /**
             * Encodes the specified SQLQueryResponse message. Does not implicitly {@link main.proto.SQLQueryResponse.verify|verify} messages.
             * @function encode
             * @memberof main.proto.SQLQueryResponse
             * @static
             * @param {main.proto.ISQLQueryResponse} message SQLQueryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SQLQueryResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.consumes != null && message.consumes.length)
                    for (var i = 0; i < message.consumes.length; ++i)
                        $root.main.proto.TableConsumedCapacity.encode(message.consumes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.rows != null && Object.hasOwnProperty.call(message, "rows"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.rows);
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.version);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.type);
                return writer;
            };

            /**
             * Encodes the specified SQLQueryResponse message, length delimited. Does not implicitly {@link main.proto.SQLQueryResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof main.proto.SQLQueryResponse
             * @static
             * @param {main.proto.ISQLQueryResponse} message SQLQueryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SQLQueryResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SQLQueryResponse message from the specified reader or buffer.
             * @function decode
             * @memberof main.proto.SQLQueryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {main.proto.SQLQueryResponse} SQLQueryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SQLQueryResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.main.proto.SQLQueryResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.consumes && message.consumes.length))
                            message.consumes = [];
                        message.consumes.push($root.main.proto.TableConsumedCapacity.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.rows = reader.bytes();
                        break;
                    case 3:
                        message.version = reader.int32();
                        break;
                    case 4:
                        message.type = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SQLQueryResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof main.proto.SQLQueryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {main.proto.SQLQueryResponse} SQLQueryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SQLQueryResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SQLQueryResponse message.
             * @function verify
             * @memberof main.proto.SQLQueryResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SQLQueryResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.consumes != null && message.hasOwnProperty("consumes")) {
                    if (!Array.isArray(message.consumes))
                        return "consumes: array expected";
                    for (var i = 0; i < message.consumes.length; ++i) {
                        var error = $root.main.proto.TableConsumedCapacity.verify(message.consumes[i]);
                        if (error)
                            return "consumes." + error;
                    }
                }
                if (message.rows != null && message.hasOwnProperty("rows"))
                    if (!(message.rows && typeof message.rows.length === "number" || $util.isString(message.rows)))
                        return "rows: buffer expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    switch (message.version) {
                    default:
                        return "version: enum value expected";
                    case 2:
                        break;
                    }
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                        break;
                    }
                return null;
            };

            /**
             * Creates a SQLQueryResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof main.proto.SQLQueryResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {main.proto.SQLQueryResponse} SQLQueryResponse
             */
            SQLQueryResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.main.proto.SQLQueryResponse)
                    return object;
                var message = new $root.main.proto.SQLQueryResponse();
                if (object.consumes) {
                    if (!Array.isArray(object.consumes))
                        throw TypeError(".main.proto.SQLQueryResponse.consumes: array expected");
                    message.consumes = [];
                    for (var i = 0; i < object.consumes.length; ++i) {
                        if (typeof object.consumes[i] !== "object")
                            throw TypeError(".main.proto.SQLQueryResponse.consumes: object expected");
                        message.consumes[i] = $root.main.proto.TableConsumedCapacity.fromObject(object.consumes[i]);
                    }
                }
                if (object.rows != null)
                    if (typeof object.rows === "string")
                        $util.base64.decode(object.rows, message.rows = $util.newBuffer($util.base64.length(object.rows)), 0);
                    else if (object.rows.length)
                        message.rows = object.rows;
                switch (object.version) {
                case "SQL_FLAT_BUFFERS":
                case 2:
                    message.version = 2;
                    break;
                }
                switch (object.type) {
                case "SQL_SELECT":
                case 1:
                    message.type = 1;
                    break;
                case "SQL_CREATE_TABLE":
                case 2:
                    message.type = 2;
                    break;
                case "SQL_SHOW_TABLE":
                case 3:
                    message.type = 3;
                    break;
                case "SQL_DESCRIBE_TABLE":
                case 4:
                    message.type = 4;
                    break;
                case "SQL_DROP_TABLE":
                case 5:
                    message.type = 5;
                    break;
                case "SQL_ALTER_TABLE":
                case 6:
                    message.type = 6;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a SQLQueryResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof main.proto.SQLQueryResponse
             * @static
             * @param {main.proto.SQLQueryResponse} message SQLQueryResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SQLQueryResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.consumes = [];
                if (options.defaults) {
                    if (options.bytes === String)
                        object.rows = "";
                    else {
                        object.rows = [];
                        if (options.bytes !== Array)
                            object.rows = $util.newBuffer(object.rows);
                    }
                    object.version = options.enums === String ? "SQL_FLAT_BUFFERS" : 2;
                    object.type = options.enums === String ? "SQL_SELECT" : 1;
                }
                if (message.consumes && message.consumes.length) {
                    object.consumes = [];
                    for (var j = 0; j < message.consumes.length; ++j)
                        object.consumes[j] = $root.main.proto.TableConsumedCapacity.toObject(message.consumes[j], options);
                }
                if (message.rows != null && message.hasOwnProperty("rows"))
                    object.rows = options.bytes === String ? $util.base64.encode(message.rows, 0, message.rows.length) : options.bytes === Array ? Array.prototype.slice.call(message.rows) : message.rows;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = options.enums === String ? $root.main.proto.SQLPayloadVersion[message.version] : message.version;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.main.proto.SQLStatementType[message.type] : message.type;
                return object;
            };

            /**
             * Converts this SQLQueryResponse to JSON.
             * @function toJSON
             * @memberof main.proto.SQLQueryResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SQLQueryResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SQLQueryResponse;
        })();

        return proto;
    })();

    return main;
})();

$root.filter = (function() {

    /**
     * Namespace filter.
     * @exports filter
     * @namespace
     */
    var filter = {};

    filter.proto = (function() {

        /**
         * Namespace proto.
         * @memberof filter
         * @namespace
         */
        var proto = {};

        /**
         * FilterType enum.
         * @name filter.proto.FilterType
         * @enum {number}
         * @property {number} FT_SINGLE_COLUMN_VALUE=1 FT_SINGLE_COLUMN_VALUE value
         * @property {number} FT_COMPOSITE_COLUMN_VALUE=2 FT_COMPOSITE_COLUMN_VALUE value
         * @property {number} FT_COLUMN_PAGINATION=3 FT_COLUMN_PAGINATION value
         */
        proto.FilterType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "FT_SINGLE_COLUMN_VALUE"] = 1;
            values[valuesById[2] = "FT_COMPOSITE_COLUMN_VALUE"] = 2;
            values[valuesById[3] = "FT_COLUMN_PAGINATION"] = 3;
            return values;
        })();

        /**
         * ComparatorType enum.
         * @name filter.proto.ComparatorType
         * @enum {number}
         * @property {number} CT_EQUAL=1 CT_EQUAL value
         * @property {number} CT_NOT_EQUAL=2 CT_NOT_EQUAL value
         * @property {number} CT_GREATER_THAN=3 CT_GREATER_THAN value
         * @property {number} CT_GREATER_EQUAL=4 CT_GREATER_EQUAL value
         * @property {number} CT_LESS_THAN=5 CT_LESS_THAN value
         * @property {number} CT_LESS_EQUAL=6 CT_LESS_EQUAL value
         */
        proto.ComparatorType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "CT_EQUAL"] = 1;
            values[valuesById[2] = "CT_NOT_EQUAL"] = 2;
            values[valuesById[3] = "CT_GREATER_THAN"] = 3;
            values[valuesById[4] = "CT_GREATER_EQUAL"] = 4;
            values[valuesById[5] = "CT_LESS_THAN"] = 5;
            values[valuesById[6] = "CT_LESS_EQUAL"] = 6;
            return values;
        })();

        proto.SingleColumnValueFilter = (function() {

            /**
             * Properties of a SingleColumnValueFilter.
             * @memberof filter.proto
             * @interface ISingleColumnValueFilter
             * @property {filter.proto.ComparatorType} comparator SingleColumnValueFilter comparator
             * @property {string} columnName SingleColumnValueFilter columnName
             * @property {Uint8Array} columnValue SingleColumnValueFilter columnValue
             * @property {boolean} filterIfMissing SingleColumnValueFilter filterIfMissing
             * @property {boolean} latestVersionOnly SingleColumnValueFilter latestVersionOnly
             */

            /**
             * Constructs a new SingleColumnValueFilter.
             * @memberof filter.proto
             * @classdesc Represents a SingleColumnValueFilter.
             * @implements ISingleColumnValueFilter
             * @constructor
             * @param {filter.proto.ISingleColumnValueFilter=} [properties] Properties to set
             */
            function SingleColumnValueFilter(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SingleColumnValueFilter comparator.
             * @member {filter.proto.ComparatorType} comparator
             * @memberof filter.proto.SingleColumnValueFilter
             * @instance
             */
            SingleColumnValueFilter.prototype.comparator = 1;

            /**
             * SingleColumnValueFilter columnName.
             * @member {string} columnName
             * @memberof filter.proto.SingleColumnValueFilter
             * @instance
             */
            SingleColumnValueFilter.prototype.columnName = "";

            /**
             * SingleColumnValueFilter columnValue.
             * @member {Uint8Array} columnValue
             * @memberof filter.proto.SingleColumnValueFilter
             * @instance
             */
            SingleColumnValueFilter.prototype.columnValue = $util.newBuffer([]);

            /**
             * SingleColumnValueFilter filterIfMissing.
             * @member {boolean} filterIfMissing
             * @memberof filter.proto.SingleColumnValueFilter
             * @instance
             */
            SingleColumnValueFilter.prototype.filterIfMissing = false;

            /**
             * SingleColumnValueFilter latestVersionOnly.
             * @member {boolean} latestVersionOnly
             * @memberof filter.proto.SingleColumnValueFilter
             * @instance
             */
            SingleColumnValueFilter.prototype.latestVersionOnly = false;

            /**
             * Creates a new SingleColumnValueFilter instance using the specified properties.
             * @function create
             * @memberof filter.proto.SingleColumnValueFilter
             * @static
             * @param {filter.proto.ISingleColumnValueFilter=} [properties] Properties to set
             * @returns {filter.proto.SingleColumnValueFilter} SingleColumnValueFilter instance
             */
            SingleColumnValueFilter.create = function create(properties) {
                return new SingleColumnValueFilter(properties);
            };

            /**
             * Encodes the specified SingleColumnValueFilter message. Does not implicitly {@link filter.proto.SingleColumnValueFilter.verify|verify} messages.
             * @function encode
             * @memberof filter.proto.SingleColumnValueFilter
             * @static
             * @param {filter.proto.ISingleColumnValueFilter} message SingleColumnValueFilter message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SingleColumnValueFilter.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.comparator);
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.columnName);
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.columnValue);
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.filterIfMissing);
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.latestVersionOnly);
                return writer;
            };

            /**
             * Encodes the specified SingleColumnValueFilter message, length delimited. Does not implicitly {@link filter.proto.SingleColumnValueFilter.verify|verify} messages.
             * @function encodeDelimited
             * @memberof filter.proto.SingleColumnValueFilter
             * @static
             * @param {filter.proto.ISingleColumnValueFilter} message SingleColumnValueFilter message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SingleColumnValueFilter.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SingleColumnValueFilter message from the specified reader or buffer.
             * @function decode
             * @memberof filter.proto.SingleColumnValueFilter
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {filter.proto.SingleColumnValueFilter} SingleColumnValueFilter
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SingleColumnValueFilter.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.filter.proto.SingleColumnValueFilter();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.comparator = reader.int32();
                        break;
                    case 2:
                        message.columnName = reader.string();
                        break;
                    case 3:
                        message.columnValue = reader.bytes();
                        break;
                    case 4:
                        message.filterIfMissing = reader.bool();
                        break;
                    case 5:
                        message.latestVersionOnly = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("comparator"))
                    throw $util.ProtocolError("missing required 'comparator'", { instance: message });
                if (!message.hasOwnProperty("columnName"))
                    throw $util.ProtocolError("missing required 'columnName'", { instance: message });
                if (!message.hasOwnProperty("columnValue"))
                    throw $util.ProtocolError("missing required 'columnValue'", { instance: message });
                if (!message.hasOwnProperty("filterIfMissing"))
                    throw $util.ProtocolError("missing required 'filterIfMissing'", { instance: message });
                if (!message.hasOwnProperty("latestVersionOnly"))
                    throw $util.ProtocolError("missing required 'latestVersionOnly'", { instance: message });
                return message;
            };

            /**
             * Decodes a SingleColumnValueFilter message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof filter.proto.SingleColumnValueFilter
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {filter.proto.SingleColumnValueFilter} SingleColumnValueFilter
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SingleColumnValueFilter.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SingleColumnValueFilter message.
             * @function verify
             * @memberof filter.proto.SingleColumnValueFilter
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SingleColumnValueFilter.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                switch (message.comparator) {
                default:
                    return "comparator: enum value expected";
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
                if (!$util.isString(message.columnName))
                    return "columnName: string expected";
                if (!(message.columnValue && typeof message.columnValue.length === "number" || $util.isString(message.columnValue)))
                    return "columnValue: buffer expected";
                if (typeof message.filterIfMissing !== "boolean")
                    return "filterIfMissing: boolean expected";
                if (typeof message.latestVersionOnly !== "boolean")
                    return "latestVersionOnly: boolean expected";
                return null;
            };

            /**
             * Creates a SingleColumnValueFilter message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof filter.proto.SingleColumnValueFilter
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {filter.proto.SingleColumnValueFilter} SingleColumnValueFilter
             */
            SingleColumnValueFilter.fromObject = function fromObject(object) {
                if (object instanceof $root.filter.proto.SingleColumnValueFilter)
                    return object;
                var message = new $root.filter.proto.SingleColumnValueFilter();
                switch (object.comparator) {
                case "CT_EQUAL":
                case 1:
                    message.comparator = 1;
                    break;
                case "CT_NOT_EQUAL":
                case 2:
                    message.comparator = 2;
                    break;
                case "CT_GREATER_THAN":
                case 3:
                    message.comparator = 3;
                    break;
                case "CT_GREATER_EQUAL":
                case 4:
                    message.comparator = 4;
                    break;
                case "CT_LESS_THAN":
                case 5:
                    message.comparator = 5;
                    break;
                case "CT_LESS_EQUAL":
                case 6:
                    message.comparator = 6;
                    break;
                }
                if (object.columnName != null)
                    message.columnName = String(object.columnName);
                if (object.columnValue != null)
                    if (typeof object.columnValue === "string")
                        $util.base64.decode(object.columnValue, message.columnValue = $util.newBuffer($util.base64.length(object.columnValue)), 0);
                    else if (object.columnValue.length)
                        message.columnValue = object.columnValue;
                if (object.filterIfMissing != null)
                    message.filterIfMissing = Boolean(object.filterIfMissing);
                if (object.latestVersionOnly != null)
                    message.latestVersionOnly = Boolean(object.latestVersionOnly);
                return message;
            };

            /**
             * Creates a plain object from a SingleColumnValueFilter message. Also converts values to other types if specified.
             * @function toObject
             * @memberof filter.proto.SingleColumnValueFilter
             * @static
             * @param {filter.proto.SingleColumnValueFilter} message SingleColumnValueFilter
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SingleColumnValueFilter.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.comparator = options.enums === String ? "CT_EQUAL" : 1;
                    object.columnName = "";
                    if (options.bytes === String)
                        object.columnValue = "";
                    else {
                        object.columnValue = [];
                        if (options.bytes !== Array)
                            object.columnValue = $util.newBuffer(object.columnValue);
                    }
                    object.filterIfMissing = false;
                    object.latestVersionOnly = false;
                }
                if (message.comparator != null && message.hasOwnProperty("comparator"))
                    object.comparator = options.enums === String ? $root.filter.proto.ComparatorType[message.comparator] : message.comparator;
                if (message.columnName != null && message.hasOwnProperty("columnName"))
                    object.columnName = message.columnName;
                if (message.columnValue != null && message.hasOwnProperty("columnValue"))
                    object.columnValue = options.bytes === String ? $util.base64.encode(message.columnValue, 0, message.columnValue.length) : options.bytes === Array ? Array.prototype.slice.call(message.columnValue) : message.columnValue;
                if (message.filterIfMissing != null && message.hasOwnProperty("filterIfMissing"))
                    object.filterIfMissing = message.filterIfMissing;
                if (message.latestVersionOnly != null && message.hasOwnProperty("latestVersionOnly"))
                    object.latestVersionOnly = message.latestVersionOnly;
                return object;
            };

            /**
             * Converts this SingleColumnValueFilter to JSON.
             * @function toJSON
             * @memberof filter.proto.SingleColumnValueFilter
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SingleColumnValueFilter.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SingleColumnValueFilter;
        })();

        /**
         * LogicalOperator enum.
         * @name filter.proto.LogicalOperator
         * @enum {number}
         * @property {number} LO_NOT=1 LO_NOT value
         * @property {number} LO_AND=2 LO_AND value
         * @property {number} LO_OR=3 LO_OR value
         */
        proto.LogicalOperator = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "LO_NOT"] = 1;
            values[valuesById[2] = "LO_AND"] = 2;
            values[valuesById[3] = "LO_OR"] = 3;
            return values;
        })();

        proto.CompositeColumnValueFilter = (function() {

            /**
             * Properties of a CompositeColumnValueFilter.
             * @memberof filter.proto
             * @interface ICompositeColumnValueFilter
             * @property {filter.proto.LogicalOperator} combinator CompositeColumnValueFilter combinator
             * @property {Array.<filter.proto.IFilter>|null} [subFilters] CompositeColumnValueFilter subFilters
             */

            /**
             * Constructs a new CompositeColumnValueFilter.
             * @memberof filter.proto
             * @classdesc Represents a CompositeColumnValueFilter.
             * @implements ICompositeColumnValueFilter
             * @constructor
             * @param {filter.proto.ICompositeColumnValueFilter=} [properties] Properties to set
             */
            function CompositeColumnValueFilter(properties) {
                this.subFilters = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CompositeColumnValueFilter combinator.
             * @member {filter.proto.LogicalOperator} combinator
             * @memberof filter.proto.CompositeColumnValueFilter
             * @instance
             */
            CompositeColumnValueFilter.prototype.combinator = 1;

            /**
             * CompositeColumnValueFilter subFilters.
             * @member {Array.<filter.proto.IFilter>} subFilters
             * @memberof filter.proto.CompositeColumnValueFilter
             * @instance
             */
            CompositeColumnValueFilter.prototype.subFilters = $util.emptyArray;

            /**
             * Creates a new CompositeColumnValueFilter instance using the specified properties.
             * @function create
             * @memberof filter.proto.CompositeColumnValueFilter
             * @static
             * @param {filter.proto.ICompositeColumnValueFilter=} [properties] Properties to set
             * @returns {filter.proto.CompositeColumnValueFilter} CompositeColumnValueFilter instance
             */
            CompositeColumnValueFilter.create = function create(properties) {
                return new CompositeColumnValueFilter(properties);
            };

            /**
             * Encodes the specified CompositeColumnValueFilter message. Does not implicitly {@link filter.proto.CompositeColumnValueFilter.verify|verify} messages.
             * @function encode
             * @memberof filter.proto.CompositeColumnValueFilter
             * @static
             * @param {filter.proto.ICompositeColumnValueFilter} message CompositeColumnValueFilter message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CompositeColumnValueFilter.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.combinator);
                if (message.subFilters != null && message.subFilters.length)
                    for (var i = 0; i < message.subFilters.length; ++i)
                        $root.filter.proto.Filter.encode(message.subFilters[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CompositeColumnValueFilter message, length delimited. Does not implicitly {@link filter.proto.CompositeColumnValueFilter.verify|verify} messages.
             * @function encodeDelimited
             * @memberof filter.proto.CompositeColumnValueFilter
             * @static
             * @param {filter.proto.ICompositeColumnValueFilter} message CompositeColumnValueFilter message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CompositeColumnValueFilter.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CompositeColumnValueFilter message from the specified reader or buffer.
             * @function decode
             * @memberof filter.proto.CompositeColumnValueFilter
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {filter.proto.CompositeColumnValueFilter} CompositeColumnValueFilter
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CompositeColumnValueFilter.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.filter.proto.CompositeColumnValueFilter();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.combinator = reader.int32();
                        break;
                    case 2:
                        if (!(message.subFilters && message.subFilters.length))
                            message.subFilters = [];
                        message.subFilters.push($root.filter.proto.Filter.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("combinator"))
                    throw $util.ProtocolError("missing required 'combinator'", { instance: message });
                return message;
            };

            /**
             * Decodes a CompositeColumnValueFilter message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof filter.proto.CompositeColumnValueFilter
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {filter.proto.CompositeColumnValueFilter} CompositeColumnValueFilter
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CompositeColumnValueFilter.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CompositeColumnValueFilter message.
             * @function verify
             * @memberof filter.proto.CompositeColumnValueFilter
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CompositeColumnValueFilter.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                switch (message.combinator) {
                default:
                    return "combinator: enum value expected";
                case 1:
                case 2:
                case 3:
                    break;
                }
                if (message.subFilters != null && message.hasOwnProperty("subFilters")) {
                    if (!Array.isArray(message.subFilters))
                        return "subFilters: array expected";
                    for (var i = 0; i < message.subFilters.length; ++i) {
                        var error = $root.filter.proto.Filter.verify(message.subFilters[i]);
                        if (error)
                            return "subFilters." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a CompositeColumnValueFilter message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof filter.proto.CompositeColumnValueFilter
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {filter.proto.CompositeColumnValueFilter} CompositeColumnValueFilter
             */
            CompositeColumnValueFilter.fromObject = function fromObject(object) {
                if (object instanceof $root.filter.proto.CompositeColumnValueFilter)
                    return object;
                var message = new $root.filter.proto.CompositeColumnValueFilter();
                switch (object.combinator) {
                case "LO_NOT":
                case 1:
                    message.combinator = 1;
                    break;
                case "LO_AND":
                case 2:
                    message.combinator = 2;
                    break;
                case "LO_OR":
                case 3:
                    message.combinator = 3;
                    break;
                }
                if (object.subFilters) {
                    if (!Array.isArray(object.subFilters))
                        throw TypeError(".filter.proto.CompositeColumnValueFilter.subFilters: array expected");
                    message.subFilters = [];
                    for (var i = 0; i < object.subFilters.length; ++i) {
                        if (typeof object.subFilters[i] !== "object")
                            throw TypeError(".filter.proto.CompositeColumnValueFilter.subFilters: object expected");
                        message.subFilters[i] = $root.filter.proto.Filter.fromObject(object.subFilters[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a CompositeColumnValueFilter message. Also converts values to other types if specified.
             * @function toObject
             * @memberof filter.proto.CompositeColumnValueFilter
             * @static
             * @param {filter.proto.CompositeColumnValueFilter} message CompositeColumnValueFilter
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CompositeColumnValueFilter.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.subFilters = [];
                if (options.defaults)
                    object.combinator = options.enums === String ? "LO_NOT" : 1;
                if (message.combinator != null && message.hasOwnProperty("combinator"))
                    object.combinator = options.enums === String ? $root.filter.proto.LogicalOperator[message.combinator] : message.combinator;
                if (message.subFilters && message.subFilters.length) {
                    object.subFilters = [];
                    for (var j = 0; j < message.subFilters.length; ++j)
                        object.subFilters[j] = $root.filter.proto.Filter.toObject(message.subFilters[j], options);
                }
                return object;
            };

            /**
             * Converts this CompositeColumnValueFilter to JSON.
             * @function toJSON
             * @memberof filter.proto.CompositeColumnValueFilter
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CompositeColumnValueFilter.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CompositeColumnValueFilter;
        })();

        proto.ColumnPaginationFilter = (function() {

            /**
             * Properties of a ColumnPaginationFilter.
             * @memberof filter.proto
             * @interface IColumnPaginationFilter
             * @property {number} offset ColumnPaginationFilter offset
             * @property {number} limit ColumnPaginationFilter limit
             */

            /**
             * Constructs a new ColumnPaginationFilter.
             * @memberof filter.proto
             * @classdesc Represents a ColumnPaginationFilter.
             * @implements IColumnPaginationFilter
             * @constructor
             * @param {filter.proto.IColumnPaginationFilter=} [properties] Properties to set
             */
            function ColumnPaginationFilter(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ColumnPaginationFilter offset.
             * @member {number} offset
             * @memberof filter.proto.ColumnPaginationFilter
             * @instance
             */
            ColumnPaginationFilter.prototype.offset = 0;

            /**
             * ColumnPaginationFilter limit.
             * @member {number} limit
             * @memberof filter.proto.ColumnPaginationFilter
             * @instance
             */
            ColumnPaginationFilter.prototype.limit = 0;

            /**
             * Creates a new ColumnPaginationFilter instance using the specified properties.
             * @function create
             * @memberof filter.proto.ColumnPaginationFilter
             * @static
             * @param {filter.proto.IColumnPaginationFilter=} [properties] Properties to set
             * @returns {filter.proto.ColumnPaginationFilter} ColumnPaginationFilter instance
             */
            ColumnPaginationFilter.create = function create(properties) {
                return new ColumnPaginationFilter(properties);
            };

            /**
             * Encodes the specified ColumnPaginationFilter message. Does not implicitly {@link filter.proto.ColumnPaginationFilter.verify|verify} messages.
             * @function encode
             * @memberof filter.proto.ColumnPaginationFilter
             * @static
             * @param {filter.proto.IColumnPaginationFilter} message ColumnPaginationFilter message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ColumnPaginationFilter.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.offset);
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.limit);
                return writer;
            };

            /**
             * Encodes the specified ColumnPaginationFilter message, length delimited. Does not implicitly {@link filter.proto.ColumnPaginationFilter.verify|verify} messages.
             * @function encodeDelimited
             * @memberof filter.proto.ColumnPaginationFilter
             * @static
             * @param {filter.proto.IColumnPaginationFilter} message ColumnPaginationFilter message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ColumnPaginationFilter.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ColumnPaginationFilter message from the specified reader or buffer.
             * @function decode
             * @memberof filter.proto.ColumnPaginationFilter
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {filter.proto.ColumnPaginationFilter} ColumnPaginationFilter
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ColumnPaginationFilter.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.filter.proto.ColumnPaginationFilter();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.offset = reader.int32();
                        break;
                    case 2:
                        message.limit = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("offset"))
                    throw $util.ProtocolError("missing required 'offset'", { instance: message });
                if (!message.hasOwnProperty("limit"))
                    throw $util.ProtocolError("missing required 'limit'", { instance: message });
                return message;
            };

            /**
             * Decodes a ColumnPaginationFilter message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof filter.proto.ColumnPaginationFilter
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {filter.proto.ColumnPaginationFilter} ColumnPaginationFilter
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ColumnPaginationFilter.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ColumnPaginationFilter message.
             * @function verify
             * @memberof filter.proto.ColumnPaginationFilter
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ColumnPaginationFilter.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.offset))
                    return "offset: integer expected";
                if (!$util.isInteger(message.limit))
                    return "limit: integer expected";
                return null;
            };

            /**
             * Creates a ColumnPaginationFilter message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof filter.proto.ColumnPaginationFilter
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {filter.proto.ColumnPaginationFilter} ColumnPaginationFilter
             */
            ColumnPaginationFilter.fromObject = function fromObject(object) {
                if (object instanceof $root.filter.proto.ColumnPaginationFilter)
                    return object;
                var message = new $root.filter.proto.ColumnPaginationFilter();
                if (object.offset != null)
                    message.offset = object.offset | 0;
                if (object.limit != null)
                    message.limit = object.limit | 0;
                return message;
            };

            /**
             * Creates a plain object from a ColumnPaginationFilter message. Also converts values to other types if specified.
             * @function toObject
             * @memberof filter.proto.ColumnPaginationFilter
             * @static
             * @param {filter.proto.ColumnPaginationFilter} message ColumnPaginationFilter
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ColumnPaginationFilter.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.offset = 0;
                    object.limit = 0;
                }
                if (message.offset != null && message.hasOwnProperty("offset"))
                    object.offset = message.offset;
                if (message.limit != null && message.hasOwnProperty("limit"))
                    object.limit = message.limit;
                return object;
            };

            /**
             * Converts this ColumnPaginationFilter to JSON.
             * @function toJSON
             * @memberof filter.proto.ColumnPaginationFilter
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ColumnPaginationFilter.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ColumnPaginationFilter;
        })();

        proto.Filter = (function() {

            /**
             * Properties of a Filter.
             * @memberof filter.proto
             * @interface IFilter
             * @property {filter.proto.FilterType} type Filter type
             * @property {Uint8Array} filter Filter filter
             */

            /**
             * Constructs a new Filter.
             * @memberof filter.proto
             * @classdesc Represents a Filter.
             * @implements IFilter
             * @constructor
             * @param {filter.proto.IFilter=} [properties] Properties to set
             */
            function Filter(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Filter type.
             * @member {filter.proto.FilterType} type
             * @memberof filter.proto.Filter
             * @instance
             */
            Filter.prototype.type = 1;

            /**
             * Filter filter.
             * @member {Uint8Array} filter
             * @memberof filter.proto.Filter
             * @instance
             */
            Filter.prototype.filter = $util.newBuffer([]);

            /**
             * Creates a new Filter instance using the specified properties.
             * @function create
             * @memberof filter.proto.Filter
             * @static
             * @param {filter.proto.IFilter=} [properties] Properties to set
             * @returns {filter.proto.Filter} Filter instance
             */
            Filter.create = function create(properties) {
                return new Filter(properties);
            };

            /**
             * Encodes the specified Filter message. Does not implicitly {@link filter.proto.Filter.verify|verify} messages.
             * @function encode
             * @memberof filter.proto.Filter
             * @static
             * @param {filter.proto.IFilter} message Filter message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Filter.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.filter);
                return writer;
            };

            /**
             * Encodes the specified Filter message, length delimited. Does not implicitly {@link filter.proto.Filter.verify|verify} messages.
             * @function encodeDelimited
             * @memberof filter.proto.Filter
             * @static
             * @param {filter.proto.IFilter} message Filter message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Filter.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Filter message from the specified reader or buffer.
             * @function decode
             * @memberof filter.proto.Filter
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {filter.proto.Filter} Filter
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Filter.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.filter.proto.Filter();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.filter = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("type"))
                    throw $util.ProtocolError("missing required 'type'", { instance: message });
                if (!message.hasOwnProperty("filter"))
                    throw $util.ProtocolError("missing required 'filter'", { instance: message });
                return message;
            };

            /**
             * Decodes a Filter message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof filter.proto.Filter
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {filter.proto.Filter} Filter
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Filter.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Filter message.
             * @function verify
             * @memberof filter.proto.Filter
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Filter.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 1:
                case 2:
                case 3:
                    break;
                }
                if (!(message.filter && typeof message.filter.length === "number" || $util.isString(message.filter)))
                    return "filter: buffer expected";
                return null;
            };

            /**
             * Creates a Filter message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof filter.proto.Filter
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {filter.proto.Filter} Filter
             */
            Filter.fromObject = function fromObject(object) {
                if (object instanceof $root.filter.proto.Filter)
                    return object;
                var message = new $root.filter.proto.Filter();
                switch (object.type) {
                case "FT_SINGLE_COLUMN_VALUE":
                case 1:
                    message.type = 1;
                    break;
                case "FT_COMPOSITE_COLUMN_VALUE":
                case 2:
                    message.type = 2;
                    break;
                case "FT_COLUMN_PAGINATION":
                case 3:
                    message.type = 3;
                    break;
                }
                if (object.filter != null)
                    if (typeof object.filter === "string")
                        $util.base64.decode(object.filter, message.filter = $util.newBuffer($util.base64.length(object.filter)), 0);
                    else if (object.filter.length)
                        message.filter = object.filter;
                return message;
            };

            /**
             * Creates a plain object from a Filter message. Also converts values to other types if specified.
             * @function toObject
             * @memberof filter.proto.Filter
             * @static
             * @param {filter.proto.Filter} message Filter
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Filter.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type = options.enums === String ? "FT_SINGLE_COLUMN_VALUE" : 1;
                    if (options.bytes === String)
                        object.filter = "";
                    else {
                        object.filter = [];
                        if (options.bytes !== Array)
                            object.filter = $util.newBuffer(object.filter);
                    }
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.filter.proto.FilterType[message.type] : message.type;
                if (message.filter != null && message.hasOwnProperty("filter"))
                    object.filter = options.bytes === String ? $util.base64.encode(message.filter, 0, message.filter.length) : options.bytes === Array ? Array.prototype.slice.call(message.filter) : message.filter;
                return object;
            };

            /**
             * Converts this Filter to JSON.
             * @function toJSON
             * @memberof filter.proto.Filter
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Filter.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Filter;
        })();

        return proto;
    })();

    return filter;
})();

$root.search = (function() {

    /**
     * Namespace search.
     * @exports search
     * @namespace
     */
    var search = {};

    search.proto = (function() {

        /**
         * Namespace proto.
         * @memberof search
         * @namespace
         */
        var proto = {};

        /**
         * AggregationType enum.
         * @name search.proto.AggregationType
         * @enum {number}
         * @property {number} AGG_AVG=1 AGG_AVG value
         * @property {number} AGG_MAX=2 AGG_MAX value
         * @property {number} AGG_MIN=3 AGG_MIN value
         * @property {number} AGG_SUM=4 AGG_SUM value
         * @property {number} AGG_COUNT=5 AGG_COUNT value
         * @property {number} AGG_DISTINCT_COUNT=6 AGG_DISTINCT_COUNT value
         * @property {number} AGG_TOP_ROWS=7 AGG_TOP_ROWS value
         * @property {number} AGG_PERCENTILES=8 AGG_PERCENTILES value
         */
        proto.AggregationType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "AGG_AVG"] = 1;
            values[valuesById[2] = "AGG_MAX"] = 2;
            values[valuesById[3] = "AGG_MIN"] = 3;
            values[valuesById[4] = "AGG_SUM"] = 4;
            values[valuesById[5] = "AGG_COUNT"] = 5;
            values[valuesById[6] = "AGG_DISTINCT_COUNT"] = 6;
            values[valuesById[7] = "AGG_TOP_ROWS"] = 7;
            values[valuesById[8] = "AGG_PERCENTILES"] = 8;
            return values;
        })();

        /**
         * GroupByType enum.
         * @name search.proto.GroupByType
         * @enum {number}
         * @property {number} GROUP_BY_FIELD=1 GROUP_BY_FIELD value
         * @property {number} GROUP_BY_RANGE=2 GROUP_BY_RANGE value
         * @property {number} GROUP_BY_FILTER=3 GROUP_BY_FILTER value
         * @property {number} GROUP_BY_GEO_DISTANCE=4 GROUP_BY_GEO_DISTANCE value
         * @property {number} GROUP_BY_HISTOGRAM=5 GROUP_BY_HISTOGRAM value
         * @property {number} GROUP_BY_DATE_HISTOGRAM=6 GROUP_BY_DATE_HISTOGRAM value
         * @property {number} GROUP_BY_GEO_GRID=7 GROUP_BY_GEO_GRID value
         * @property {number} GROUP_BY_COMPOSITE=8 GROUP_BY_COMPOSITE value
         */
        proto.GroupByType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "GROUP_BY_FIELD"] = 1;
            values[valuesById[2] = "GROUP_BY_RANGE"] = 2;
            values[valuesById[3] = "GROUP_BY_FILTER"] = 3;
            values[valuesById[4] = "GROUP_BY_GEO_DISTANCE"] = 4;
            values[valuesById[5] = "GROUP_BY_HISTOGRAM"] = 5;
            values[valuesById[6] = "GROUP_BY_DATE_HISTOGRAM"] = 6;
            values[valuesById[7] = "GROUP_BY_GEO_GRID"] = 7;
            values[valuesById[8] = "GROUP_BY_COMPOSITE"] = 8;
            return values;
        })();

        proto.Aggregation = (function() {

            /**
             * Properties of an Aggregation.
             * @memberof search.proto
             * @interface IAggregation
             * @property {string|null} [name] Aggregation name
             * @property {search.proto.AggregationType|null} [type] Aggregation type
             * @property {Uint8Array|null} [body] Aggregation body
             */

            /**
             * Constructs a new Aggregation.
             * @memberof search.proto
             * @classdesc Represents an Aggregation.
             * @implements IAggregation
             * @constructor
             * @param {search.proto.IAggregation=} [properties] Properties to set
             */
            function Aggregation(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Aggregation name.
             * @member {string} name
             * @memberof search.proto.Aggregation
             * @instance
             */
            Aggregation.prototype.name = "";

            /**
             * Aggregation type.
             * @member {search.proto.AggregationType} type
             * @memberof search.proto.Aggregation
             * @instance
             */
            Aggregation.prototype.type = 1;

            /**
             * Aggregation body.
             * @member {Uint8Array} body
             * @memberof search.proto.Aggregation
             * @instance
             */
            Aggregation.prototype.body = $util.newBuffer([]);

            /**
             * Creates a new Aggregation instance using the specified properties.
             * @function create
             * @memberof search.proto.Aggregation
             * @static
             * @param {search.proto.IAggregation=} [properties] Properties to set
             * @returns {search.proto.Aggregation} Aggregation instance
             */
            Aggregation.create = function create(properties) {
                return new Aggregation(properties);
            };

            /**
             * Encodes the specified Aggregation message. Does not implicitly {@link search.proto.Aggregation.verify|verify} messages.
             * @function encode
             * @memberof search.proto.Aggregation
             * @static
             * @param {search.proto.IAggregation} message Aggregation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Aggregation.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                if (message.body != null && Object.hasOwnProperty.call(message, "body"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.body);
                return writer;
            };

            /**
             * Encodes the specified Aggregation message, length delimited. Does not implicitly {@link search.proto.Aggregation.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.Aggregation
             * @static
             * @param {search.proto.IAggregation} message Aggregation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Aggregation.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Aggregation message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.Aggregation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.Aggregation} Aggregation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Aggregation.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.Aggregation();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.type = reader.int32();
                        break;
                    case 3:
                        message.body = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Aggregation message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.Aggregation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.Aggregation} Aggregation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Aggregation.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Aggregation message.
             * @function verify
             * @memberof search.proto.Aggregation
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Aggregation.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                        break;
                    }
                if (message.body != null && message.hasOwnProperty("body"))
                    if (!(message.body && typeof message.body.length === "number" || $util.isString(message.body)))
                        return "body: buffer expected";
                return null;
            };

            /**
             * Creates an Aggregation message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.Aggregation
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.Aggregation} Aggregation
             */
            Aggregation.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.Aggregation)
                    return object;
                var message = new $root.search.proto.Aggregation();
                if (object.name != null)
                    message.name = String(object.name);
                switch (object.type) {
                case "AGG_AVG":
                case 1:
                    message.type = 1;
                    break;
                case "AGG_MAX":
                case 2:
                    message.type = 2;
                    break;
                case "AGG_MIN":
                case 3:
                    message.type = 3;
                    break;
                case "AGG_SUM":
                case 4:
                    message.type = 4;
                    break;
                case "AGG_COUNT":
                case 5:
                    message.type = 5;
                    break;
                case "AGG_DISTINCT_COUNT":
                case 6:
                    message.type = 6;
                    break;
                case "AGG_TOP_ROWS":
                case 7:
                    message.type = 7;
                    break;
                case "AGG_PERCENTILES":
                case 8:
                    message.type = 8;
                    break;
                }
                if (object.body != null)
                    if (typeof object.body === "string")
                        $util.base64.decode(object.body, message.body = $util.newBuffer($util.base64.length(object.body)), 0);
                    else if (object.body.length)
                        message.body = object.body;
                return message;
            };

            /**
             * Creates a plain object from an Aggregation message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.Aggregation
             * @static
             * @param {search.proto.Aggregation} message Aggregation
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Aggregation.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.type = options.enums === String ? "AGG_AVG" : 1;
                    if (options.bytes === String)
                        object.body = "";
                    else {
                        object.body = [];
                        if (options.bytes !== Array)
                            object.body = $util.newBuffer(object.body);
                    }
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.search.proto.AggregationType[message.type] : message.type;
                if (message.body != null && message.hasOwnProperty("body"))
                    object.body = options.bytes === String ? $util.base64.encode(message.body, 0, message.body.length) : options.bytes === Array ? Array.prototype.slice.call(message.body) : message.body;
                return object;
            };

            /**
             * Converts this Aggregation to JSON.
             * @function toJSON
             * @memberof search.proto.Aggregation
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Aggregation.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Aggregation;
        })();

        proto.Aggregations = (function() {

            /**
             * Properties of an Aggregations.
             * @memberof search.proto
             * @interface IAggregations
             * @property {Array.<search.proto.IAggregation>|null} [aggs] Aggregations aggs
             */

            /**
             * Constructs a new Aggregations.
             * @memberof search.proto
             * @classdesc Represents an Aggregations.
             * @implements IAggregations
             * @constructor
             * @param {search.proto.IAggregations=} [properties] Properties to set
             */
            function Aggregations(properties) {
                this.aggs = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Aggregations aggs.
             * @member {Array.<search.proto.IAggregation>} aggs
             * @memberof search.proto.Aggregations
             * @instance
             */
            Aggregations.prototype.aggs = $util.emptyArray;

            /**
             * Creates a new Aggregations instance using the specified properties.
             * @function create
             * @memberof search.proto.Aggregations
             * @static
             * @param {search.proto.IAggregations=} [properties] Properties to set
             * @returns {search.proto.Aggregations} Aggregations instance
             */
            Aggregations.create = function create(properties) {
                return new Aggregations(properties);
            };

            /**
             * Encodes the specified Aggregations message. Does not implicitly {@link search.proto.Aggregations.verify|verify} messages.
             * @function encode
             * @memberof search.proto.Aggregations
             * @static
             * @param {search.proto.IAggregations} message Aggregations message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Aggregations.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.aggs != null && message.aggs.length)
                    for (var i = 0; i < message.aggs.length; ++i)
                        $root.search.proto.Aggregation.encode(message.aggs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Aggregations message, length delimited. Does not implicitly {@link search.proto.Aggregations.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.Aggregations
             * @static
             * @param {search.proto.IAggregations} message Aggregations message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Aggregations.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Aggregations message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.Aggregations
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.Aggregations} Aggregations
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Aggregations.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.Aggregations();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.aggs && message.aggs.length))
                            message.aggs = [];
                        message.aggs.push($root.search.proto.Aggregation.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Aggregations message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.Aggregations
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.Aggregations} Aggregations
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Aggregations.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Aggregations message.
             * @function verify
             * @memberof search.proto.Aggregations
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Aggregations.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.aggs != null && message.hasOwnProperty("aggs")) {
                    if (!Array.isArray(message.aggs))
                        return "aggs: array expected";
                    for (var i = 0; i < message.aggs.length; ++i) {
                        var error = $root.search.proto.Aggregation.verify(message.aggs[i]);
                        if (error)
                            return "aggs." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an Aggregations message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.Aggregations
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.Aggregations} Aggregations
             */
            Aggregations.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.Aggregations)
                    return object;
                var message = new $root.search.proto.Aggregations();
                if (object.aggs) {
                    if (!Array.isArray(object.aggs))
                        throw TypeError(".search.proto.Aggregations.aggs: array expected");
                    message.aggs = [];
                    for (var i = 0; i < object.aggs.length; ++i) {
                        if (typeof object.aggs[i] !== "object")
                            throw TypeError(".search.proto.Aggregations.aggs: object expected");
                        message.aggs[i] = $root.search.proto.Aggregation.fromObject(object.aggs[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an Aggregations message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.Aggregations
             * @static
             * @param {search.proto.Aggregations} message Aggregations
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Aggregations.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.aggs = [];
                if (message.aggs && message.aggs.length) {
                    object.aggs = [];
                    for (var j = 0; j < message.aggs.length; ++j)
                        object.aggs[j] = $root.search.proto.Aggregation.toObject(message.aggs[j], options);
                }
                return object;
            };

            /**
             * Converts this Aggregations to JSON.
             * @function toJSON
             * @memberof search.proto.Aggregations
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Aggregations.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Aggregations;
        })();

        proto.GroupBy = (function() {

            /**
             * Properties of a GroupBy.
             * @memberof search.proto
             * @interface IGroupBy
             * @property {string|null} [name] GroupBy name
             * @property {search.proto.GroupByType|null} [type] GroupBy type
             * @property {Uint8Array|null} [body] GroupBy body
             */

            /**
             * Constructs a new GroupBy.
             * @memberof search.proto
             * @classdesc Represents a GroupBy.
             * @implements IGroupBy
             * @constructor
             * @param {search.proto.IGroupBy=} [properties] Properties to set
             */
            function GroupBy(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupBy name.
             * @member {string} name
             * @memberof search.proto.GroupBy
             * @instance
             */
            GroupBy.prototype.name = "";

            /**
             * GroupBy type.
             * @member {search.proto.GroupByType} type
             * @memberof search.proto.GroupBy
             * @instance
             */
            GroupBy.prototype.type = 1;

            /**
             * GroupBy body.
             * @member {Uint8Array} body
             * @memberof search.proto.GroupBy
             * @instance
             */
            GroupBy.prototype.body = $util.newBuffer([]);

            /**
             * Creates a new GroupBy instance using the specified properties.
             * @function create
             * @memberof search.proto.GroupBy
             * @static
             * @param {search.proto.IGroupBy=} [properties] Properties to set
             * @returns {search.proto.GroupBy} GroupBy instance
             */
            GroupBy.create = function create(properties) {
                return new GroupBy(properties);
            };

            /**
             * Encodes the specified GroupBy message. Does not implicitly {@link search.proto.GroupBy.verify|verify} messages.
             * @function encode
             * @memberof search.proto.GroupBy
             * @static
             * @param {search.proto.IGroupBy} message GroupBy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupBy.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                if (message.body != null && Object.hasOwnProperty.call(message, "body"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.body);
                return writer;
            };

            /**
             * Encodes the specified GroupBy message, length delimited. Does not implicitly {@link search.proto.GroupBy.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.GroupBy
             * @static
             * @param {search.proto.IGroupBy} message GroupBy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupBy.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupBy message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.GroupBy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.GroupBy} GroupBy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupBy.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.GroupBy();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.type = reader.int32();
                        break;
                    case 3:
                        message.body = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupBy message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.GroupBy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.GroupBy} GroupBy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupBy.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupBy message.
             * @function verify
             * @memberof search.proto.GroupBy
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupBy.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                        break;
                    }
                if (message.body != null && message.hasOwnProperty("body"))
                    if (!(message.body && typeof message.body.length === "number" || $util.isString(message.body)))
                        return "body: buffer expected";
                return null;
            };

            /**
             * Creates a GroupBy message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.GroupBy
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.GroupBy} GroupBy
             */
            GroupBy.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.GroupBy)
                    return object;
                var message = new $root.search.proto.GroupBy();
                if (object.name != null)
                    message.name = String(object.name);
                switch (object.type) {
                case "GROUP_BY_FIELD":
                case 1:
                    message.type = 1;
                    break;
                case "GROUP_BY_RANGE":
                case 2:
                    message.type = 2;
                    break;
                case "GROUP_BY_FILTER":
                case 3:
                    message.type = 3;
                    break;
                case "GROUP_BY_GEO_DISTANCE":
                case 4:
                    message.type = 4;
                    break;
                case "GROUP_BY_HISTOGRAM":
                case 5:
                    message.type = 5;
                    break;
                case "GROUP_BY_DATE_HISTOGRAM":
                case 6:
                    message.type = 6;
                    break;
                case "GROUP_BY_GEO_GRID":
                case 7:
                    message.type = 7;
                    break;
                case "GROUP_BY_COMPOSITE":
                case 8:
                    message.type = 8;
                    break;
                }
                if (object.body != null)
                    if (typeof object.body === "string")
                        $util.base64.decode(object.body, message.body = $util.newBuffer($util.base64.length(object.body)), 0);
                    else if (object.body.length)
                        message.body = object.body;
                return message;
            };

            /**
             * Creates a plain object from a GroupBy message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.GroupBy
             * @static
             * @param {search.proto.GroupBy} message GroupBy
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupBy.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.type = options.enums === String ? "GROUP_BY_FIELD" : 1;
                    if (options.bytes === String)
                        object.body = "";
                    else {
                        object.body = [];
                        if (options.bytes !== Array)
                            object.body = $util.newBuffer(object.body);
                    }
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.search.proto.GroupByType[message.type] : message.type;
                if (message.body != null && message.hasOwnProperty("body"))
                    object.body = options.bytes === String ? $util.base64.encode(message.body, 0, message.body.length) : options.bytes === Array ? Array.prototype.slice.call(message.body) : message.body;
                return object;
            };

            /**
             * Converts this GroupBy to JSON.
             * @function toJSON
             * @memberof search.proto.GroupBy
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupBy.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GroupBy;
        })();

        proto.GroupBys = (function() {

            /**
             * Properties of a GroupBys.
             * @memberof search.proto
             * @interface IGroupBys
             * @property {Array.<search.proto.IGroupBy>|null} [groupBys] GroupBys groupBys
             */

            /**
             * Constructs a new GroupBys.
             * @memberof search.proto
             * @classdesc Represents a GroupBys.
             * @implements IGroupBys
             * @constructor
             * @param {search.proto.IGroupBys=} [properties] Properties to set
             */
            function GroupBys(properties) {
                this.groupBys = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupBys groupBys.
             * @member {Array.<search.proto.IGroupBy>} groupBys
             * @memberof search.proto.GroupBys
             * @instance
             */
            GroupBys.prototype.groupBys = $util.emptyArray;

            /**
             * Creates a new GroupBys instance using the specified properties.
             * @function create
             * @memberof search.proto.GroupBys
             * @static
             * @param {search.proto.IGroupBys=} [properties] Properties to set
             * @returns {search.proto.GroupBys} GroupBys instance
             */
            GroupBys.create = function create(properties) {
                return new GroupBys(properties);
            };

            /**
             * Encodes the specified GroupBys message. Does not implicitly {@link search.proto.GroupBys.verify|verify} messages.
             * @function encode
             * @memberof search.proto.GroupBys
             * @static
             * @param {search.proto.IGroupBys} message GroupBys message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupBys.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupBys != null && message.groupBys.length)
                    for (var i = 0; i < message.groupBys.length; ++i)
                        $root.search.proto.GroupBy.encode(message.groupBys[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GroupBys message, length delimited. Does not implicitly {@link search.proto.GroupBys.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.GroupBys
             * @static
             * @param {search.proto.IGroupBys} message GroupBys message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupBys.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupBys message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.GroupBys
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.GroupBys} GroupBys
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupBys.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.GroupBys();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.groupBys && message.groupBys.length))
                            message.groupBys = [];
                        message.groupBys.push($root.search.proto.GroupBy.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupBys message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.GroupBys
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.GroupBys} GroupBys
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupBys.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupBys message.
             * @function verify
             * @memberof search.proto.GroupBys
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupBys.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupBys != null && message.hasOwnProperty("groupBys")) {
                    if (!Array.isArray(message.groupBys))
                        return "groupBys: array expected";
                    for (var i = 0; i < message.groupBys.length; ++i) {
                        var error = $root.search.proto.GroupBy.verify(message.groupBys[i]);
                        if (error)
                            return "groupBys." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GroupBys message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.GroupBys
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.GroupBys} GroupBys
             */
            GroupBys.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.GroupBys)
                    return object;
                var message = new $root.search.proto.GroupBys();
                if (object.groupBys) {
                    if (!Array.isArray(object.groupBys))
                        throw TypeError(".search.proto.GroupBys.groupBys: array expected");
                    message.groupBys = [];
                    for (var i = 0; i < object.groupBys.length; ++i) {
                        if (typeof object.groupBys[i] !== "object")
                            throw TypeError(".search.proto.GroupBys.groupBys: object expected");
                        message.groupBys[i] = $root.search.proto.GroupBy.fromObject(object.groupBys[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GroupBys message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.GroupBys
             * @static
             * @param {search.proto.GroupBys} message GroupBys
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupBys.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.groupBys = [];
                if (message.groupBys && message.groupBys.length) {
                    object.groupBys = [];
                    for (var j = 0; j < message.groupBys.length; ++j)
                        object.groupBys[j] = $root.search.proto.GroupBy.toObject(message.groupBys[j], options);
                }
                return object;
            };

            /**
             * Converts this GroupBys to JSON.
             * @function toJSON
             * @memberof search.proto.GroupBys
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupBys.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GroupBys;
        })();

        proto.AvgAggregation = (function() {

            /**
             * Properties of an AvgAggregation.
             * @memberof search.proto
             * @interface IAvgAggregation
             * @property {string|null} [fieldName] AvgAggregation fieldName
             * @property {Uint8Array|null} [missing] AvgAggregation missing
             */

            /**
             * Constructs a new AvgAggregation.
             * @memberof search.proto
             * @classdesc Represents an AvgAggregation.
             * @implements IAvgAggregation
             * @constructor
             * @param {search.proto.IAvgAggregation=} [properties] Properties to set
             */
            function AvgAggregation(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AvgAggregation fieldName.
             * @member {string} fieldName
             * @memberof search.proto.AvgAggregation
             * @instance
             */
            AvgAggregation.prototype.fieldName = "";

            /**
             * AvgAggregation missing.
             * @member {Uint8Array} missing
             * @memberof search.proto.AvgAggregation
             * @instance
             */
            AvgAggregation.prototype.missing = $util.newBuffer([]);

            /**
             * Creates a new AvgAggregation instance using the specified properties.
             * @function create
             * @memberof search.proto.AvgAggregation
             * @static
             * @param {search.proto.IAvgAggregation=} [properties] Properties to set
             * @returns {search.proto.AvgAggregation} AvgAggregation instance
             */
            AvgAggregation.create = function create(properties) {
                return new AvgAggregation(properties);
            };

            /**
             * Encodes the specified AvgAggregation message. Does not implicitly {@link search.proto.AvgAggregation.verify|verify} messages.
             * @function encode
             * @memberof search.proto.AvgAggregation
             * @static
             * @param {search.proto.IAvgAggregation} message AvgAggregation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AvgAggregation.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fieldName != null && Object.hasOwnProperty.call(message, "fieldName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fieldName);
                if (message.missing != null && Object.hasOwnProperty.call(message, "missing"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.missing);
                return writer;
            };

            /**
             * Encodes the specified AvgAggregation message, length delimited. Does not implicitly {@link search.proto.AvgAggregation.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.AvgAggregation
             * @static
             * @param {search.proto.IAvgAggregation} message AvgAggregation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AvgAggregation.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AvgAggregation message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.AvgAggregation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.AvgAggregation} AvgAggregation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AvgAggregation.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.AvgAggregation();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fieldName = reader.string();
                        break;
                    case 2:
                        message.missing = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AvgAggregation message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.AvgAggregation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.AvgAggregation} AvgAggregation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AvgAggregation.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AvgAggregation message.
             * @function verify
             * @memberof search.proto.AvgAggregation
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AvgAggregation.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    if (!$util.isString(message.fieldName))
                        return "fieldName: string expected";
                if (message.missing != null && message.hasOwnProperty("missing"))
                    if (!(message.missing && typeof message.missing.length === "number" || $util.isString(message.missing)))
                        return "missing: buffer expected";
                return null;
            };

            /**
             * Creates an AvgAggregation message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.AvgAggregation
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.AvgAggregation} AvgAggregation
             */
            AvgAggregation.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.AvgAggregation)
                    return object;
                var message = new $root.search.proto.AvgAggregation();
                if (object.fieldName != null)
                    message.fieldName = String(object.fieldName);
                if (object.missing != null)
                    if (typeof object.missing === "string")
                        $util.base64.decode(object.missing, message.missing = $util.newBuffer($util.base64.length(object.missing)), 0);
                    else if (object.missing.length)
                        message.missing = object.missing;
                return message;
            };

            /**
             * Creates a plain object from an AvgAggregation message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.AvgAggregation
             * @static
             * @param {search.proto.AvgAggregation} message AvgAggregation
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AvgAggregation.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.fieldName = "";
                    if (options.bytes === String)
                        object.missing = "";
                    else {
                        object.missing = [];
                        if (options.bytes !== Array)
                            object.missing = $util.newBuffer(object.missing);
                    }
                }
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    object.fieldName = message.fieldName;
                if (message.missing != null && message.hasOwnProperty("missing"))
                    object.missing = options.bytes === String ? $util.base64.encode(message.missing, 0, message.missing.length) : options.bytes === Array ? Array.prototype.slice.call(message.missing) : message.missing;
                return object;
            };

            /**
             * Converts this AvgAggregation to JSON.
             * @function toJSON
             * @memberof search.proto.AvgAggregation
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AvgAggregation.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AvgAggregation;
        })();

        proto.MaxAggregation = (function() {

            /**
             * Properties of a MaxAggregation.
             * @memberof search.proto
             * @interface IMaxAggregation
             * @property {string|null} [fieldName] MaxAggregation fieldName
             * @property {Uint8Array|null} [missing] MaxAggregation missing
             */

            /**
             * Constructs a new MaxAggregation.
             * @memberof search.proto
             * @classdesc Represents a MaxAggregation.
             * @implements IMaxAggregation
             * @constructor
             * @param {search.proto.IMaxAggregation=} [properties] Properties to set
             */
            function MaxAggregation(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MaxAggregation fieldName.
             * @member {string} fieldName
             * @memberof search.proto.MaxAggregation
             * @instance
             */
            MaxAggregation.prototype.fieldName = "";

            /**
             * MaxAggregation missing.
             * @member {Uint8Array} missing
             * @memberof search.proto.MaxAggregation
             * @instance
             */
            MaxAggregation.prototype.missing = $util.newBuffer([]);

            /**
             * Creates a new MaxAggregation instance using the specified properties.
             * @function create
             * @memberof search.proto.MaxAggregation
             * @static
             * @param {search.proto.IMaxAggregation=} [properties] Properties to set
             * @returns {search.proto.MaxAggregation} MaxAggregation instance
             */
            MaxAggregation.create = function create(properties) {
                return new MaxAggregation(properties);
            };

            /**
             * Encodes the specified MaxAggregation message. Does not implicitly {@link search.proto.MaxAggregation.verify|verify} messages.
             * @function encode
             * @memberof search.proto.MaxAggregation
             * @static
             * @param {search.proto.IMaxAggregation} message MaxAggregation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MaxAggregation.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fieldName != null && Object.hasOwnProperty.call(message, "fieldName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fieldName);
                if (message.missing != null && Object.hasOwnProperty.call(message, "missing"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.missing);
                return writer;
            };

            /**
             * Encodes the specified MaxAggregation message, length delimited. Does not implicitly {@link search.proto.MaxAggregation.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.MaxAggregation
             * @static
             * @param {search.proto.IMaxAggregation} message MaxAggregation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MaxAggregation.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MaxAggregation message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.MaxAggregation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.MaxAggregation} MaxAggregation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MaxAggregation.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.MaxAggregation();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fieldName = reader.string();
                        break;
                    case 2:
                        message.missing = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MaxAggregation message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.MaxAggregation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.MaxAggregation} MaxAggregation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MaxAggregation.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MaxAggregation message.
             * @function verify
             * @memberof search.proto.MaxAggregation
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MaxAggregation.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    if (!$util.isString(message.fieldName))
                        return "fieldName: string expected";
                if (message.missing != null && message.hasOwnProperty("missing"))
                    if (!(message.missing && typeof message.missing.length === "number" || $util.isString(message.missing)))
                        return "missing: buffer expected";
                return null;
            };

            /**
             * Creates a MaxAggregation message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.MaxAggregation
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.MaxAggregation} MaxAggregation
             */
            MaxAggregation.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.MaxAggregation)
                    return object;
                var message = new $root.search.proto.MaxAggregation();
                if (object.fieldName != null)
                    message.fieldName = String(object.fieldName);
                if (object.missing != null)
                    if (typeof object.missing === "string")
                        $util.base64.decode(object.missing, message.missing = $util.newBuffer($util.base64.length(object.missing)), 0);
                    else if (object.missing.length)
                        message.missing = object.missing;
                return message;
            };

            /**
             * Creates a plain object from a MaxAggregation message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.MaxAggregation
             * @static
             * @param {search.proto.MaxAggregation} message MaxAggregation
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MaxAggregation.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.fieldName = "";
                    if (options.bytes === String)
                        object.missing = "";
                    else {
                        object.missing = [];
                        if (options.bytes !== Array)
                            object.missing = $util.newBuffer(object.missing);
                    }
                }
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    object.fieldName = message.fieldName;
                if (message.missing != null && message.hasOwnProperty("missing"))
                    object.missing = options.bytes === String ? $util.base64.encode(message.missing, 0, message.missing.length) : options.bytes === Array ? Array.prototype.slice.call(message.missing) : message.missing;
                return object;
            };

            /**
             * Converts this MaxAggregation to JSON.
             * @function toJSON
             * @memberof search.proto.MaxAggregation
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MaxAggregation.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MaxAggregation;
        })();

        proto.MinAggregation = (function() {

            /**
             * Properties of a MinAggregation.
             * @memberof search.proto
             * @interface IMinAggregation
             * @property {string|null} [fieldName] MinAggregation fieldName
             * @property {Uint8Array|null} [missing] MinAggregation missing
             */

            /**
             * Constructs a new MinAggregation.
             * @memberof search.proto
             * @classdesc Represents a MinAggregation.
             * @implements IMinAggregation
             * @constructor
             * @param {search.proto.IMinAggregation=} [properties] Properties to set
             */
            function MinAggregation(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MinAggregation fieldName.
             * @member {string} fieldName
             * @memberof search.proto.MinAggregation
             * @instance
             */
            MinAggregation.prototype.fieldName = "";

            /**
             * MinAggregation missing.
             * @member {Uint8Array} missing
             * @memberof search.proto.MinAggregation
             * @instance
             */
            MinAggregation.prototype.missing = $util.newBuffer([]);

            /**
             * Creates a new MinAggregation instance using the specified properties.
             * @function create
             * @memberof search.proto.MinAggregation
             * @static
             * @param {search.proto.IMinAggregation=} [properties] Properties to set
             * @returns {search.proto.MinAggregation} MinAggregation instance
             */
            MinAggregation.create = function create(properties) {
                return new MinAggregation(properties);
            };

            /**
             * Encodes the specified MinAggregation message. Does not implicitly {@link search.proto.MinAggregation.verify|verify} messages.
             * @function encode
             * @memberof search.proto.MinAggregation
             * @static
             * @param {search.proto.IMinAggregation} message MinAggregation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MinAggregation.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fieldName != null && Object.hasOwnProperty.call(message, "fieldName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fieldName);
                if (message.missing != null && Object.hasOwnProperty.call(message, "missing"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.missing);
                return writer;
            };

            /**
             * Encodes the specified MinAggregation message, length delimited. Does not implicitly {@link search.proto.MinAggregation.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.MinAggregation
             * @static
             * @param {search.proto.IMinAggregation} message MinAggregation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MinAggregation.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MinAggregation message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.MinAggregation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.MinAggregation} MinAggregation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MinAggregation.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.MinAggregation();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fieldName = reader.string();
                        break;
                    case 2:
                        message.missing = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MinAggregation message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.MinAggregation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.MinAggregation} MinAggregation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MinAggregation.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MinAggregation message.
             * @function verify
             * @memberof search.proto.MinAggregation
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MinAggregation.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    if (!$util.isString(message.fieldName))
                        return "fieldName: string expected";
                if (message.missing != null && message.hasOwnProperty("missing"))
                    if (!(message.missing && typeof message.missing.length === "number" || $util.isString(message.missing)))
                        return "missing: buffer expected";
                return null;
            };

            /**
             * Creates a MinAggregation message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.MinAggregation
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.MinAggregation} MinAggregation
             */
            MinAggregation.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.MinAggregation)
                    return object;
                var message = new $root.search.proto.MinAggregation();
                if (object.fieldName != null)
                    message.fieldName = String(object.fieldName);
                if (object.missing != null)
                    if (typeof object.missing === "string")
                        $util.base64.decode(object.missing, message.missing = $util.newBuffer($util.base64.length(object.missing)), 0);
                    else if (object.missing.length)
                        message.missing = object.missing;
                return message;
            };

            /**
             * Creates a plain object from a MinAggregation message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.MinAggregation
             * @static
             * @param {search.proto.MinAggregation} message MinAggregation
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MinAggregation.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.fieldName = "";
                    if (options.bytes === String)
                        object.missing = "";
                    else {
                        object.missing = [];
                        if (options.bytes !== Array)
                            object.missing = $util.newBuffer(object.missing);
                    }
                }
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    object.fieldName = message.fieldName;
                if (message.missing != null && message.hasOwnProperty("missing"))
                    object.missing = options.bytes === String ? $util.base64.encode(message.missing, 0, message.missing.length) : options.bytes === Array ? Array.prototype.slice.call(message.missing) : message.missing;
                return object;
            };

            /**
             * Converts this MinAggregation to JSON.
             * @function toJSON
             * @memberof search.proto.MinAggregation
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MinAggregation.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MinAggregation;
        })();

        proto.SumAggregation = (function() {

            /**
             * Properties of a SumAggregation.
             * @memberof search.proto
             * @interface ISumAggregation
             * @property {string|null} [fieldName] SumAggregation fieldName
             * @property {Uint8Array|null} [missing] SumAggregation missing
             */

            /**
             * Constructs a new SumAggregation.
             * @memberof search.proto
             * @classdesc Represents a SumAggregation.
             * @implements ISumAggregation
             * @constructor
             * @param {search.proto.ISumAggregation=} [properties] Properties to set
             */
            function SumAggregation(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SumAggregation fieldName.
             * @member {string} fieldName
             * @memberof search.proto.SumAggregation
             * @instance
             */
            SumAggregation.prototype.fieldName = "";

            /**
             * SumAggregation missing.
             * @member {Uint8Array} missing
             * @memberof search.proto.SumAggregation
             * @instance
             */
            SumAggregation.prototype.missing = $util.newBuffer([]);

            /**
             * Creates a new SumAggregation instance using the specified properties.
             * @function create
             * @memberof search.proto.SumAggregation
             * @static
             * @param {search.proto.ISumAggregation=} [properties] Properties to set
             * @returns {search.proto.SumAggregation} SumAggregation instance
             */
            SumAggregation.create = function create(properties) {
                return new SumAggregation(properties);
            };

            /**
             * Encodes the specified SumAggregation message. Does not implicitly {@link search.proto.SumAggregation.verify|verify} messages.
             * @function encode
             * @memberof search.proto.SumAggregation
             * @static
             * @param {search.proto.ISumAggregation} message SumAggregation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SumAggregation.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fieldName != null && Object.hasOwnProperty.call(message, "fieldName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fieldName);
                if (message.missing != null && Object.hasOwnProperty.call(message, "missing"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.missing);
                return writer;
            };

            /**
             * Encodes the specified SumAggregation message, length delimited. Does not implicitly {@link search.proto.SumAggregation.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.SumAggregation
             * @static
             * @param {search.proto.ISumAggregation} message SumAggregation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SumAggregation.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SumAggregation message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.SumAggregation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.SumAggregation} SumAggregation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SumAggregation.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.SumAggregation();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fieldName = reader.string();
                        break;
                    case 2:
                        message.missing = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SumAggregation message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.SumAggregation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.SumAggregation} SumAggregation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SumAggregation.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SumAggregation message.
             * @function verify
             * @memberof search.proto.SumAggregation
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SumAggregation.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    if (!$util.isString(message.fieldName))
                        return "fieldName: string expected";
                if (message.missing != null && message.hasOwnProperty("missing"))
                    if (!(message.missing && typeof message.missing.length === "number" || $util.isString(message.missing)))
                        return "missing: buffer expected";
                return null;
            };

            /**
             * Creates a SumAggregation message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.SumAggregation
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.SumAggregation} SumAggregation
             */
            SumAggregation.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.SumAggregation)
                    return object;
                var message = new $root.search.proto.SumAggregation();
                if (object.fieldName != null)
                    message.fieldName = String(object.fieldName);
                if (object.missing != null)
                    if (typeof object.missing === "string")
                        $util.base64.decode(object.missing, message.missing = $util.newBuffer($util.base64.length(object.missing)), 0);
                    else if (object.missing.length)
                        message.missing = object.missing;
                return message;
            };

            /**
             * Creates a plain object from a SumAggregation message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.SumAggregation
             * @static
             * @param {search.proto.SumAggregation} message SumAggregation
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SumAggregation.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.fieldName = "";
                    if (options.bytes === String)
                        object.missing = "";
                    else {
                        object.missing = [];
                        if (options.bytes !== Array)
                            object.missing = $util.newBuffer(object.missing);
                    }
                }
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    object.fieldName = message.fieldName;
                if (message.missing != null && message.hasOwnProperty("missing"))
                    object.missing = options.bytes === String ? $util.base64.encode(message.missing, 0, message.missing.length) : options.bytes === Array ? Array.prototype.slice.call(message.missing) : message.missing;
                return object;
            };

            /**
             * Converts this SumAggregation to JSON.
             * @function toJSON
             * @memberof search.proto.SumAggregation
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SumAggregation.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SumAggregation;
        })();

        proto.CountAggregation = (function() {

            /**
             * Properties of a CountAggregation.
             * @memberof search.proto
             * @interface ICountAggregation
             * @property {string|null} [fieldName] CountAggregation fieldName
             */

            /**
             * Constructs a new CountAggregation.
             * @memberof search.proto
             * @classdesc Represents a CountAggregation.
             * @implements ICountAggregation
             * @constructor
             * @param {search.proto.ICountAggregation=} [properties] Properties to set
             */
            function CountAggregation(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CountAggregation fieldName.
             * @member {string} fieldName
             * @memberof search.proto.CountAggregation
             * @instance
             */
            CountAggregation.prototype.fieldName = "";

            /**
             * Creates a new CountAggregation instance using the specified properties.
             * @function create
             * @memberof search.proto.CountAggregation
             * @static
             * @param {search.proto.ICountAggregation=} [properties] Properties to set
             * @returns {search.proto.CountAggregation} CountAggregation instance
             */
            CountAggregation.create = function create(properties) {
                return new CountAggregation(properties);
            };

            /**
             * Encodes the specified CountAggregation message. Does not implicitly {@link search.proto.CountAggregation.verify|verify} messages.
             * @function encode
             * @memberof search.proto.CountAggregation
             * @static
             * @param {search.proto.ICountAggregation} message CountAggregation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CountAggregation.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fieldName != null && Object.hasOwnProperty.call(message, "fieldName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fieldName);
                return writer;
            };

            /**
             * Encodes the specified CountAggregation message, length delimited. Does not implicitly {@link search.proto.CountAggregation.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.CountAggregation
             * @static
             * @param {search.proto.ICountAggregation} message CountAggregation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CountAggregation.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CountAggregation message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.CountAggregation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.CountAggregation} CountAggregation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CountAggregation.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.CountAggregation();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fieldName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CountAggregation message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.CountAggregation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.CountAggregation} CountAggregation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CountAggregation.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CountAggregation message.
             * @function verify
             * @memberof search.proto.CountAggregation
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CountAggregation.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    if (!$util.isString(message.fieldName))
                        return "fieldName: string expected";
                return null;
            };

            /**
             * Creates a CountAggregation message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.CountAggregation
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.CountAggregation} CountAggregation
             */
            CountAggregation.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.CountAggregation)
                    return object;
                var message = new $root.search.proto.CountAggregation();
                if (object.fieldName != null)
                    message.fieldName = String(object.fieldName);
                return message;
            };

            /**
             * Creates a plain object from a CountAggregation message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.CountAggregation
             * @static
             * @param {search.proto.CountAggregation} message CountAggregation
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CountAggregation.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.fieldName = "";
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    object.fieldName = message.fieldName;
                return object;
            };

            /**
             * Converts this CountAggregation to JSON.
             * @function toJSON
             * @memberof search.proto.CountAggregation
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CountAggregation.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CountAggregation;
        })();

        proto.DistinctCountAggregation = (function() {

            /**
             * Properties of a DistinctCountAggregation.
             * @memberof search.proto
             * @interface IDistinctCountAggregation
             * @property {string|null} [fieldName] DistinctCountAggregation fieldName
             * @property {Uint8Array|null} [missing] DistinctCountAggregation missing
             */

            /**
             * Constructs a new DistinctCountAggregation.
             * @memberof search.proto
             * @classdesc Represents a DistinctCountAggregation.
             * @implements IDistinctCountAggregation
             * @constructor
             * @param {search.proto.IDistinctCountAggregation=} [properties] Properties to set
             */
            function DistinctCountAggregation(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DistinctCountAggregation fieldName.
             * @member {string} fieldName
             * @memberof search.proto.DistinctCountAggregation
             * @instance
             */
            DistinctCountAggregation.prototype.fieldName = "";

            /**
             * DistinctCountAggregation missing.
             * @member {Uint8Array} missing
             * @memberof search.proto.DistinctCountAggregation
             * @instance
             */
            DistinctCountAggregation.prototype.missing = $util.newBuffer([]);

            /**
             * Creates a new DistinctCountAggregation instance using the specified properties.
             * @function create
             * @memberof search.proto.DistinctCountAggregation
             * @static
             * @param {search.proto.IDistinctCountAggregation=} [properties] Properties to set
             * @returns {search.proto.DistinctCountAggregation} DistinctCountAggregation instance
             */
            DistinctCountAggregation.create = function create(properties) {
                return new DistinctCountAggregation(properties);
            };

            /**
             * Encodes the specified DistinctCountAggregation message. Does not implicitly {@link search.proto.DistinctCountAggregation.verify|verify} messages.
             * @function encode
             * @memberof search.proto.DistinctCountAggregation
             * @static
             * @param {search.proto.IDistinctCountAggregation} message DistinctCountAggregation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DistinctCountAggregation.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fieldName != null && Object.hasOwnProperty.call(message, "fieldName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fieldName);
                if (message.missing != null && Object.hasOwnProperty.call(message, "missing"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.missing);
                return writer;
            };

            /**
             * Encodes the specified DistinctCountAggregation message, length delimited. Does not implicitly {@link search.proto.DistinctCountAggregation.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.DistinctCountAggregation
             * @static
             * @param {search.proto.IDistinctCountAggregation} message DistinctCountAggregation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DistinctCountAggregation.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DistinctCountAggregation message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.DistinctCountAggregation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.DistinctCountAggregation} DistinctCountAggregation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DistinctCountAggregation.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.DistinctCountAggregation();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fieldName = reader.string();
                        break;
                    case 2:
                        message.missing = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DistinctCountAggregation message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.DistinctCountAggregation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.DistinctCountAggregation} DistinctCountAggregation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DistinctCountAggregation.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DistinctCountAggregation message.
             * @function verify
             * @memberof search.proto.DistinctCountAggregation
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DistinctCountAggregation.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    if (!$util.isString(message.fieldName))
                        return "fieldName: string expected";
                if (message.missing != null && message.hasOwnProperty("missing"))
                    if (!(message.missing && typeof message.missing.length === "number" || $util.isString(message.missing)))
                        return "missing: buffer expected";
                return null;
            };

            /**
             * Creates a DistinctCountAggregation message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.DistinctCountAggregation
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.DistinctCountAggregation} DistinctCountAggregation
             */
            DistinctCountAggregation.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.DistinctCountAggregation)
                    return object;
                var message = new $root.search.proto.DistinctCountAggregation();
                if (object.fieldName != null)
                    message.fieldName = String(object.fieldName);
                if (object.missing != null)
                    if (typeof object.missing === "string")
                        $util.base64.decode(object.missing, message.missing = $util.newBuffer($util.base64.length(object.missing)), 0);
                    else if (object.missing.length)
                        message.missing = object.missing;
                return message;
            };

            /**
             * Creates a plain object from a DistinctCountAggregation message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.DistinctCountAggregation
             * @static
             * @param {search.proto.DistinctCountAggregation} message DistinctCountAggregation
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DistinctCountAggregation.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.fieldName = "";
                    if (options.bytes === String)
                        object.missing = "";
                    else {
                        object.missing = [];
                        if (options.bytes !== Array)
                            object.missing = $util.newBuffer(object.missing);
                    }
                }
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    object.fieldName = message.fieldName;
                if (message.missing != null && message.hasOwnProperty("missing"))
                    object.missing = options.bytes === String ? $util.base64.encode(message.missing, 0, message.missing.length) : options.bytes === Array ? Array.prototype.slice.call(message.missing) : message.missing;
                return object;
            };

            /**
             * Converts this DistinctCountAggregation to JSON.
             * @function toJSON
             * @memberof search.proto.DistinctCountAggregation
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DistinctCountAggregation.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DistinctCountAggregation;
        })();

        proto.TopRowsAggregation = (function() {

            /**
             * Properties of a TopRowsAggregation.
             * @memberof search.proto
             * @interface ITopRowsAggregation
             * @property {number|null} [limit] TopRowsAggregation limit
             * @property {search.proto.ISort|null} [sort] TopRowsAggregation sort
             */

            /**
             * Constructs a new TopRowsAggregation.
             * @memberof search.proto
             * @classdesc Represents a TopRowsAggregation.
             * @implements ITopRowsAggregation
             * @constructor
             * @param {search.proto.ITopRowsAggregation=} [properties] Properties to set
             */
            function TopRowsAggregation(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TopRowsAggregation limit.
             * @member {number} limit
             * @memberof search.proto.TopRowsAggregation
             * @instance
             */
            TopRowsAggregation.prototype.limit = 0;

            /**
             * TopRowsAggregation sort.
             * @member {search.proto.ISort|null|undefined} sort
             * @memberof search.proto.TopRowsAggregation
             * @instance
             */
            TopRowsAggregation.prototype.sort = null;

            /**
             * Creates a new TopRowsAggregation instance using the specified properties.
             * @function create
             * @memberof search.proto.TopRowsAggregation
             * @static
             * @param {search.proto.ITopRowsAggregation=} [properties] Properties to set
             * @returns {search.proto.TopRowsAggregation} TopRowsAggregation instance
             */
            TopRowsAggregation.create = function create(properties) {
                return new TopRowsAggregation(properties);
            };

            /**
             * Encodes the specified TopRowsAggregation message. Does not implicitly {@link search.proto.TopRowsAggregation.verify|verify} messages.
             * @function encode
             * @memberof search.proto.TopRowsAggregation
             * @static
             * @param {search.proto.ITopRowsAggregation} message TopRowsAggregation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TopRowsAggregation.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.limit != null && Object.hasOwnProperty.call(message, "limit"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.limit);
                if (message.sort != null && Object.hasOwnProperty.call(message, "sort"))
                    $root.search.proto.Sort.encode(message.sort, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified TopRowsAggregation message, length delimited. Does not implicitly {@link search.proto.TopRowsAggregation.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.TopRowsAggregation
             * @static
             * @param {search.proto.ITopRowsAggregation} message TopRowsAggregation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TopRowsAggregation.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TopRowsAggregation message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.TopRowsAggregation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.TopRowsAggregation} TopRowsAggregation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TopRowsAggregation.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.TopRowsAggregation();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.limit = reader.int32();
                        break;
                    case 2:
                        message.sort = $root.search.proto.Sort.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TopRowsAggregation message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.TopRowsAggregation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.TopRowsAggregation} TopRowsAggregation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TopRowsAggregation.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TopRowsAggregation message.
             * @function verify
             * @memberof search.proto.TopRowsAggregation
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TopRowsAggregation.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.limit != null && message.hasOwnProperty("limit"))
                    if (!$util.isInteger(message.limit))
                        return "limit: integer expected";
                if (message.sort != null && message.hasOwnProperty("sort")) {
                    var error = $root.search.proto.Sort.verify(message.sort);
                    if (error)
                        return "sort." + error;
                }
                return null;
            };

            /**
             * Creates a TopRowsAggregation message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.TopRowsAggregation
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.TopRowsAggregation} TopRowsAggregation
             */
            TopRowsAggregation.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.TopRowsAggregation)
                    return object;
                var message = new $root.search.proto.TopRowsAggregation();
                if (object.limit != null)
                    message.limit = object.limit | 0;
                if (object.sort != null) {
                    if (typeof object.sort !== "object")
                        throw TypeError(".search.proto.TopRowsAggregation.sort: object expected");
                    message.sort = $root.search.proto.Sort.fromObject(object.sort);
                }
                return message;
            };

            /**
             * Creates a plain object from a TopRowsAggregation message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.TopRowsAggregation
             * @static
             * @param {search.proto.TopRowsAggregation} message TopRowsAggregation
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TopRowsAggregation.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.limit = 0;
                    object.sort = null;
                }
                if (message.limit != null && message.hasOwnProperty("limit"))
                    object.limit = message.limit;
                if (message.sort != null && message.hasOwnProperty("sort"))
                    object.sort = $root.search.proto.Sort.toObject(message.sort, options);
                return object;
            };

            /**
             * Converts this TopRowsAggregation to JSON.
             * @function toJSON
             * @memberof search.proto.TopRowsAggregation
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TopRowsAggregation.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TopRowsAggregation;
        })();

        proto.PercentilesAggregation = (function() {

            /**
             * Properties of a PercentilesAggregation.
             * @memberof search.proto
             * @interface IPercentilesAggregation
             * @property {string|null} [fieldName] PercentilesAggregation fieldName
             * @property {Array.<number>|null} [percentiles] PercentilesAggregation percentiles
             * @property {Uint8Array|null} [missing] PercentilesAggregation missing
             */

            /**
             * Constructs a new PercentilesAggregation.
             * @memberof search.proto
             * @classdesc Represents a PercentilesAggregation.
             * @implements IPercentilesAggregation
             * @constructor
             * @param {search.proto.IPercentilesAggregation=} [properties] Properties to set
             */
            function PercentilesAggregation(properties) {
                this.percentiles = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PercentilesAggregation fieldName.
             * @member {string} fieldName
             * @memberof search.proto.PercentilesAggregation
             * @instance
             */
            PercentilesAggregation.prototype.fieldName = "";

            /**
             * PercentilesAggregation percentiles.
             * @member {Array.<number>} percentiles
             * @memberof search.proto.PercentilesAggregation
             * @instance
             */
            PercentilesAggregation.prototype.percentiles = $util.emptyArray;

            /**
             * PercentilesAggregation missing.
             * @member {Uint8Array} missing
             * @memberof search.proto.PercentilesAggregation
             * @instance
             */
            PercentilesAggregation.prototype.missing = $util.newBuffer([]);

            /**
             * Creates a new PercentilesAggregation instance using the specified properties.
             * @function create
             * @memberof search.proto.PercentilesAggregation
             * @static
             * @param {search.proto.IPercentilesAggregation=} [properties] Properties to set
             * @returns {search.proto.PercentilesAggregation} PercentilesAggregation instance
             */
            PercentilesAggregation.create = function create(properties) {
                return new PercentilesAggregation(properties);
            };

            /**
             * Encodes the specified PercentilesAggregation message. Does not implicitly {@link search.proto.PercentilesAggregation.verify|verify} messages.
             * @function encode
             * @memberof search.proto.PercentilesAggregation
             * @static
             * @param {search.proto.IPercentilesAggregation} message PercentilesAggregation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PercentilesAggregation.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fieldName != null && Object.hasOwnProperty.call(message, "fieldName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fieldName);
                if (message.percentiles != null && message.percentiles.length)
                    for (var i = 0; i < message.percentiles.length; ++i)
                        writer.uint32(/* id 2, wireType 1 =*/17).double(message.percentiles[i]);
                if (message.missing != null && Object.hasOwnProperty.call(message, "missing"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.missing);
                return writer;
            };

            /**
             * Encodes the specified PercentilesAggregation message, length delimited. Does not implicitly {@link search.proto.PercentilesAggregation.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.PercentilesAggregation
             * @static
             * @param {search.proto.IPercentilesAggregation} message PercentilesAggregation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PercentilesAggregation.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PercentilesAggregation message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.PercentilesAggregation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.PercentilesAggregation} PercentilesAggregation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PercentilesAggregation.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.PercentilesAggregation();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fieldName = reader.string();
                        break;
                    case 2:
                        if (!(message.percentiles && message.percentiles.length))
                            message.percentiles = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.percentiles.push(reader.double());
                        } else
                            message.percentiles.push(reader.double());
                        break;
                    case 3:
                        message.missing = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PercentilesAggregation message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.PercentilesAggregation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.PercentilesAggregation} PercentilesAggregation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PercentilesAggregation.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PercentilesAggregation message.
             * @function verify
             * @memberof search.proto.PercentilesAggregation
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PercentilesAggregation.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    if (!$util.isString(message.fieldName))
                        return "fieldName: string expected";
                if (message.percentiles != null && message.hasOwnProperty("percentiles")) {
                    if (!Array.isArray(message.percentiles))
                        return "percentiles: array expected";
                    for (var i = 0; i < message.percentiles.length; ++i)
                        if (typeof message.percentiles[i] !== "number")
                            return "percentiles: number[] expected";
                }
                if (message.missing != null && message.hasOwnProperty("missing"))
                    if (!(message.missing && typeof message.missing.length === "number" || $util.isString(message.missing)))
                        return "missing: buffer expected";
                return null;
            };

            /**
             * Creates a PercentilesAggregation message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.PercentilesAggregation
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.PercentilesAggregation} PercentilesAggregation
             */
            PercentilesAggregation.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.PercentilesAggregation)
                    return object;
                var message = new $root.search.proto.PercentilesAggregation();
                if (object.fieldName != null)
                    message.fieldName = String(object.fieldName);
                if (object.percentiles) {
                    if (!Array.isArray(object.percentiles))
                        throw TypeError(".search.proto.PercentilesAggregation.percentiles: array expected");
                    message.percentiles = [];
                    for (var i = 0; i < object.percentiles.length; ++i)
                        message.percentiles[i] = Number(object.percentiles[i]);
                }
                if (object.missing != null)
                    if (typeof object.missing === "string")
                        $util.base64.decode(object.missing, message.missing = $util.newBuffer($util.base64.length(object.missing)), 0);
                    else if (object.missing.length)
                        message.missing = object.missing;
                return message;
            };

            /**
             * Creates a plain object from a PercentilesAggregation message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.PercentilesAggregation
             * @static
             * @param {search.proto.PercentilesAggregation} message PercentilesAggregation
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PercentilesAggregation.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.percentiles = [];
                if (options.defaults) {
                    object.fieldName = "";
                    if (options.bytes === String)
                        object.missing = "";
                    else {
                        object.missing = [];
                        if (options.bytes !== Array)
                            object.missing = $util.newBuffer(object.missing);
                    }
                }
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    object.fieldName = message.fieldName;
                if (message.percentiles && message.percentiles.length) {
                    object.percentiles = [];
                    for (var j = 0; j < message.percentiles.length; ++j)
                        object.percentiles[j] = options.json && !isFinite(message.percentiles[j]) ? String(message.percentiles[j]) : message.percentiles[j];
                }
                if (message.missing != null && message.hasOwnProperty("missing"))
                    object.missing = options.bytes === String ? $util.base64.encode(message.missing, 0, message.missing.length) : options.bytes === Array ? Array.prototype.slice.call(message.missing) : message.missing;
                return object;
            };

            /**
             * Converts this PercentilesAggregation to JSON.
             * @function toJSON
             * @memberof search.proto.PercentilesAggregation
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PercentilesAggregation.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PercentilesAggregation;
        })();

        proto.FieldRange = (function() {

            /**
             * Properties of a FieldRange.
             * @memberof search.proto
             * @interface IFieldRange
             * @property {Uint8Array|null} [min] FieldRange min
             * @property {Uint8Array|null} [max] FieldRange max
             */

            /**
             * Constructs a new FieldRange.
             * @memberof search.proto
             * @classdesc Represents a FieldRange.
             * @implements IFieldRange
             * @constructor
             * @param {search.proto.IFieldRange=} [properties] Properties to set
             */
            function FieldRange(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FieldRange min.
             * @member {Uint8Array} min
             * @memberof search.proto.FieldRange
             * @instance
             */
            FieldRange.prototype.min = $util.newBuffer([]);

            /**
             * FieldRange max.
             * @member {Uint8Array} max
             * @memberof search.proto.FieldRange
             * @instance
             */
            FieldRange.prototype.max = $util.newBuffer([]);

            /**
             * Creates a new FieldRange instance using the specified properties.
             * @function create
             * @memberof search.proto.FieldRange
             * @static
             * @param {search.proto.IFieldRange=} [properties] Properties to set
             * @returns {search.proto.FieldRange} FieldRange instance
             */
            FieldRange.create = function create(properties) {
                return new FieldRange(properties);
            };

            /**
             * Encodes the specified FieldRange message. Does not implicitly {@link search.proto.FieldRange.verify|verify} messages.
             * @function encode
             * @memberof search.proto.FieldRange
             * @static
             * @param {search.proto.IFieldRange} message FieldRange message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldRange.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.min != null && Object.hasOwnProperty.call(message, "min"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.min);
                if (message.max != null && Object.hasOwnProperty.call(message, "max"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.max);
                return writer;
            };

            /**
             * Encodes the specified FieldRange message, length delimited. Does not implicitly {@link search.proto.FieldRange.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.FieldRange
             * @static
             * @param {search.proto.IFieldRange} message FieldRange message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldRange.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FieldRange message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.FieldRange
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.FieldRange} FieldRange
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldRange.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.FieldRange();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.min = reader.bytes();
                        break;
                    case 2:
                        message.max = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FieldRange message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.FieldRange
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.FieldRange} FieldRange
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldRange.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FieldRange message.
             * @function verify
             * @memberof search.proto.FieldRange
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FieldRange.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.min != null && message.hasOwnProperty("min"))
                    if (!(message.min && typeof message.min.length === "number" || $util.isString(message.min)))
                        return "min: buffer expected";
                if (message.max != null && message.hasOwnProperty("max"))
                    if (!(message.max && typeof message.max.length === "number" || $util.isString(message.max)))
                        return "max: buffer expected";
                return null;
            };

            /**
             * Creates a FieldRange message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.FieldRange
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.FieldRange} FieldRange
             */
            FieldRange.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.FieldRange)
                    return object;
                var message = new $root.search.proto.FieldRange();
                if (object.min != null)
                    if (typeof object.min === "string")
                        $util.base64.decode(object.min, message.min = $util.newBuffer($util.base64.length(object.min)), 0);
                    else if (object.min.length)
                        message.min = object.min;
                if (object.max != null)
                    if (typeof object.max === "string")
                        $util.base64.decode(object.max, message.max = $util.newBuffer($util.base64.length(object.max)), 0);
                    else if (object.max.length)
                        message.max = object.max;
                return message;
            };

            /**
             * Creates a plain object from a FieldRange message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.FieldRange
             * @static
             * @param {search.proto.FieldRange} message FieldRange
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FieldRange.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.min = "";
                    else {
                        object.min = [];
                        if (options.bytes !== Array)
                            object.min = $util.newBuffer(object.min);
                    }
                    if (options.bytes === String)
                        object.max = "";
                    else {
                        object.max = [];
                        if (options.bytes !== Array)
                            object.max = $util.newBuffer(object.max);
                    }
                }
                if (message.min != null && message.hasOwnProperty("min"))
                    object.min = options.bytes === String ? $util.base64.encode(message.min, 0, message.min.length) : options.bytes === Array ? Array.prototype.slice.call(message.min) : message.min;
                if (message.max != null && message.hasOwnProperty("max"))
                    object.max = options.bytes === String ? $util.base64.encode(message.max, 0, message.max.length) : options.bytes === Array ? Array.prototype.slice.call(message.max) : message.max;
                return object;
            };

            /**
             * Converts this FieldRange to JSON.
             * @function toJSON
             * @memberof search.proto.FieldRange
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FieldRange.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FieldRange;
        })();

        proto.GroupByDateHistogram = (function() {

            /**
             * Properties of a GroupByDateHistogram.
             * @memberof search.proto
             * @interface IGroupByDateHistogram
             * @property {string|null} [fieldName] GroupByDateHistogram fieldName
             * @property {search.proto.IDateTimeValue|null} [interval] GroupByDateHistogram interval
             * @property {search.proto.IFieldRange|null} [fieldRange] GroupByDateHistogram fieldRange
             * @property {Uint8Array|null} [missing] GroupByDateHistogram missing
             * @property {number|Long|null} [minDocCount] GroupByDateHistogram minDocCount
             * @property {string|null} [timeZone] GroupByDateHistogram timeZone
             * @property {search.proto.IGroupBySort|null} [sort] GroupByDateHistogram sort
             * @property {search.proto.IAggregations|null} [subAggs] GroupByDateHistogram subAggs
             * @property {search.proto.IGroupBys|null} [subGroupBys] GroupByDateHistogram subGroupBys
             * @property {search.proto.IDateTimeValue|null} [offset] GroupByDateHistogram offset
             */

            /**
             * Constructs a new GroupByDateHistogram.
             * @memberof search.proto
             * @classdesc Represents a GroupByDateHistogram.
             * @implements IGroupByDateHistogram
             * @constructor
             * @param {search.proto.IGroupByDateHistogram=} [properties] Properties to set
             */
            function GroupByDateHistogram(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupByDateHistogram fieldName.
             * @member {string} fieldName
             * @memberof search.proto.GroupByDateHistogram
             * @instance
             */
            GroupByDateHistogram.prototype.fieldName = "";

            /**
             * GroupByDateHistogram interval.
             * @member {search.proto.IDateTimeValue|null|undefined} interval
             * @memberof search.proto.GroupByDateHistogram
             * @instance
             */
            GroupByDateHistogram.prototype.interval = null;

            /**
             * GroupByDateHistogram fieldRange.
             * @member {search.proto.IFieldRange|null|undefined} fieldRange
             * @memberof search.proto.GroupByDateHistogram
             * @instance
             */
            GroupByDateHistogram.prototype.fieldRange = null;

            /**
             * GroupByDateHistogram missing.
             * @member {Uint8Array} missing
             * @memberof search.proto.GroupByDateHistogram
             * @instance
             */
            GroupByDateHistogram.prototype.missing = $util.newBuffer([]);

            /**
             * GroupByDateHistogram minDocCount.
             * @member {number|Long} minDocCount
             * @memberof search.proto.GroupByDateHistogram
             * @instance
             */
            GroupByDateHistogram.prototype.minDocCount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * GroupByDateHistogram timeZone.
             * @member {string} timeZone
             * @memberof search.proto.GroupByDateHistogram
             * @instance
             */
            GroupByDateHistogram.prototype.timeZone = "";

            /**
             * GroupByDateHistogram sort.
             * @member {search.proto.IGroupBySort|null|undefined} sort
             * @memberof search.proto.GroupByDateHistogram
             * @instance
             */
            GroupByDateHistogram.prototype.sort = null;

            /**
             * GroupByDateHistogram subAggs.
             * @member {search.proto.IAggregations|null|undefined} subAggs
             * @memberof search.proto.GroupByDateHistogram
             * @instance
             */
            GroupByDateHistogram.prototype.subAggs = null;

            /**
             * GroupByDateHistogram subGroupBys.
             * @member {search.proto.IGroupBys|null|undefined} subGroupBys
             * @memberof search.proto.GroupByDateHistogram
             * @instance
             */
            GroupByDateHistogram.prototype.subGroupBys = null;

            /**
             * GroupByDateHistogram offset.
             * @member {search.proto.IDateTimeValue|null|undefined} offset
             * @memberof search.proto.GroupByDateHistogram
             * @instance
             */
            GroupByDateHistogram.prototype.offset = null;

            /**
             * Creates a new GroupByDateHistogram instance using the specified properties.
             * @function create
             * @memberof search.proto.GroupByDateHistogram
             * @static
             * @param {search.proto.IGroupByDateHistogram=} [properties] Properties to set
             * @returns {search.proto.GroupByDateHistogram} GroupByDateHistogram instance
             */
            GroupByDateHistogram.create = function create(properties) {
                return new GroupByDateHistogram(properties);
            };

            /**
             * Encodes the specified GroupByDateHistogram message. Does not implicitly {@link search.proto.GroupByDateHistogram.verify|verify} messages.
             * @function encode
             * @memberof search.proto.GroupByDateHistogram
             * @static
             * @param {search.proto.IGroupByDateHistogram} message GroupByDateHistogram message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByDateHistogram.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fieldName != null && Object.hasOwnProperty.call(message, "fieldName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fieldName);
                if (message.interval != null && Object.hasOwnProperty.call(message, "interval"))
                    $root.search.proto.DateTimeValue.encode(message.interval, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.fieldRange != null && Object.hasOwnProperty.call(message, "fieldRange"))
                    $root.search.proto.FieldRange.encode(message.fieldRange, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.missing != null && Object.hasOwnProperty.call(message, "missing"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.missing);
                if (message.minDocCount != null && Object.hasOwnProperty.call(message, "minDocCount"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.minDocCount);
                if (message.timeZone != null && Object.hasOwnProperty.call(message, "timeZone"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.timeZone);
                if (message.sort != null && Object.hasOwnProperty.call(message, "sort"))
                    $root.search.proto.GroupBySort.encode(message.sort, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.subAggs != null && Object.hasOwnProperty.call(message, "subAggs"))
                    $root.search.proto.Aggregations.encode(message.subAggs, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.subGroupBys != null && Object.hasOwnProperty.call(message, "subGroupBys"))
                    $root.search.proto.GroupBys.encode(message.subGroupBys, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                    $root.search.proto.DateTimeValue.encode(message.offset, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GroupByDateHistogram message, length delimited. Does not implicitly {@link search.proto.GroupByDateHistogram.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.GroupByDateHistogram
             * @static
             * @param {search.proto.IGroupByDateHistogram} message GroupByDateHistogram message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByDateHistogram.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupByDateHistogram message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.GroupByDateHistogram
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.GroupByDateHistogram} GroupByDateHistogram
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByDateHistogram.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.GroupByDateHistogram();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fieldName = reader.string();
                        break;
                    case 2:
                        message.interval = $root.search.proto.DateTimeValue.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.fieldRange = $root.search.proto.FieldRange.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.missing = reader.bytes();
                        break;
                    case 5:
                        message.minDocCount = reader.int64();
                        break;
                    case 6:
                        message.timeZone = reader.string();
                        break;
                    case 7:
                        message.sort = $root.search.proto.GroupBySort.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.subAggs = $root.search.proto.Aggregations.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.subGroupBys = $root.search.proto.GroupBys.decode(reader, reader.uint32());
                        break;
                    case 10:
                        message.offset = $root.search.proto.DateTimeValue.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupByDateHistogram message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.GroupByDateHistogram
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.GroupByDateHistogram} GroupByDateHistogram
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByDateHistogram.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupByDateHistogram message.
             * @function verify
             * @memberof search.proto.GroupByDateHistogram
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupByDateHistogram.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    if (!$util.isString(message.fieldName))
                        return "fieldName: string expected";
                if (message.interval != null && message.hasOwnProperty("interval")) {
                    var error = $root.search.proto.DateTimeValue.verify(message.interval);
                    if (error)
                        return "interval." + error;
                }
                if (message.fieldRange != null && message.hasOwnProperty("fieldRange")) {
                    var error = $root.search.proto.FieldRange.verify(message.fieldRange);
                    if (error)
                        return "fieldRange." + error;
                }
                if (message.missing != null && message.hasOwnProperty("missing"))
                    if (!(message.missing && typeof message.missing.length === "number" || $util.isString(message.missing)))
                        return "missing: buffer expected";
                if (message.minDocCount != null && message.hasOwnProperty("minDocCount"))
                    if (!$util.isInteger(message.minDocCount) && !(message.minDocCount && $util.isInteger(message.minDocCount.low) && $util.isInteger(message.minDocCount.high)))
                        return "minDocCount: integer|Long expected";
                if (message.timeZone != null && message.hasOwnProperty("timeZone"))
                    if (!$util.isString(message.timeZone))
                        return "timeZone: string expected";
                if (message.sort != null && message.hasOwnProperty("sort")) {
                    var error = $root.search.proto.GroupBySort.verify(message.sort);
                    if (error)
                        return "sort." + error;
                }
                if (message.subAggs != null && message.hasOwnProperty("subAggs")) {
                    var error = $root.search.proto.Aggregations.verify(message.subAggs);
                    if (error)
                        return "subAggs." + error;
                }
                if (message.subGroupBys != null && message.hasOwnProperty("subGroupBys")) {
                    var error = $root.search.proto.GroupBys.verify(message.subGroupBys);
                    if (error)
                        return "subGroupBys." + error;
                }
                if (message.offset != null && message.hasOwnProperty("offset")) {
                    var error = $root.search.proto.DateTimeValue.verify(message.offset);
                    if (error)
                        return "offset." + error;
                }
                return null;
            };

            /**
             * Creates a GroupByDateHistogram message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.GroupByDateHistogram
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.GroupByDateHistogram} GroupByDateHistogram
             */
            GroupByDateHistogram.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.GroupByDateHistogram)
                    return object;
                var message = new $root.search.proto.GroupByDateHistogram();
                if (object.fieldName != null)
                    message.fieldName = String(object.fieldName);
                if (object.interval != null) {
                    if (typeof object.interval !== "object")
                        throw TypeError(".search.proto.GroupByDateHistogram.interval: object expected");
                    message.interval = $root.search.proto.DateTimeValue.fromObject(object.interval);
                }
                if (object.fieldRange != null) {
                    if (typeof object.fieldRange !== "object")
                        throw TypeError(".search.proto.GroupByDateHistogram.fieldRange: object expected");
                    message.fieldRange = $root.search.proto.FieldRange.fromObject(object.fieldRange);
                }
                if (object.missing != null)
                    if (typeof object.missing === "string")
                        $util.base64.decode(object.missing, message.missing = $util.newBuffer($util.base64.length(object.missing)), 0);
                    else if (object.missing.length)
                        message.missing = object.missing;
                if (object.minDocCount != null)
                    if ($util.Long)
                        (message.minDocCount = $util.Long.fromValue(object.minDocCount)).unsigned = false;
                    else if (typeof object.minDocCount === "string")
                        message.minDocCount = parseInt(object.minDocCount, 10);
                    else if (typeof object.minDocCount === "number")
                        message.minDocCount = object.minDocCount;
                    else if (typeof object.minDocCount === "object")
                        message.minDocCount = new $util.LongBits(object.minDocCount.low >>> 0, object.minDocCount.high >>> 0).toNumber();
                if (object.timeZone != null)
                    message.timeZone = String(object.timeZone);
                if (object.sort != null) {
                    if (typeof object.sort !== "object")
                        throw TypeError(".search.proto.GroupByDateHistogram.sort: object expected");
                    message.sort = $root.search.proto.GroupBySort.fromObject(object.sort);
                }
                if (object.subAggs != null) {
                    if (typeof object.subAggs !== "object")
                        throw TypeError(".search.proto.GroupByDateHistogram.subAggs: object expected");
                    message.subAggs = $root.search.proto.Aggregations.fromObject(object.subAggs);
                }
                if (object.subGroupBys != null) {
                    if (typeof object.subGroupBys !== "object")
                        throw TypeError(".search.proto.GroupByDateHistogram.subGroupBys: object expected");
                    message.subGroupBys = $root.search.proto.GroupBys.fromObject(object.subGroupBys);
                }
                if (object.offset != null) {
                    if (typeof object.offset !== "object")
                        throw TypeError(".search.proto.GroupByDateHistogram.offset: object expected");
                    message.offset = $root.search.proto.DateTimeValue.fromObject(object.offset);
                }
                return message;
            };

            /**
             * Creates a plain object from a GroupByDateHistogram message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.GroupByDateHistogram
             * @static
             * @param {search.proto.GroupByDateHistogram} message GroupByDateHistogram
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupByDateHistogram.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.fieldName = "";
                    object.interval = null;
                    object.fieldRange = null;
                    if (options.bytes === String)
                        object.missing = "";
                    else {
                        object.missing = [];
                        if (options.bytes !== Array)
                            object.missing = $util.newBuffer(object.missing);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.minDocCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.minDocCount = options.longs === String ? "0" : 0;
                    object.timeZone = "";
                    object.sort = null;
                    object.subAggs = null;
                    object.subGroupBys = null;
                    object.offset = null;
                }
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    object.fieldName = message.fieldName;
                if (message.interval != null && message.hasOwnProperty("interval"))
                    object.interval = $root.search.proto.DateTimeValue.toObject(message.interval, options);
                if (message.fieldRange != null && message.hasOwnProperty("fieldRange"))
                    object.fieldRange = $root.search.proto.FieldRange.toObject(message.fieldRange, options);
                if (message.missing != null && message.hasOwnProperty("missing"))
                    object.missing = options.bytes === String ? $util.base64.encode(message.missing, 0, message.missing.length) : options.bytes === Array ? Array.prototype.slice.call(message.missing) : message.missing;
                if (message.minDocCount != null && message.hasOwnProperty("minDocCount"))
                    if (typeof message.minDocCount === "number")
                        object.minDocCount = options.longs === String ? String(message.minDocCount) : message.minDocCount;
                    else
                        object.minDocCount = options.longs === String ? $util.Long.prototype.toString.call(message.minDocCount) : options.longs === Number ? new $util.LongBits(message.minDocCount.low >>> 0, message.minDocCount.high >>> 0).toNumber() : message.minDocCount;
                if (message.timeZone != null && message.hasOwnProperty("timeZone"))
                    object.timeZone = message.timeZone;
                if (message.sort != null && message.hasOwnProperty("sort"))
                    object.sort = $root.search.proto.GroupBySort.toObject(message.sort, options);
                if (message.subAggs != null && message.hasOwnProperty("subAggs"))
                    object.subAggs = $root.search.proto.Aggregations.toObject(message.subAggs, options);
                if (message.subGroupBys != null && message.hasOwnProperty("subGroupBys"))
                    object.subGroupBys = $root.search.proto.GroupBys.toObject(message.subGroupBys, options);
                if (message.offset != null && message.hasOwnProperty("offset"))
                    object.offset = $root.search.proto.DateTimeValue.toObject(message.offset, options);
                return object;
            };

            /**
             * Converts this GroupByDateHistogram to JSON.
             * @function toJSON
             * @memberof search.proto.GroupByDateHistogram
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupByDateHistogram.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GroupByDateHistogram;
        })();

        proto.GroupByHistogram = (function() {

            /**
             * Properties of a GroupByHistogram.
             * @memberof search.proto
             * @interface IGroupByHistogram
             * @property {string|null} [fieldName] GroupByHistogram fieldName
             * @property {Uint8Array|null} [interval] GroupByHistogram interval
             * @property {Uint8Array|null} [missing] GroupByHistogram missing
             * @property {number|Long|null} [minDocCount] GroupByHistogram minDocCount
             * @property {search.proto.IGroupBySort|null} [sort] GroupByHistogram sort
             * @property {search.proto.IFieldRange|null} [fieldRange] GroupByHistogram fieldRange
             * @property {search.proto.IAggregations|null} [subAggs] GroupByHistogram subAggs
             * @property {search.proto.IGroupBys|null} [subGroupBys] GroupByHistogram subGroupBys
             * @property {Uint8Array|null} [offset] GroupByHistogram offset
             */

            /**
             * Constructs a new GroupByHistogram.
             * @memberof search.proto
             * @classdesc Represents a GroupByHistogram.
             * @implements IGroupByHistogram
             * @constructor
             * @param {search.proto.IGroupByHistogram=} [properties] Properties to set
             */
            function GroupByHistogram(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupByHistogram fieldName.
             * @member {string} fieldName
             * @memberof search.proto.GroupByHistogram
             * @instance
             */
            GroupByHistogram.prototype.fieldName = "";

            /**
             * GroupByHistogram interval.
             * @member {Uint8Array} interval
             * @memberof search.proto.GroupByHistogram
             * @instance
             */
            GroupByHistogram.prototype.interval = $util.newBuffer([]);

            /**
             * GroupByHistogram missing.
             * @member {Uint8Array} missing
             * @memberof search.proto.GroupByHistogram
             * @instance
             */
            GroupByHistogram.prototype.missing = $util.newBuffer([]);

            /**
             * GroupByHistogram minDocCount.
             * @member {number|Long} minDocCount
             * @memberof search.proto.GroupByHistogram
             * @instance
             */
            GroupByHistogram.prototype.minDocCount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * GroupByHistogram sort.
             * @member {search.proto.IGroupBySort|null|undefined} sort
             * @memberof search.proto.GroupByHistogram
             * @instance
             */
            GroupByHistogram.prototype.sort = null;

            /**
             * GroupByHistogram fieldRange.
             * @member {search.proto.IFieldRange|null|undefined} fieldRange
             * @memberof search.proto.GroupByHistogram
             * @instance
             */
            GroupByHistogram.prototype.fieldRange = null;

            /**
             * GroupByHistogram subAggs.
             * @member {search.proto.IAggregations|null|undefined} subAggs
             * @memberof search.proto.GroupByHistogram
             * @instance
             */
            GroupByHistogram.prototype.subAggs = null;

            /**
             * GroupByHistogram subGroupBys.
             * @member {search.proto.IGroupBys|null|undefined} subGroupBys
             * @memberof search.proto.GroupByHistogram
             * @instance
             */
            GroupByHistogram.prototype.subGroupBys = null;

            /**
             * GroupByHistogram offset.
             * @member {Uint8Array} offset
             * @memberof search.proto.GroupByHistogram
             * @instance
             */
            GroupByHistogram.prototype.offset = $util.newBuffer([]);

            /**
             * Creates a new GroupByHistogram instance using the specified properties.
             * @function create
             * @memberof search.proto.GroupByHistogram
             * @static
             * @param {search.proto.IGroupByHistogram=} [properties] Properties to set
             * @returns {search.proto.GroupByHistogram} GroupByHistogram instance
             */
            GroupByHistogram.create = function create(properties) {
                return new GroupByHistogram(properties);
            };

            /**
             * Encodes the specified GroupByHistogram message. Does not implicitly {@link search.proto.GroupByHistogram.verify|verify} messages.
             * @function encode
             * @memberof search.proto.GroupByHistogram
             * @static
             * @param {search.proto.IGroupByHistogram} message GroupByHistogram message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByHistogram.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fieldName != null && Object.hasOwnProperty.call(message, "fieldName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fieldName);
                if (message.interval != null && Object.hasOwnProperty.call(message, "interval"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.interval);
                if (message.missing != null && Object.hasOwnProperty.call(message, "missing"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.missing);
                if (message.minDocCount != null && Object.hasOwnProperty.call(message, "minDocCount"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.minDocCount);
                if (message.sort != null && Object.hasOwnProperty.call(message, "sort"))
                    $root.search.proto.GroupBySort.encode(message.sort, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.fieldRange != null && Object.hasOwnProperty.call(message, "fieldRange"))
                    $root.search.proto.FieldRange.encode(message.fieldRange, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.subAggs != null && Object.hasOwnProperty.call(message, "subAggs"))
                    $root.search.proto.Aggregations.encode(message.subAggs, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.subGroupBys != null && Object.hasOwnProperty.call(message, "subGroupBys"))
                    $root.search.proto.GroupBys.encode(message.subGroupBys, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                    writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.offset);
                return writer;
            };

            /**
             * Encodes the specified GroupByHistogram message, length delimited. Does not implicitly {@link search.proto.GroupByHistogram.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.GroupByHistogram
             * @static
             * @param {search.proto.IGroupByHistogram} message GroupByHistogram message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByHistogram.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupByHistogram message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.GroupByHistogram
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.GroupByHistogram} GroupByHistogram
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByHistogram.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.GroupByHistogram();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fieldName = reader.string();
                        break;
                    case 2:
                        message.interval = reader.bytes();
                        break;
                    case 3:
                        message.missing = reader.bytes();
                        break;
                    case 4:
                        message.minDocCount = reader.int64();
                        break;
                    case 5:
                        message.sort = $root.search.proto.GroupBySort.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.fieldRange = $root.search.proto.FieldRange.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.subAggs = $root.search.proto.Aggregations.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.subGroupBys = $root.search.proto.GroupBys.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.offset = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupByHistogram message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.GroupByHistogram
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.GroupByHistogram} GroupByHistogram
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByHistogram.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupByHistogram message.
             * @function verify
             * @memberof search.proto.GroupByHistogram
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupByHistogram.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    if (!$util.isString(message.fieldName))
                        return "fieldName: string expected";
                if (message.interval != null && message.hasOwnProperty("interval"))
                    if (!(message.interval && typeof message.interval.length === "number" || $util.isString(message.interval)))
                        return "interval: buffer expected";
                if (message.missing != null && message.hasOwnProperty("missing"))
                    if (!(message.missing && typeof message.missing.length === "number" || $util.isString(message.missing)))
                        return "missing: buffer expected";
                if (message.minDocCount != null && message.hasOwnProperty("minDocCount"))
                    if (!$util.isInteger(message.minDocCount) && !(message.minDocCount && $util.isInteger(message.minDocCount.low) && $util.isInteger(message.minDocCount.high)))
                        return "minDocCount: integer|Long expected";
                if (message.sort != null && message.hasOwnProperty("sort")) {
                    var error = $root.search.proto.GroupBySort.verify(message.sort);
                    if (error)
                        return "sort." + error;
                }
                if (message.fieldRange != null && message.hasOwnProperty("fieldRange")) {
                    var error = $root.search.proto.FieldRange.verify(message.fieldRange);
                    if (error)
                        return "fieldRange." + error;
                }
                if (message.subAggs != null && message.hasOwnProperty("subAggs")) {
                    var error = $root.search.proto.Aggregations.verify(message.subAggs);
                    if (error)
                        return "subAggs." + error;
                }
                if (message.subGroupBys != null && message.hasOwnProperty("subGroupBys")) {
                    var error = $root.search.proto.GroupBys.verify(message.subGroupBys);
                    if (error)
                        return "subGroupBys." + error;
                }
                if (message.offset != null && message.hasOwnProperty("offset"))
                    if (!(message.offset && typeof message.offset.length === "number" || $util.isString(message.offset)))
                        return "offset: buffer expected";
                return null;
            };

            /**
             * Creates a GroupByHistogram message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.GroupByHistogram
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.GroupByHistogram} GroupByHistogram
             */
            GroupByHistogram.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.GroupByHistogram)
                    return object;
                var message = new $root.search.proto.GroupByHistogram();
                if (object.fieldName != null)
                    message.fieldName = String(object.fieldName);
                if (object.interval != null)
                    if (typeof object.interval === "string")
                        $util.base64.decode(object.interval, message.interval = $util.newBuffer($util.base64.length(object.interval)), 0);
                    else if (object.interval.length)
                        message.interval = object.interval;
                if (object.missing != null)
                    if (typeof object.missing === "string")
                        $util.base64.decode(object.missing, message.missing = $util.newBuffer($util.base64.length(object.missing)), 0);
                    else if (object.missing.length)
                        message.missing = object.missing;
                if (object.minDocCount != null)
                    if ($util.Long)
                        (message.minDocCount = $util.Long.fromValue(object.minDocCount)).unsigned = false;
                    else if (typeof object.minDocCount === "string")
                        message.minDocCount = parseInt(object.minDocCount, 10);
                    else if (typeof object.minDocCount === "number")
                        message.minDocCount = object.minDocCount;
                    else if (typeof object.minDocCount === "object")
                        message.minDocCount = new $util.LongBits(object.minDocCount.low >>> 0, object.minDocCount.high >>> 0).toNumber();
                if (object.sort != null) {
                    if (typeof object.sort !== "object")
                        throw TypeError(".search.proto.GroupByHistogram.sort: object expected");
                    message.sort = $root.search.proto.GroupBySort.fromObject(object.sort);
                }
                if (object.fieldRange != null) {
                    if (typeof object.fieldRange !== "object")
                        throw TypeError(".search.proto.GroupByHistogram.fieldRange: object expected");
                    message.fieldRange = $root.search.proto.FieldRange.fromObject(object.fieldRange);
                }
                if (object.subAggs != null) {
                    if (typeof object.subAggs !== "object")
                        throw TypeError(".search.proto.GroupByHistogram.subAggs: object expected");
                    message.subAggs = $root.search.proto.Aggregations.fromObject(object.subAggs);
                }
                if (object.subGroupBys != null) {
                    if (typeof object.subGroupBys !== "object")
                        throw TypeError(".search.proto.GroupByHistogram.subGroupBys: object expected");
                    message.subGroupBys = $root.search.proto.GroupBys.fromObject(object.subGroupBys);
                }
                if (object.offset != null)
                    if (typeof object.offset === "string")
                        $util.base64.decode(object.offset, message.offset = $util.newBuffer($util.base64.length(object.offset)), 0);
                    else if (object.offset.length)
                        message.offset = object.offset;
                return message;
            };

            /**
             * Creates a plain object from a GroupByHistogram message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.GroupByHistogram
             * @static
             * @param {search.proto.GroupByHistogram} message GroupByHistogram
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupByHistogram.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.fieldName = "";
                    if (options.bytes === String)
                        object.interval = "";
                    else {
                        object.interval = [];
                        if (options.bytes !== Array)
                            object.interval = $util.newBuffer(object.interval);
                    }
                    if (options.bytes === String)
                        object.missing = "";
                    else {
                        object.missing = [];
                        if (options.bytes !== Array)
                            object.missing = $util.newBuffer(object.missing);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.minDocCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.minDocCount = options.longs === String ? "0" : 0;
                    object.sort = null;
                    object.fieldRange = null;
                    object.subAggs = null;
                    object.subGroupBys = null;
                    if (options.bytes === String)
                        object.offset = "";
                    else {
                        object.offset = [];
                        if (options.bytes !== Array)
                            object.offset = $util.newBuffer(object.offset);
                    }
                }
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    object.fieldName = message.fieldName;
                if (message.interval != null && message.hasOwnProperty("interval"))
                    object.interval = options.bytes === String ? $util.base64.encode(message.interval, 0, message.interval.length) : options.bytes === Array ? Array.prototype.slice.call(message.interval) : message.interval;
                if (message.missing != null && message.hasOwnProperty("missing"))
                    object.missing = options.bytes === String ? $util.base64.encode(message.missing, 0, message.missing.length) : options.bytes === Array ? Array.prototype.slice.call(message.missing) : message.missing;
                if (message.minDocCount != null && message.hasOwnProperty("minDocCount"))
                    if (typeof message.minDocCount === "number")
                        object.minDocCount = options.longs === String ? String(message.minDocCount) : message.minDocCount;
                    else
                        object.minDocCount = options.longs === String ? $util.Long.prototype.toString.call(message.minDocCount) : options.longs === Number ? new $util.LongBits(message.minDocCount.low >>> 0, message.minDocCount.high >>> 0).toNumber() : message.minDocCount;
                if (message.sort != null && message.hasOwnProperty("sort"))
                    object.sort = $root.search.proto.GroupBySort.toObject(message.sort, options);
                if (message.fieldRange != null && message.hasOwnProperty("fieldRange"))
                    object.fieldRange = $root.search.proto.FieldRange.toObject(message.fieldRange, options);
                if (message.subAggs != null && message.hasOwnProperty("subAggs"))
                    object.subAggs = $root.search.proto.Aggregations.toObject(message.subAggs, options);
                if (message.subGroupBys != null && message.hasOwnProperty("subGroupBys"))
                    object.subGroupBys = $root.search.proto.GroupBys.toObject(message.subGroupBys, options);
                if (message.offset != null && message.hasOwnProperty("offset"))
                    object.offset = options.bytes === String ? $util.base64.encode(message.offset, 0, message.offset.length) : options.bytes === Array ? Array.prototype.slice.call(message.offset) : message.offset;
                return object;
            };

            /**
             * Converts this GroupByHistogram to JSON.
             * @function toJSON
             * @memberof search.proto.GroupByHistogram
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupByHistogram.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GroupByHistogram;
        })();

        proto.GroupKeySort = (function() {

            /**
             * Properties of a GroupKeySort.
             * @memberof search.proto
             * @interface IGroupKeySort
             * @property {search.proto.SortOrder|null} [order] GroupKeySort order
             */

            /**
             * Constructs a new GroupKeySort.
             * @memberof search.proto
             * @classdesc Represents a GroupKeySort.
             * @implements IGroupKeySort
             * @constructor
             * @param {search.proto.IGroupKeySort=} [properties] Properties to set
             */
            function GroupKeySort(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupKeySort order.
             * @member {search.proto.SortOrder} order
             * @memberof search.proto.GroupKeySort
             * @instance
             */
            GroupKeySort.prototype.order = 0;

            /**
             * Creates a new GroupKeySort instance using the specified properties.
             * @function create
             * @memberof search.proto.GroupKeySort
             * @static
             * @param {search.proto.IGroupKeySort=} [properties] Properties to set
             * @returns {search.proto.GroupKeySort} GroupKeySort instance
             */
            GroupKeySort.create = function create(properties) {
                return new GroupKeySort(properties);
            };

            /**
             * Encodes the specified GroupKeySort message. Does not implicitly {@link search.proto.GroupKeySort.verify|verify} messages.
             * @function encode
             * @memberof search.proto.GroupKeySort
             * @static
             * @param {search.proto.IGroupKeySort} message GroupKeySort message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupKeySort.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.order != null && Object.hasOwnProperty.call(message, "order"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.order);
                return writer;
            };

            /**
             * Encodes the specified GroupKeySort message, length delimited. Does not implicitly {@link search.proto.GroupKeySort.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.GroupKeySort
             * @static
             * @param {search.proto.IGroupKeySort} message GroupKeySort message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupKeySort.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupKeySort message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.GroupKeySort
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.GroupKeySort} GroupKeySort
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupKeySort.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.GroupKeySort();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.order = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupKeySort message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.GroupKeySort
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.GroupKeySort} GroupKeySort
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupKeySort.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupKeySort message.
             * @function verify
             * @memberof search.proto.GroupKeySort
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupKeySort.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.order != null && message.hasOwnProperty("order"))
                    switch (message.order) {
                    default:
                        return "order: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };

            /**
             * Creates a GroupKeySort message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.GroupKeySort
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.GroupKeySort} GroupKeySort
             */
            GroupKeySort.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.GroupKeySort)
                    return object;
                var message = new $root.search.proto.GroupKeySort();
                switch (object.order) {
                case "SORT_ORDER_ASC":
                case 0:
                    message.order = 0;
                    break;
                case "SORT_ORDER_DESC":
                case 1:
                    message.order = 1;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a GroupKeySort message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.GroupKeySort
             * @static
             * @param {search.proto.GroupKeySort} message GroupKeySort
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupKeySort.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.order = options.enums === String ? "SORT_ORDER_ASC" : 0;
                if (message.order != null && message.hasOwnProperty("order"))
                    object.order = options.enums === String ? $root.search.proto.SortOrder[message.order] : message.order;
                return object;
            };

            /**
             * Converts this GroupKeySort to JSON.
             * @function toJSON
             * @memberof search.proto.GroupKeySort
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupKeySort.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GroupKeySort;
        })();

        proto.RowCountSort = (function() {

            /**
             * Properties of a RowCountSort.
             * @memberof search.proto
             * @interface IRowCountSort
             * @property {search.proto.SortOrder|null} [order] RowCountSort order
             */

            /**
             * Constructs a new RowCountSort.
             * @memberof search.proto
             * @classdesc Represents a RowCountSort.
             * @implements IRowCountSort
             * @constructor
             * @param {search.proto.IRowCountSort=} [properties] Properties to set
             */
            function RowCountSort(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RowCountSort order.
             * @member {search.proto.SortOrder} order
             * @memberof search.proto.RowCountSort
             * @instance
             */
            RowCountSort.prototype.order = 0;

            /**
             * Creates a new RowCountSort instance using the specified properties.
             * @function create
             * @memberof search.proto.RowCountSort
             * @static
             * @param {search.proto.IRowCountSort=} [properties] Properties to set
             * @returns {search.proto.RowCountSort} RowCountSort instance
             */
            RowCountSort.create = function create(properties) {
                return new RowCountSort(properties);
            };

            /**
             * Encodes the specified RowCountSort message. Does not implicitly {@link search.proto.RowCountSort.verify|verify} messages.
             * @function encode
             * @memberof search.proto.RowCountSort
             * @static
             * @param {search.proto.IRowCountSort} message RowCountSort message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RowCountSort.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.order != null && Object.hasOwnProperty.call(message, "order"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.order);
                return writer;
            };

            /**
             * Encodes the specified RowCountSort message, length delimited. Does not implicitly {@link search.proto.RowCountSort.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.RowCountSort
             * @static
             * @param {search.proto.IRowCountSort} message RowCountSort message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RowCountSort.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RowCountSort message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.RowCountSort
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.RowCountSort} RowCountSort
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RowCountSort.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.RowCountSort();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.order = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RowCountSort message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.RowCountSort
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.RowCountSort} RowCountSort
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RowCountSort.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RowCountSort message.
             * @function verify
             * @memberof search.proto.RowCountSort
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RowCountSort.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.order != null && message.hasOwnProperty("order"))
                    switch (message.order) {
                    default:
                        return "order: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };

            /**
             * Creates a RowCountSort message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.RowCountSort
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.RowCountSort} RowCountSort
             */
            RowCountSort.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.RowCountSort)
                    return object;
                var message = new $root.search.proto.RowCountSort();
                switch (object.order) {
                case "SORT_ORDER_ASC":
                case 0:
                    message.order = 0;
                    break;
                case "SORT_ORDER_DESC":
                case 1:
                    message.order = 1;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a RowCountSort message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.RowCountSort
             * @static
             * @param {search.proto.RowCountSort} message RowCountSort
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RowCountSort.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.order = options.enums === String ? "SORT_ORDER_ASC" : 0;
                if (message.order != null && message.hasOwnProperty("order"))
                    object.order = options.enums === String ? $root.search.proto.SortOrder[message.order] : message.order;
                return object;
            };

            /**
             * Converts this RowCountSort to JSON.
             * @function toJSON
             * @memberof search.proto.RowCountSort
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RowCountSort.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RowCountSort;
        })();

        proto.SubAggSort = (function() {

            /**
             * Properties of a SubAggSort.
             * @memberof search.proto
             * @interface ISubAggSort
             * @property {string|null} [subAggName] SubAggSort subAggName
             * @property {search.proto.SortOrder|null} [order] SubAggSort order
             */

            /**
             * Constructs a new SubAggSort.
             * @memberof search.proto
             * @classdesc Represents a SubAggSort.
             * @implements ISubAggSort
             * @constructor
             * @param {search.proto.ISubAggSort=} [properties] Properties to set
             */
            function SubAggSort(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SubAggSort subAggName.
             * @member {string} subAggName
             * @memberof search.proto.SubAggSort
             * @instance
             */
            SubAggSort.prototype.subAggName = "";

            /**
             * SubAggSort order.
             * @member {search.proto.SortOrder} order
             * @memberof search.proto.SubAggSort
             * @instance
             */
            SubAggSort.prototype.order = 0;

            /**
             * Creates a new SubAggSort instance using the specified properties.
             * @function create
             * @memberof search.proto.SubAggSort
             * @static
             * @param {search.proto.ISubAggSort=} [properties] Properties to set
             * @returns {search.proto.SubAggSort} SubAggSort instance
             */
            SubAggSort.create = function create(properties) {
                return new SubAggSort(properties);
            };

            /**
             * Encodes the specified SubAggSort message. Does not implicitly {@link search.proto.SubAggSort.verify|verify} messages.
             * @function encode
             * @memberof search.proto.SubAggSort
             * @static
             * @param {search.proto.ISubAggSort} message SubAggSort message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SubAggSort.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.subAggName != null && Object.hasOwnProperty.call(message, "subAggName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.subAggName);
                if (message.order != null && Object.hasOwnProperty.call(message, "order"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.order);
                return writer;
            };

            /**
             * Encodes the specified SubAggSort message, length delimited. Does not implicitly {@link search.proto.SubAggSort.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.SubAggSort
             * @static
             * @param {search.proto.ISubAggSort} message SubAggSort message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SubAggSort.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SubAggSort message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.SubAggSort
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.SubAggSort} SubAggSort
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SubAggSort.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.SubAggSort();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.subAggName = reader.string();
                        break;
                    case 2:
                        message.order = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SubAggSort message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.SubAggSort
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.SubAggSort} SubAggSort
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SubAggSort.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SubAggSort message.
             * @function verify
             * @memberof search.proto.SubAggSort
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SubAggSort.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.subAggName != null && message.hasOwnProperty("subAggName"))
                    if (!$util.isString(message.subAggName))
                        return "subAggName: string expected";
                if (message.order != null && message.hasOwnProperty("order"))
                    switch (message.order) {
                    default:
                        return "order: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };

            /**
             * Creates a SubAggSort message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.SubAggSort
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.SubAggSort} SubAggSort
             */
            SubAggSort.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.SubAggSort)
                    return object;
                var message = new $root.search.proto.SubAggSort();
                if (object.subAggName != null)
                    message.subAggName = String(object.subAggName);
                switch (object.order) {
                case "SORT_ORDER_ASC":
                case 0:
                    message.order = 0;
                    break;
                case "SORT_ORDER_DESC":
                case 1:
                    message.order = 1;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a SubAggSort message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.SubAggSort
             * @static
             * @param {search.proto.SubAggSort} message SubAggSort
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SubAggSort.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.subAggName = "";
                    object.order = options.enums === String ? "SORT_ORDER_ASC" : 0;
                }
                if (message.subAggName != null && message.hasOwnProperty("subAggName"))
                    object.subAggName = message.subAggName;
                if (message.order != null && message.hasOwnProperty("order"))
                    object.order = options.enums === String ? $root.search.proto.SortOrder[message.order] : message.order;
                return object;
            };

            /**
             * Converts this SubAggSort to JSON.
             * @function toJSON
             * @memberof search.proto.SubAggSort
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SubAggSort.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SubAggSort;
        })();

        proto.GroupBySorter = (function() {

            /**
             * Properties of a GroupBySorter.
             * @memberof search.proto
             * @interface IGroupBySorter
             * @property {search.proto.IGroupKeySort|null} [groupKeySort] GroupBySorter groupKeySort
             * @property {search.proto.IRowCountSort|null} [rowCountSort] GroupBySorter rowCountSort
             * @property {search.proto.ISubAggSort|null} [subAggSort] GroupBySorter subAggSort
             */

            /**
             * Constructs a new GroupBySorter.
             * @memberof search.proto
             * @classdesc Represents a GroupBySorter.
             * @implements IGroupBySorter
             * @constructor
             * @param {search.proto.IGroupBySorter=} [properties] Properties to set
             */
            function GroupBySorter(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupBySorter groupKeySort.
             * @member {search.proto.IGroupKeySort|null|undefined} groupKeySort
             * @memberof search.proto.GroupBySorter
             * @instance
             */
            GroupBySorter.prototype.groupKeySort = null;

            /**
             * GroupBySorter rowCountSort.
             * @member {search.proto.IRowCountSort|null|undefined} rowCountSort
             * @memberof search.proto.GroupBySorter
             * @instance
             */
            GroupBySorter.prototype.rowCountSort = null;

            /**
             * GroupBySorter subAggSort.
             * @member {search.proto.ISubAggSort|null|undefined} subAggSort
             * @memberof search.proto.GroupBySorter
             * @instance
             */
            GroupBySorter.prototype.subAggSort = null;

            /**
             * Creates a new GroupBySorter instance using the specified properties.
             * @function create
             * @memberof search.proto.GroupBySorter
             * @static
             * @param {search.proto.IGroupBySorter=} [properties] Properties to set
             * @returns {search.proto.GroupBySorter} GroupBySorter instance
             */
            GroupBySorter.create = function create(properties) {
                return new GroupBySorter(properties);
            };

            /**
             * Encodes the specified GroupBySorter message. Does not implicitly {@link search.proto.GroupBySorter.verify|verify} messages.
             * @function encode
             * @memberof search.proto.GroupBySorter
             * @static
             * @param {search.proto.IGroupBySorter} message GroupBySorter message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupBySorter.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupKeySort != null && Object.hasOwnProperty.call(message, "groupKeySort"))
                    $root.search.proto.GroupKeySort.encode(message.groupKeySort, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.rowCountSort != null && Object.hasOwnProperty.call(message, "rowCountSort"))
                    $root.search.proto.RowCountSort.encode(message.rowCountSort, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.subAggSort != null && Object.hasOwnProperty.call(message, "subAggSort"))
                    $root.search.proto.SubAggSort.encode(message.subAggSort, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GroupBySorter message, length delimited. Does not implicitly {@link search.proto.GroupBySorter.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.GroupBySorter
             * @static
             * @param {search.proto.IGroupBySorter} message GroupBySorter message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupBySorter.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupBySorter message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.GroupBySorter
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.GroupBySorter} GroupBySorter
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupBySorter.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.GroupBySorter();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.groupKeySort = $root.search.proto.GroupKeySort.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.rowCountSort = $root.search.proto.RowCountSort.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.subAggSort = $root.search.proto.SubAggSort.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupBySorter message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.GroupBySorter
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.GroupBySorter} GroupBySorter
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupBySorter.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupBySorter message.
             * @function verify
             * @memberof search.proto.GroupBySorter
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupBySorter.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupKeySort != null && message.hasOwnProperty("groupKeySort")) {
                    var error = $root.search.proto.GroupKeySort.verify(message.groupKeySort);
                    if (error)
                        return "groupKeySort." + error;
                }
                if (message.rowCountSort != null && message.hasOwnProperty("rowCountSort")) {
                    var error = $root.search.proto.RowCountSort.verify(message.rowCountSort);
                    if (error)
                        return "rowCountSort." + error;
                }
                if (message.subAggSort != null && message.hasOwnProperty("subAggSort")) {
                    var error = $root.search.proto.SubAggSort.verify(message.subAggSort);
                    if (error)
                        return "subAggSort." + error;
                }
                return null;
            };

            /**
             * Creates a GroupBySorter message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.GroupBySorter
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.GroupBySorter} GroupBySorter
             */
            GroupBySorter.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.GroupBySorter)
                    return object;
                var message = new $root.search.proto.GroupBySorter();
                if (object.groupKeySort != null) {
                    if (typeof object.groupKeySort !== "object")
                        throw TypeError(".search.proto.GroupBySorter.groupKeySort: object expected");
                    message.groupKeySort = $root.search.proto.GroupKeySort.fromObject(object.groupKeySort);
                }
                if (object.rowCountSort != null) {
                    if (typeof object.rowCountSort !== "object")
                        throw TypeError(".search.proto.GroupBySorter.rowCountSort: object expected");
                    message.rowCountSort = $root.search.proto.RowCountSort.fromObject(object.rowCountSort);
                }
                if (object.subAggSort != null) {
                    if (typeof object.subAggSort !== "object")
                        throw TypeError(".search.proto.GroupBySorter.subAggSort: object expected");
                    message.subAggSort = $root.search.proto.SubAggSort.fromObject(object.subAggSort);
                }
                return message;
            };

            /**
             * Creates a plain object from a GroupBySorter message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.GroupBySorter
             * @static
             * @param {search.proto.GroupBySorter} message GroupBySorter
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupBySorter.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.groupKeySort = null;
                    object.rowCountSort = null;
                    object.subAggSort = null;
                }
                if (message.groupKeySort != null && message.hasOwnProperty("groupKeySort"))
                    object.groupKeySort = $root.search.proto.GroupKeySort.toObject(message.groupKeySort, options);
                if (message.rowCountSort != null && message.hasOwnProperty("rowCountSort"))
                    object.rowCountSort = $root.search.proto.RowCountSort.toObject(message.rowCountSort, options);
                if (message.subAggSort != null && message.hasOwnProperty("subAggSort"))
                    object.subAggSort = $root.search.proto.SubAggSort.toObject(message.subAggSort, options);
                return object;
            };

            /**
             * Converts this GroupBySorter to JSON.
             * @function toJSON
             * @memberof search.proto.GroupBySorter
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupBySorter.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GroupBySorter;
        })();

        proto.GroupBySort = (function() {

            /**
             * Properties of a GroupBySort.
             * @memberof search.proto
             * @interface IGroupBySort
             * @property {Array.<search.proto.IGroupBySorter>|null} [sorters] GroupBySort sorters
             */

            /**
             * Constructs a new GroupBySort.
             * @memberof search.proto
             * @classdesc Represents a GroupBySort.
             * @implements IGroupBySort
             * @constructor
             * @param {search.proto.IGroupBySort=} [properties] Properties to set
             */
            function GroupBySort(properties) {
                this.sorters = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupBySort sorters.
             * @member {Array.<search.proto.IGroupBySorter>} sorters
             * @memberof search.proto.GroupBySort
             * @instance
             */
            GroupBySort.prototype.sorters = $util.emptyArray;

            /**
             * Creates a new GroupBySort instance using the specified properties.
             * @function create
             * @memberof search.proto.GroupBySort
             * @static
             * @param {search.proto.IGroupBySort=} [properties] Properties to set
             * @returns {search.proto.GroupBySort} GroupBySort instance
             */
            GroupBySort.create = function create(properties) {
                return new GroupBySort(properties);
            };

            /**
             * Encodes the specified GroupBySort message. Does not implicitly {@link search.proto.GroupBySort.verify|verify} messages.
             * @function encode
             * @memberof search.proto.GroupBySort
             * @static
             * @param {search.proto.IGroupBySort} message GroupBySort message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupBySort.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sorters != null && message.sorters.length)
                    for (var i = 0; i < message.sorters.length; ++i)
                        $root.search.proto.GroupBySorter.encode(message.sorters[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GroupBySort message, length delimited. Does not implicitly {@link search.proto.GroupBySort.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.GroupBySort
             * @static
             * @param {search.proto.IGroupBySort} message GroupBySort message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupBySort.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupBySort message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.GroupBySort
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.GroupBySort} GroupBySort
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupBySort.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.GroupBySort();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.sorters && message.sorters.length))
                            message.sorters = [];
                        message.sorters.push($root.search.proto.GroupBySorter.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupBySort message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.GroupBySort
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.GroupBySort} GroupBySort
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupBySort.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupBySort message.
             * @function verify
             * @memberof search.proto.GroupBySort
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupBySort.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sorters != null && message.hasOwnProperty("sorters")) {
                    if (!Array.isArray(message.sorters))
                        return "sorters: array expected";
                    for (var i = 0; i < message.sorters.length; ++i) {
                        var error = $root.search.proto.GroupBySorter.verify(message.sorters[i]);
                        if (error)
                            return "sorters." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GroupBySort message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.GroupBySort
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.GroupBySort} GroupBySort
             */
            GroupBySort.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.GroupBySort)
                    return object;
                var message = new $root.search.proto.GroupBySort();
                if (object.sorters) {
                    if (!Array.isArray(object.sorters))
                        throw TypeError(".search.proto.GroupBySort.sorters: array expected");
                    message.sorters = [];
                    for (var i = 0; i < object.sorters.length; ++i) {
                        if (typeof object.sorters[i] !== "object")
                            throw TypeError(".search.proto.GroupBySort.sorters: object expected");
                        message.sorters[i] = $root.search.proto.GroupBySorter.fromObject(object.sorters[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GroupBySort message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.GroupBySort
             * @static
             * @param {search.proto.GroupBySort} message GroupBySort
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupBySort.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.sorters = [];
                if (message.sorters && message.sorters.length) {
                    object.sorters = [];
                    for (var j = 0; j < message.sorters.length; ++j)
                        object.sorters[j] = $root.search.proto.GroupBySorter.toObject(message.sorters[j], options);
                }
                return object;
            };

            /**
             * Converts this GroupBySort to JSON.
             * @function toJSON
             * @memberof search.proto.GroupBySort
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupBySort.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GroupBySort;
        })();

        proto.GroupByComposite = (function() {

            /**
             * Properties of a GroupByComposite.
             * @memberof search.proto
             * @interface IGroupByComposite
             * @property {search.proto.IGroupBys|null} [sources] GroupByComposite sources
             * @property {number|null} [size] GroupByComposite size
             * @property {search.proto.IAggregations|null} [subAggs] GroupByComposite subAggs
             * @property {search.proto.IGroupBys|null} [subGroupBys] GroupByComposite subGroupBys
             * @property {string|null} [nextToken] GroupByComposite nextToken
             */

            /**
             * Constructs a new GroupByComposite.
             * @memberof search.proto
             * @classdesc Represents a GroupByComposite.
             * @implements IGroupByComposite
             * @constructor
             * @param {search.proto.IGroupByComposite=} [properties] Properties to set
             */
            function GroupByComposite(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupByComposite sources.
             * @member {search.proto.IGroupBys|null|undefined} sources
             * @memberof search.proto.GroupByComposite
             * @instance
             */
            GroupByComposite.prototype.sources = null;

            /**
             * GroupByComposite size.
             * @member {number} size
             * @memberof search.proto.GroupByComposite
             * @instance
             */
            GroupByComposite.prototype.size = 0;

            /**
             * GroupByComposite subAggs.
             * @member {search.proto.IAggregations|null|undefined} subAggs
             * @memberof search.proto.GroupByComposite
             * @instance
             */
            GroupByComposite.prototype.subAggs = null;

            /**
             * GroupByComposite subGroupBys.
             * @member {search.proto.IGroupBys|null|undefined} subGroupBys
             * @memberof search.proto.GroupByComposite
             * @instance
             */
            GroupByComposite.prototype.subGroupBys = null;

            /**
             * GroupByComposite nextToken.
             * @member {string} nextToken
             * @memberof search.proto.GroupByComposite
             * @instance
             */
            GroupByComposite.prototype.nextToken = "";

            /**
             * Creates a new GroupByComposite instance using the specified properties.
             * @function create
             * @memberof search.proto.GroupByComposite
             * @static
             * @param {search.proto.IGroupByComposite=} [properties] Properties to set
             * @returns {search.proto.GroupByComposite} GroupByComposite instance
             */
            GroupByComposite.create = function create(properties) {
                return new GroupByComposite(properties);
            };

            /**
             * Encodes the specified GroupByComposite message. Does not implicitly {@link search.proto.GroupByComposite.verify|verify} messages.
             * @function encode
             * @memberof search.proto.GroupByComposite
             * @static
             * @param {search.proto.IGroupByComposite} message GroupByComposite message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByComposite.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sources != null && Object.hasOwnProperty.call(message, "sources"))
                    $root.search.proto.GroupBys.encode(message.sources, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.size != null && Object.hasOwnProperty.call(message, "size"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.size);
                if (message.subAggs != null && Object.hasOwnProperty.call(message, "subAggs"))
                    $root.search.proto.Aggregations.encode(message.subAggs, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.subGroupBys != null && Object.hasOwnProperty.call(message, "subGroupBys"))
                    $root.search.proto.GroupBys.encode(message.subGroupBys, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.nextToken != null && Object.hasOwnProperty.call(message, "nextToken"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.nextToken);
                return writer;
            };

            /**
             * Encodes the specified GroupByComposite message, length delimited. Does not implicitly {@link search.proto.GroupByComposite.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.GroupByComposite
             * @static
             * @param {search.proto.IGroupByComposite} message GroupByComposite message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByComposite.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupByComposite message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.GroupByComposite
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.GroupByComposite} GroupByComposite
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByComposite.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.GroupByComposite();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sources = $root.search.proto.GroupBys.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.size = reader.int32();
                        break;
                    case 4:
                        message.subAggs = $root.search.proto.Aggregations.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.subGroupBys = $root.search.proto.GroupBys.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.nextToken = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupByComposite message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.GroupByComposite
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.GroupByComposite} GroupByComposite
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByComposite.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupByComposite message.
             * @function verify
             * @memberof search.proto.GroupByComposite
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupByComposite.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sources != null && message.hasOwnProperty("sources")) {
                    var error = $root.search.proto.GroupBys.verify(message.sources);
                    if (error)
                        return "sources." + error;
                }
                if (message.size != null && message.hasOwnProperty("size"))
                    if (!$util.isInteger(message.size))
                        return "size: integer expected";
                if (message.subAggs != null && message.hasOwnProperty("subAggs")) {
                    var error = $root.search.proto.Aggregations.verify(message.subAggs);
                    if (error)
                        return "subAggs." + error;
                }
                if (message.subGroupBys != null && message.hasOwnProperty("subGroupBys")) {
                    var error = $root.search.proto.GroupBys.verify(message.subGroupBys);
                    if (error)
                        return "subGroupBys." + error;
                }
                if (message.nextToken != null && message.hasOwnProperty("nextToken"))
                    if (!$util.isString(message.nextToken))
                        return "nextToken: string expected";
                return null;
            };

            /**
             * Creates a GroupByComposite message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.GroupByComposite
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.GroupByComposite} GroupByComposite
             */
            GroupByComposite.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.GroupByComposite)
                    return object;
                var message = new $root.search.proto.GroupByComposite();
                if (object.sources != null) {
                    if (typeof object.sources !== "object")
                        throw TypeError(".search.proto.GroupByComposite.sources: object expected");
                    message.sources = $root.search.proto.GroupBys.fromObject(object.sources);
                }
                if (object.size != null)
                    message.size = object.size | 0;
                if (object.subAggs != null) {
                    if (typeof object.subAggs !== "object")
                        throw TypeError(".search.proto.GroupByComposite.subAggs: object expected");
                    message.subAggs = $root.search.proto.Aggregations.fromObject(object.subAggs);
                }
                if (object.subGroupBys != null) {
                    if (typeof object.subGroupBys !== "object")
                        throw TypeError(".search.proto.GroupByComposite.subGroupBys: object expected");
                    message.subGroupBys = $root.search.proto.GroupBys.fromObject(object.subGroupBys);
                }
                if (object.nextToken != null)
                    message.nextToken = String(object.nextToken);
                return message;
            };

            /**
             * Creates a plain object from a GroupByComposite message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.GroupByComposite
             * @static
             * @param {search.proto.GroupByComposite} message GroupByComposite
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupByComposite.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.sources = null;
                    object.size = 0;
                    object.subAggs = null;
                    object.subGroupBys = null;
                    object.nextToken = "";
                }
                if (message.sources != null && message.hasOwnProperty("sources"))
                    object.sources = $root.search.proto.GroupBys.toObject(message.sources, options);
                if (message.size != null && message.hasOwnProperty("size"))
                    object.size = message.size;
                if (message.subAggs != null && message.hasOwnProperty("subAggs"))
                    object.subAggs = $root.search.proto.Aggregations.toObject(message.subAggs, options);
                if (message.subGroupBys != null && message.hasOwnProperty("subGroupBys"))
                    object.subGroupBys = $root.search.proto.GroupBys.toObject(message.subGroupBys, options);
                if (message.nextToken != null && message.hasOwnProperty("nextToken"))
                    object.nextToken = message.nextToken;
                return object;
            };

            /**
             * Converts this GroupByComposite to JSON.
             * @function toJSON
             * @memberof search.proto.GroupByComposite
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupByComposite.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GroupByComposite;
        })();

        proto.GroupByCompositeResultItem = (function() {

            /**
             * Properties of a GroupByCompositeResultItem.
             * @memberof search.proto
             * @interface IGroupByCompositeResultItem
             * @property {Array.<string>|null} [keys] GroupByCompositeResultItem keys
             * @property {number|Long|null} [rowCount] GroupByCompositeResultItem rowCount
             * @property {search.proto.IAggregationsResult|null} [subAggsResult] GroupByCompositeResultItem subAggsResult
             * @property {search.proto.IGroupBysResult|null} [subGroupBysResult] GroupByCompositeResultItem subGroupBysResult
             */

            /**
             * Constructs a new GroupByCompositeResultItem.
             * @memberof search.proto
             * @classdesc Represents a GroupByCompositeResultItem.
             * @implements IGroupByCompositeResultItem
             * @constructor
             * @param {search.proto.IGroupByCompositeResultItem=} [properties] Properties to set
             */
            function GroupByCompositeResultItem(properties) {
                this.keys = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupByCompositeResultItem keys.
             * @member {Array.<string>} keys
             * @memberof search.proto.GroupByCompositeResultItem
             * @instance
             */
            GroupByCompositeResultItem.prototype.keys = $util.emptyArray;

            /**
             * GroupByCompositeResultItem rowCount.
             * @member {number|Long} rowCount
             * @memberof search.proto.GroupByCompositeResultItem
             * @instance
             */
            GroupByCompositeResultItem.prototype.rowCount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * GroupByCompositeResultItem subAggsResult.
             * @member {search.proto.IAggregationsResult|null|undefined} subAggsResult
             * @memberof search.proto.GroupByCompositeResultItem
             * @instance
             */
            GroupByCompositeResultItem.prototype.subAggsResult = null;

            /**
             * GroupByCompositeResultItem subGroupBysResult.
             * @member {search.proto.IGroupBysResult|null|undefined} subGroupBysResult
             * @memberof search.proto.GroupByCompositeResultItem
             * @instance
             */
            GroupByCompositeResultItem.prototype.subGroupBysResult = null;

            /**
             * Creates a new GroupByCompositeResultItem instance using the specified properties.
             * @function create
             * @memberof search.proto.GroupByCompositeResultItem
             * @static
             * @param {search.proto.IGroupByCompositeResultItem=} [properties] Properties to set
             * @returns {search.proto.GroupByCompositeResultItem} GroupByCompositeResultItem instance
             */
            GroupByCompositeResultItem.create = function create(properties) {
                return new GroupByCompositeResultItem(properties);
            };

            /**
             * Encodes the specified GroupByCompositeResultItem message. Does not implicitly {@link search.proto.GroupByCompositeResultItem.verify|verify} messages.
             * @function encode
             * @memberof search.proto.GroupByCompositeResultItem
             * @static
             * @param {search.proto.IGroupByCompositeResultItem} message GroupByCompositeResultItem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByCompositeResultItem.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.keys != null && message.keys.length)
                    for (var i = 0; i < message.keys.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.keys[i]);
                if (message.rowCount != null && Object.hasOwnProperty.call(message, "rowCount"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.rowCount);
                if (message.subAggsResult != null && Object.hasOwnProperty.call(message, "subAggsResult"))
                    $root.search.proto.AggregationsResult.encode(message.subAggsResult, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.subGroupBysResult != null && Object.hasOwnProperty.call(message, "subGroupBysResult"))
                    $root.search.proto.GroupBysResult.encode(message.subGroupBysResult, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GroupByCompositeResultItem message, length delimited. Does not implicitly {@link search.proto.GroupByCompositeResultItem.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.GroupByCompositeResultItem
             * @static
             * @param {search.proto.IGroupByCompositeResultItem} message GroupByCompositeResultItem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByCompositeResultItem.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupByCompositeResultItem message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.GroupByCompositeResultItem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.GroupByCompositeResultItem} GroupByCompositeResultItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByCompositeResultItem.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.GroupByCompositeResultItem();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.keys && message.keys.length))
                            message.keys = [];
                        message.keys.push(reader.string());
                        break;
                    case 2:
                        message.rowCount = reader.int64();
                        break;
                    case 3:
                        message.subAggsResult = $root.search.proto.AggregationsResult.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.subGroupBysResult = $root.search.proto.GroupBysResult.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupByCompositeResultItem message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.GroupByCompositeResultItem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.GroupByCompositeResultItem} GroupByCompositeResultItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByCompositeResultItem.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupByCompositeResultItem message.
             * @function verify
             * @memberof search.proto.GroupByCompositeResultItem
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupByCompositeResultItem.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.keys != null && message.hasOwnProperty("keys")) {
                    if (!Array.isArray(message.keys))
                        return "keys: array expected";
                    for (var i = 0; i < message.keys.length; ++i)
                        if (!$util.isString(message.keys[i]))
                            return "keys: string[] expected";
                }
                if (message.rowCount != null && message.hasOwnProperty("rowCount"))
                    if (!$util.isInteger(message.rowCount) && !(message.rowCount && $util.isInteger(message.rowCount.low) && $util.isInteger(message.rowCount.high)))
                        return "rowCount: integer|Long expected";
                if (message.subAggsResult != null && message.hasOwnProperty("subAggsResult")) {
                    var error = $root.search.proto.AggregationsResult.verify(message.subAggsResult);
                    if (error)
                        return "subAggsResult." + error;
                }
                if (message.subGroupBysResult != null && message.hasOwnProperty("subGroupBysResult")) {
                    var error = $root.search.proto.GroupBysResult.verify(message.subGroupBysResult);
                    if (error)
                        return "subGroupBysResult." + error;
                }
                return null;
            };

            /**
             * Creates a GroupByCompositeResultItem message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.GroupByCompositeResultItem
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.GroupByCompositeResultItem} GroupByCompositeResultItem
             */
            GroupByCompositeResultItem.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.GroupByCompositeResultItem)
                    return object;
                var message = new $root.search.proto.GroupByCompositeResultItem();
                if (object.keys) {
                    if (!Array.isArray(object.keys))
                        throw TypeError(".search.proto.GroupByCompositeResultItem.keys: array expected");
                    message.keys = [];
                    for (var i = 0; i < object.keys.length; ++i)
                        message.keys[i] = String(object.keys[i]);
                }
                if (object.rowCount != null)
                    if ($util.Long)
                        (message.rowCount = $util.Long.fromValue(object.rowCount)).unsigned = false;
                    else if (typeof object.rowCount === "string")
                        message.rowCount = parseInt(object.rowCount, 10);
                    else if (typeof object.rowCount === "number")
                        message.rowCount = object.rowCount;
                    else if (typeof object.rowCount === "object")
                        message.rowCount = new $util.LongBits(object.rowCount.low >>> 0, object.rowCount.high >>> 0).toNumber();
                if (object.subAggsResult != null) {
                    if (typeof object.subAggsResult !== "object")
                        throw TypeError(".search.proto.GroupByCompositeResultItem.subAggsResult: object expected");
                    message.subAggsResult = $root.search.proto.AggregationsResult.fromObject(object.subAggsResult);
                }
                if (object.subGroupBysResult != null) {
                    if (typeof object.subGroupBysResult !== "object")
                        throw TypeError(".search.proto.GroupByCompositeResultItem.subGroupBysResult: object expected");
                    message.subGroupBysResult = $root.search.proto.GroupBysResult.fromObject(object.subGroupBysResult);
                }
                return message;
            };

            /**
             * Creates a plain object from a GroupByCompositeResultItem message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.GroupByCompositeResultItem
             * @static
             * @param {search.proto.GroupByCompositeResultItem} message GroupByCompositeResultItem
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupByCompositeResultItem.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.keys = [];
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.rowCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.rowCount = options.longs === String ? "0" : 0;
                    object.subAggsResult = null;
                    object.subGroupBysResult = null;
                }
                if (message.keys && message.keys.length) {
                    object.keys = [];
                    for (var j = 0; j < message.keys.length; ++j)
                        object.keys[j] = message.keys[j];
                }
                if (message.rowCount != null && message.hasOwnProperty("rowCount"))
                    if (typeof message.rowCount === "number")
                        object.rowCount = options.longs === String ? String(message.rowCount) : message.rowCount;
                    else
                        object.rowCount = options.longs === String ? $util.Long.prototype.toString.call(message.rowCount) : options.longs === Number ? new $util.LongBits(message.rowCount.low >>> 0, message.rowCount.high >>> 0).toNumber() : message.rowCount;
                if (message.subAggsResult != null && message.hasOwnProperty("subAggsResult"))
                    object.subAggsResult = $root.search.proto.AggregationsResult.toObject(message.subAggsResult, options);
                if (message.subGroupBysResult != null && message.hasOwnProperty("subGroupBysResult"))
                    object.subGroupBysResult = $root.search.proto.GroupBysResult.toObject(message.subGroupBysResult, options);
                return object;
            };

            /**
             * Converts this GroupByCompositeResultItem to JSON.
             * @function toJSON
             * @memberof search.proto.GroupByCompositeResultItem
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupByCompositeResultItem.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GroupByCompositeResultItem;
        })();

        proto.GroupByCompositeResult = (function() {

            /**
             * Properties of a GroupByCompositeResult.
             * @memberof search.proto
             * @interface IGroupByCompositeResult
             * @property {Array.<search.proto.IGroupByCompositeResultItem>|null} [groupByCompositeResultItems] GroupByCompositeResult groupByCompositeResultItems
             * @property {Array.<string>|null} [sourceGroupByNames] GroupByCompositeResult sourceGroupByNames
             * @property {string|null} [nextToken] GroupByCompositeResult nextToken
             */

            /**
             * Constructs a new GroupByCompositeResult.
             * @memberof search.proto
             * @classdesc Represents a GroupByCompositeResult.
             * @implements IGroupByCompositeResult
             * @constructor
             * @param {search.proto.IGroupByCompositeResult=} [properties] Properties to set
             */
            function GroupByCompositeResult(properties) {
                this.groupByCompositeResultItems = [];
                this.sourceGroupByNames = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupByCompositeResult groupByCompositeResultItems.
             * @member {Array.<search.proto.IGroupByCompositeResultItem>} groupByCompositeResultItems
             * @memberof search.proto.GroupByCompositeResult
             * @instance
             */
            GroupByCompositeResult.prototype.groupByCompositeResultItems = $util.emptyArray;

            /**
             * GroupByCompositeResult sourceGroupByNames.
             * @member {Array.<string>} sourceGroupByNames
             * @memberof search.proto.GroupByCompositeResult
             * @instance
             */
            GroupByCompositeResult.prototype.sourceGroupByNames = $util.emptyArray;

            /**
             * GroupByCompositeResult nextToken.
             * @member {string} nextToken
             * @memberof search.proto.GroupByCompositeResult
             * @instance
             */
            GroupByCompositeResult.prototype.nextToken = "";

            /**
             * Creates a new GroupByCompositeResult instance using the specified properties.
             * @function create
             * @memberof search.proto.GroupByCompositeResult
             * @static
             * @param {search.proto.IGroupByCompositeResult=} [properties] Properties to set
             * @returns {search.proto.GroupByCompositeResult} GroupByCompositeResult instance
             */
            GroupByCompositeResult.create = function create(properties) {
                return new GroupByCompositeResult(properties);
            };

            /**
             * Encodes the specified GroupByCompositeResult message. Does not implicitly {@link search.proto.GroupByCompositeResult.verify|verify} messages.
             * @function encode
             * @memberof search.proto.GroupByCompositeResult
             * @static
             * @param {search.proto.IGroupByCompositeResult} message GroupByCompositeResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByCompositeResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupByCompositeResultItems != null && message.groupByCompositeResultItems.length)
                    for (var i = 0; i < message.groupByCompositeResultItems.length; ++i)
                        $root.search.proto.GroupByCompositeResultItem.encode(message.groupByCompositeResultItems[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.sourceGroupByNames != null && message.sourceGroupByNames.length)
                    for (var i = 0; i < message.sourceGroupByNames.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.sourceGroupByNames[i]);
                if (message.nextToken != null && Object.hasOwnProperty.call(message, "nextToken"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.nextToken);
                return writer;
            };

            /**
             * Encodes the specified GroupByCompositeResult message, length delimited. Does not implicitly {@link search.proto.GroupByCompositeResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.GroupByCompositeResult
             * @static
             * @param {search.proto.IGroupByCompositeResult} message GroupByCompositeResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByCompositeResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupByCompositeResult message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.GroupByCompositeResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.GroupByCompositeResult} GroupByCompositeResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByCompositeResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.GroupByCompositeResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.groupByCompositeResultItems && message.groupByCompositeResultItems.length))
                            message.groupByCompositeResultItems = [];
                        message.groupByCompositeResultItems.push($root.search.proto.GroupByCompositeResultItem.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        if (!(message.sourceGroupByNames && message.sourceGroupByNames.length))
                            message.sourceGroupByNames = [];
                        message.sourceGroupByNames.push(reader.string());
                        break;
                    case 3:
                        message.nextToken = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupByCompositeResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.GroupByCompositeResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.GroupByCompositeResult} GroupByCompositeResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByCompositeResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupByCompositeResult message.
             * @function verify
             * @memberof search.proto.GroupByCompositeResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupByCompositeResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupByCompositeResultItems != null && message.hasOwnProperty("groupByCompositeResultItems")) {
                    if (!Array.isArray(message.groupByCompositeResultItems))
                        return "groupByCompositeResultItems: array expected";
                    for (var i = 0; i < message.groupByCompositeResultItems.length; ++i) {
                        var error = $root.search.proto.GroupByCompositeResultItem.verify(message.groupByCompositeResultItems[i]);
                        if (error)
                            return "groupByCompositeResultItems." + error;
                    }
                }
                if (message.sourceGroupByNames != null && message.hasOwnProperty("sourceGroupByNames")) {
                    if (!Array.isArray(message.sourceGroupByNames))
                        return "sourceGroupByNames: array expected";
                    for (var i = 0; i < message.sourceGroupByNames.length; ++i)
                        if (!$util.isString(message.sourceGroupByNames[i]))
                            return "sourceGroupByNames: string[] expected";
                }
                if (message.nextToken != null && message.hasOwnProperty("nextToken"))
                    if (!$util.isString(message.nextToken))
                        return "nextToken: string expected";
                return null;
            };

            /**
             * Creates a GroupByCompositeResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.GroupByCompositeResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.GroupByCompositeResult} GroupByCompositeResult
             */
            GroupByCompositeResult.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.GroupByCompositeResult)
                    return object;
                var message = new $root.search.proto.GroupByCompositeResult();
                if (object.groupByCompositeResultItems) {
                    if (!Array.isArray(object.groupByCompositeResultItems))
                        throw TypeError(".search.proto.GroupByCompositeResult.groupByCompositeResultItems: array expected");
                    message.groupByCompositeResultItems = [];
                    for (var i = 0; i < object.groupByCompositeResultItems.length; ++i) {
                        if (typeof object.groupByCompositeResultItems[i] !== "object")
                            throw TypeError(".search.proto.GroupByCompositeResult.groupByCompositeResultItems: object expected");
                        message.groupByCompositeResultItems[i] = $root.search.proto.GroupByCompositeResultItem.fromObject(object.groupByCompositeResultItems[i]);
                    }
                }
                if (object.sourceGroupByNames) {
                    if (!Array.isArray(object.sourceGroupByNames))
                        throw TypeError(".search.proto.GroupByCompositeResult.sourceGroupByNames: array expected");
                    message.sourceGroupByNames = [];
                    for (var i = 0; i < object.sourceGroupByNames.length; ++i)
                        message.sourceGroupByNames[i] = String(object.sourceGroupByNames[i]);
                }
                if (object.nextToken != null)
                    message.nextToken = String(object.nextToken);
                return message;
            };

            /**
             * Creates a plain object from a GroupByCompositeResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.GroupByCompositeResult
             * @static
             * @param {search.proto.GroupByCompositeResult} message GroupByCompositeResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupByCompositeResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.groupByCompositeResultItems = [];
                    object.sourceGroupByNames = [];
                }
                if (options.defaults)
                    object.nextToken = "";
                if (message.groupByCompositeResultItems && message.groupByCompositeResultItems.length) {
                    object.groupByCompositeResultItems = [];
                    for (var j = 0; j < message.groupByCompositeResultItems.length; ++j)
                        object.groupByCompositeResultItems[j] = $root.search.proto.GroupByCompositeResultItem.toObject(message.groupByCompositeResultItems[j], options);
                }
                if (message.sourceGroupByNames && message.sourceGroupByNames.length) {
                    object.sourceGroupByNames = [];
                    for (var j = 0; j < message.sourceGroupByNames.length; ++j)
                        object.sourceGroupByNames[j] = message.sourceGroupByNames[j];
                }
                if (message.nextToken != null && message.hasOwnProperty("nextToken"))
                    object.nextToken = message.nextToken;
                return object;
            };

            /**
             * Converts this GroupByCompositeResult to JSON.
             * @function toJSON
             * @memberof search.proto.GroupByCompositeResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupByCompositeResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GroupByCompositeResult;
        })();

        proto.GroupByField = (function() {

            /**
             * Properties of a GroupByField.
             * @memberof search.proto
             * @interface IGroupByField
             * @property {string|null} [fieldName] GroupByField fieldName
             * @property {number|null} [size] GroupByField size
             * @property {search.proto.IGroupBySort|null} [sort] GroupByField sort
             * @property {search.proto.IAggregations|null} [subAggs] GroupByField subAggs
             * @property {search.proto.IGroupBys|null} [subGroupBys] GroupByField subGroupBys
             * @property {number|Long|null} [minDocCount] GroupByField minDocCount
             */

            /**
             * Constructs a new GroupByField.
             * @memberof search.proto
             * @classdesc Represents a GroupByField.
             * @implements IGroupByField
             * @constructor
             * @param {search.proto.IGroupByField=} [properties] Properties to set
             */
            function GroupByField(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupByField fieldName.
             * @member {string} fieldName
             * @memberof search.proto.GroupByField
             * @instance
             */
            GroupByField.prototype.fieldName = "";

            /**
             * GroupByField size.
             * @member {number} size
             * @memberof search.proto.GroupByField
             * @instance
             */
            GroupByField.prototype.size = 0;

            /**
             * GroupByField sort.
             * @member {search.proto.IGroupBySort|null|undefined} sort
             * @memberof search.proto.GroupByField
             * @instance
             */
            GroupByField.prototype.sort = null;

            /**
             * GroupByField subAggs.
             * @member {search.proto.IAggregations|null|undefined} subAggs
             * @memberof search.proto.GroupByField
             * @instance
             */
            GroupByField.prototype.subAggs = null;

            /**
             * GroupByField subGroupBys.
             * @member {search.proto.IGroupBys|null|undefined} subGroupBys
             * @memberof search.proto.GroupByField
             * @instance
             */
            GroupByField.prototype.subGroupBys = null;

            /**
             * GroupByField minDocCount.
             * @member {number|Long} minDocCount
             * @memberof search.proto.GroupByField
             * @instance
             */
            GroupByField.prototype.minDocCount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new GroupByField instance using the specified properties.
             * @function create
             * @memberof search.proto.GroupByField
             * @static
             * @param {search.proto.IGroupByField=} [properties] Properties to set
             * @returns {search.proto.GroupByField} GroupByField instance
             */
            GroupByField.create = function create(properties) {
                return new GroupByField(properties);
            };

            /**
             * Encodes the specified GroupByField message. Does not implicitly {@link search.proto.GroupByField.verify|verify} messages.
             * @function encode
             * @memberof search.proto.GroupByField
             * @static
             * @param {search.proto.IGroupByField} message GroupByField message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByField.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fieldName != null && Object.hasOwnProperty.call(message, "fieldName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fieldName);
                if (message.size != null && Object.hasOwnProperty.call(message, "size"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.size);
                if (message.sort != null && Object.hasOwnProperty.call(message, "sort"))
                    $root.search.proto.GroupBySort.encode(message.sort, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.subAggs != null && Object.hasOwnProperty.call(message, "subAggs"))
                    $root.search.proto.Aggregations.encode(message.subAggs, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.subGroupBys != null && Object.hasOwnProperty.call(message, "subGroupBys"))
                    $root.search.proto.GroupBys.encode(message.subGroupBys, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.minDocCount != null && Object.hasOwnProperty.call(message, "minDocCount"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int64(message.minDocCount);
                return writer;
            };

            /**
             * Encodes the specified GroupByField message, length delimited. Does not implicitly {@link search.proto.GroupByField.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.GroupByField
             * @static
             * @param {search.proto.IGroupByField} message GroupByField message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByField.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupByField message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.GroupByField
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.GroupByField} GroupByField
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByField.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.GroupByField();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fieldName = reader.string();
                        break;
                    case 2:
                        message.size = reader.int32();
                        break;
                    case 3:
                        message.sort = $root.search.proto.GroupBySort.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.subAggs = $root.search.proto.Aggregations.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.subGroupBys = $root.search.proto.GroupBys.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.minDocCount = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupByField message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.GroupByField
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.GroupByField} GroupByField
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByField.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupByField message.
             * @function verify
             * @memberof search.proto.GroupByField
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupByField.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    if (!$util.isString(message.fieldName))
                        return "fieldName: string expected";
                if (message.size != null && message.hasOwnProperty("size"))
                    if (!$util.isInteger(message.size))
                        return "size: integer expected";
                if (message.sort != null && message.hasOwnProperty("sort")) {
                    var error = $root.search.proto.GroupBySort.verify(message.sort);
                    if (error)
                        return "sort." + error;
                }
                if (message.subAggs != null && message.hasOwnProperty("subAggs")) {
                    var error = $root.search.proto.Aggregations.verify(message.subAggs);
                    if (error)
                        return "subAggs." + error;
                }
                if (message.subGroupBys != null && message.hasOwnProperty("subGroupBys")) {
                    var error = $root.search.proto.GroupBys.verify(message.subGroupBys);
                    if (error)
                        return "subGroupBys." + error;
                }
                if (message.minDocCount != null && message.hasOwnProperty("minDocCount"))
                    if (!$util.isInteger(message.minDocCount) && !(message.minDocCount && $util.isInteger(message.minDocCount.low) && $util.isInteger(message.minDocCount.high)))
                        return "minDocCount: integer|Long expected";
                return null;
            };

            /**
             * Creates a GroupByField message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.GroupByField
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.GroupByField} GroupByField
             */
            GroupByField.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.GroupByField)
                    return object;
                var message = new $root.search.proto.GroupByField();
                if (object.fieldName != null)
                    message.fieldName = String(object.fieldName);
                if (object.size != null)
                    message.size = object.size | 0;
                if (object.sort != null) {
                    if (typeof object.sort !== "object")
                        throw TypeError(".search.proto.GroupByField.sort: object expected");
                    message.sort = $root.search.proto.GroupBySort.fromObject(object.sort);
                }
                if (object.subAggs != null) {
                    if (typeof object.subAggs !== "object")
                        throw TypeError(".search.proto.GroupByField.subAggs: object expected");
                    message.subAggs = $root.search.proto.Aggregations.fromObject(object.subAggs);
                }
                if (object.subGroupBys != null) {
                    if (typeof object.subGroupBys !== "object")
                        throw TypeError(".search.proto.GroupByField.subGroupBys: object expected");
                    message.subGroupBys = $root.search.proto.GroupBys.fromObject(object.subGroupBys);
                }
                if (object.minDocCount != null)
                    if ($util.Long)
                        (message.minDocCount = $util.Long.fromValue(object.minDocCount)).unsigned = false;
                    else if (typeof object.minDocCount === "string")
                        message.minDocCount = parseInt(object.minDocCount, 10);
                    else if (typeof object.minDocCount === "number")
                        message.minDocCount = object.minDocCount;
                    else if (typeof object.minDocCount === "object")
                        message.minDocCount = new $util.LongBits(object.minDocCount.low >>> 0, object.minDocCount.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a GroupByField message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.GroupByField
             * @static
             * @param {search.proto.GroupByField} message GroupByField
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupByField.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.fieldName = "";
                    object.size = 0;
                    object.sort = null;
                    object.subAggs = null;
                    object.subGroupBys = null;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.minDocCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.minDocCount = options.longs === String ? "0" : 0;
                }
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    object.fieldName = message.fieldName;
                if (message.size != null && message.hasOwnProperty("size"))
                    object.size = message.size;
                if (message.sort != null && message.hasOwnProperty("sort"))
                    object.sort = $root.search.proto.GroupBySort.toObject(message.sort, options);
                if (message.subAggs != null && message.hasOwnProperty("subAggs"))
                    object.subAggs = $root.search.proto.Aggregations.toObject(message.subAggs, options);
                if (message.subGroupBys != null && message.hasOwnProperty("subGroupBys"))
                    object.subGroupBys = $root.search.proto.GroupBys.toObject(message.subGroupBys, options);
                if (message.minDocCount != null && message.hasOwnProperty("minDocCount"))
                    if (typeof message.minDocCount === "number")
                        object.minDocCount = options.longs === String ? String(message.minDocCount) : message.minDocCount;
                    else
                        object.minDocCount = options.longs === String ? $util.Long.prototype.toString.call(message.minDocCount) : options.longs === Number ? new $util.LongBits(message.minDocCount.low >>> 0, message.minDocCount.high >>> 0).toNumber() : message.minDocCount;
                return object;
            };

            /**
             * Converts this GroupByField to JSON.
             * @function toJSON
             * @memberof search.proto.GroupByField
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupByField.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GroupByField;
        })();

        proto.Range = (function() {

            /**
             * Properties of a Range.
             * @memberof search.proto
             * @interface IRange
             * @property {number|null} [from] Range from
             * @property {number|null} [to] Range to
             */

            /**
             * Constructs a new Range.
             * @memberof search.proto
             * @classdesc Represents a Range.
             * @implements IRange
             * @constructor
             * @param {search.proto.IRange=} [properties] Properties to set
             */
            function Range(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Range from.
             * @member {number} from
             * @memberof search.proto.Range
             * @instance
             */
            Range.prototype.from = 0;

            /**
             * Range to.
             * @member {number} to
             * @memberof search.proto.Range
             * @instance
             */
            Range.prototype.to = 0;

            /**
             * Creates a new Range instance using the specified properties.
             * @function create
             * @memberof search.proto.Range
             * @static
             * @param {search.proto.IRange=} [properties] Properties to set
             * @returns {search.proto.Range} Range instance
             */
            Range.create = function create(properties) {
                return new Range(properties);
            };

            /**
             * Encodes the specified Range message. Does not implicitly {@link search.proto.Range.verify|verify} messages.
             * @function encode
             * @memberof search.proto.Range
             * @static
             * @param {search.proto.IRange} message Range message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Range.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.from);
                if (message.to != null && Object.hasOwnProperty.call(message, "to"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.to);
                return writer;
            };

            /**
             * Encodes the specified Range message, length delimited. Does not implicitly {@link search.proto.Range.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.Range
             * @static
             * @param {search.proto.IRange} message Range message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Range.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Range message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.Range
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.Range} Range
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Range.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.Range();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.from = reader.double();
                        break;
                    case 2:
                        message.to = reader.double();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Range message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.Range
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.Range} Range
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Range.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Range message.
             * @function verify
             * @memberof search.proto.Range
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Range.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.from != null && message.hasOwnProperty("from"))
                    if (typeof message.from !== "number")
                        return "from: number expected";
                if (message.to != null && message.hasOwnProperty("to"))
                    if (typeof message.to !== "number")
                        return "to: number expected";
                return null;
            };

            /**
             * Creates a Range message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.Range
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.Range} Range
             */
            Range.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.Range)
                    return object;
                var message = new $root.search.proto.Range();
                if (object.from != null)
                    message.from = Number(object.from);
                if (object.to != null)
                    message.to = Number(object.to);
                return message;
            };

            /**
             * Creates a plain object from a Range message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.Range
             * @static
             * @param {search.proto.Range} message Range
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Range.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.from = 0;
                    object.to = 0;
                }
                if (message.from != null && message.hasOwnProperty("from"))
                    object.from = options.json && !isFinite(message.from) ? String(message.from) : message.from;
                if (message.to != null && message.hasOwnProperty("to"))
                    object.to = options.json && !isFinite(message.to) ? String(message.to) : message.to;
                return object;
            };

            /**
             * Converts this Range to JSON.
             * @function toJSON
             * @memberof search.proto.Range
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Range.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Range;
        })();

        proto.GroupByRange = (function() {

            /**
             * Properties of a GroupByRange.
             * @memberof search.proto
             * @interface IGroupByRange
             * @property {string|null} [fieldName] GroupByRange fieldName
             * @property {Array.<search.proto.IRange>|null} [ranges] GroupByRange ranges
             * @property {search.proto.IAggregations|null} [subAggs] GroupByRange subAggs
             * @property {search.proto.IGroupBys|null} [subGroupBys] GroupByRange subGroupBys
             */

            /**
             * Constructs a new GroupByRange.
             * @memberof search.proto
             * @classdesc Represents a GroupByRange.
             * @implements IGroupByRange
             * @constructor
             * @param {search.proto.IGroupByRange=} [properties] Properties to set
             */
            function GroupByRange(properties) {
                this.ranges = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupByRange fieldName.
             * @member {string} fieldName
             * @memberof search.proto.GroupByRange
             * @instance
             */
            GroupByRange.prototype.fieldName = "";

            /**
             * GroupByRange ranges.
             * @member {Array.<search.proto.IRange>} ranges
             * @memberof search.proto.GroupByRange
             * @instance
             */
            GroupByRange.prototype.ranges = $util.emptyArray;

            /**
             * GroupByRange subAggs.
             * @member {search.proto.IAggregations|null|undefined} subAggs
             * @memberof search.proto.GroupByRange
             * @instance
             */
            GroupByRange.prototype.subAggs = null;

            /**
             * GroupByRange subGroupBys.
             * @member {search.proto.IGroupBys|null|undefined} subGroupBys
             * @memberof search.proto.GroupByRange
             * @instance
             */
            GroupByRange.prototype.subGroupBys = null;

            /**
             * Creates a new GroupByRange instance using the specified properties.
             * @function create
             * @memberof search.proto.GroupByRange
             * @static
             * @param {search.proto.IGroupByRange=} [properties] Properties to set
             * @returns {search.proto.GroupByRange} GroupByRange instance
             */
            GroupByRange.create = function create(properties) {
                return new GroupByRange(properties);
            };

            /**
             * Encodes the specified GroupByRange message. Does not implicitly {@link search.proto.GroupByRange.verify|verify} messages.
             * @function encode
             * @memberof search.proto.GroupByRange
             * @static
             * @param {search.proto.IGroupByRange} message GroupByRange message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByRange.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fieldName != null && Object.hasOwnProperty.call(message, "fieldName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fieldName);
                if (message.ranges != null && message.ranges.length)
                    for (var i = 0; i < message.ranges.length; ++i)
                        $root.search.proto.Range.encode(message.ranges[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.subAggs != null && Object.hasOwnProperty.call(message, "subAggs"))
                    $root.search.proto.Aggregations.encode(message.subAggs, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.subGroupBys != null && Object.hasOwnProperty.call(message, "subGroupBys"))
                    $root.search.proto.GroupBys.encode(message.subGroupBys, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GroupByRange message, length delimited. Does not implicitly {@link search.proto.GroupByRange.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.GroupByRange
             * @static
             * @param {search.proto.IGroupByRange} message GroupByRange message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByRange.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupByRange message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.GroupByRange
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.GroupByRange} GroupByRange
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByRange.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.GroupByRange();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fieldName = reader.string();
                        break;
                    case 2:
                        if (!(message.ranges && message.ranges.length))
                            message.ranges = [];
                        message.ranges.push($root.search.proto.Range.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.subAggs = $root.search.proto.Aggregations.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.subGroupBys = $root.search.proto.GroupBys.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupByRange message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.GroupByRange
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.GroupByRange} GroupByRange
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByRange.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupByRange message.
             * @function verify
             * @memberof search.proto.GroupByRange
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupByRange.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    if (!$util.isString(message.fieldName))
                        return "fieldName: string expected";
                if (message.ranges != null && message.hasOwnProperty("ranges")) {
                    if (!Array.isArray(message.ranges))
                        return "ranges: array expected";
                    for (var i = 0; i < message.ranges.length; ++i) {
                        var error = $root.search.proto.Range.verify(message.ranges[i]);
                        if (error)
                            return "ranges." + error;
                    }
                }
                if (message.subAggs != null && message.hasOwnProperty("subAggs")) {
                    var error = $root.search.proto.Aggregations.verify(message.subAggs);
                    if (error)
                        return "subAggs." + error;
                }
                if (message.subGroupBys != null && message.hasOwnProperty("subGroupBys")) {
                    var error = $root.search.proto.GroupBys.verify(message.subGroupBys);
                    if (error)
                        return "subGroupBys." + error;
                }
                return null;
            };

            /**
             * Creates a GroupByRange message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.GroupByRange
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.GroupByRange} GroupByRange
             */
            GroupByRange.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.GroupByRange)
                    return object;
                var message = new $root.search.proto.GroupByRange();
                if (object.fieldName != null)
                    message.fieldName = String(object.fieldName);
                if (object.ranges) {
                    if (!Array.isArray(object.ranges))
                        throw TypeError(".search.proto.GroupByRange.ranges: array expected");
                    message.ranges = [];
                    for (var i = 0; i < object.ranges.length; ++i) {
                        if (typeof object.ranges[i] !== "object")
                            throw TypeError(".search.proto.GroupByRange.ranges: object expected");
                        message.ranges[i] = $root.search.proto.Range.fromObject(object.ranges[i]);
                    }
                }
                if (object.subAggs != null) {
                    if (typeof object.subAggs !== "object")
                        throw TypeError(".search.proto.GroupByRange.subAggs: object expected");
                    message.subAggs = $root.search.proto.Aggregations.fromObject(object.subAggs);
                }
                if (object.subGroupBys != null) {
                    if (typeof object.subGroupBys !== "object")
                        throw TypeError(".search.proto.GroupByRange.subGroupBys: object expected");
                    message.subGroupBys = $root.search.proto.GroupBys.fromObject(object.subGroupBys);
                }
                return message;
            };

            /**
             * Creates a plain object from a GroupByRange message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.GroupByRange
             * @static
             * @param {search.proto.GroupByRange} message GroupByRange
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupByRange.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.ranges = [];
                if (options.defaults) {
                    object.fieldName = "";
                    object.subAggs = null;
                    object.subGroupBys = null;
                }
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    object.fieldName = message.fieldName;
                if (message.ranges && message.ranges.length) {
                    object.ranges = [];
                    for (var j = 0; j < message.ranges.length; ++j)
                        object.ranges[j] = $root.search.proto.Range.toObject(message.ranges[j], options);
                }
                if (message.subAggs != null && message.hasOwnProperty("subAggs"))
                    object.subAggs = $root.search.proto.Aggregations.toObject(message.subAggs, options);
                if (message.subGroupBys != null && message.hasOwnProperty("subGroupBys"))
                    object.subGroupBys = $root.search.proto.GroupBys.toObject(message.subGroupBys, options);
                return object;
            };

            /**
             * Converts this GroupByRange to JSON.
             * @function toJSON
             * @memberof search.proto.GroupByRange
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupByRange.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GroupByRange;
        })();

        proto.GroupByFilter = (function() {

            /**
             * Properties of a GroupByFilter.
             * @memberof search.proto
             * @interface IGroupByFilter
             * @property {Array.<search.proto.IQuery>|null} [filters] GroupByFilter filters
             * @property {search.proto.IAggregations|null} [subAggs] GroupByFilter subAggs
             * @property {search.proto.IGroupBys|null} [subGroupBys] GroupByFilter subGroupBys
             */

            /**
             * Constructs a new GroupByFilter.
             * @memberof search.proto
             * @classdesc Represents a GroupByFilter.
             * @implements IGroupByFilter
             * @constructor
             * @param {search.proto.IGroupByFilter=} [properties] Properties to set
             */
            function GroupByFilter(properties) {
                this.filters = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupByFilter filters.
             * @member {Array.<search.proto.IQuery>} filters
             * @memberof search.proto.GroupByFilter
             * @instance
             */
            GroupByFilter.prototype.filters = $util.emptyArray;

            /**
             * GroupByFilter subAggs.
             * @member {search.proto.IAggregations|null|undefined} subAggs
             * @memberof search.proto.GroupByFilter
             * @instance
             */
            GroupByFilter.prototype.subAggs = null;

            /**
             * GroupByFilter subGroupBys.
             * @member {search.proto.IGroupBys|null|undefined} subGroupBys
             * @memberof search.proto.GroupByFilter
             * @instance
             */
            GroupByFilter.prototype.subGroupBys = null;

            /**
             * Creates a new GroupByFilter instance using the specified properties.
             * @function create
             * @memberof search.proto.GroupByFilter
             * @static
             * @param {search.proto.IGroupByFilter=} [properties] Properties to set
             * @returns {search.proto.GroupByFilter} GroupByFilter instance
             */
            GroupByFilter.create = function create(properties) {
                return new GroupByFilter(properties);
            };

            /**
             * Encodes the specified GroupByFilter message. Does not implicitly {@link search.proto.GroupByFilter.verify|verify} messages.
             * @function encode
             * @memberof search.proto.GroupByFilter
             * @static
             * @param {search.proto.IGroupByFilter} message GroupByFilter message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByFilter.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.filters != null && message.filters.length)
                    for (var i = 0; i < message.filters.length; ++i)
                        $root.search.proto.Query.encode(message.filters[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.subAggs != null && Object.hasOwnProperty.call(message, "subAggs"))
                    $root.search.proto.Aggregations.encode(message.subAggs, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.subGroupBys != null && Object.hasOwnProperty.call(message, "subGroupBys"))
                    $root.search.proto.GroupBys.encode(message.subGroupBys, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GroupByFilter message, length delimited. Does not implicitly {@link search.proto.GroupByFilter.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.GroupByFilter
             * @static
             * @param {search.proto.IGroupByFilter} message GroupByFilter message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByFilter.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupByFilter message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.GroupByFilter
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.GroupByFilter} GroupByFilter
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByFilter.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.GroupByFilter();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.filters && message.filters.length))
                            message.filters = [];
                        message.filters.push($root.search.proto.Query.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.subAggs = $root.search.proto.Aggregations.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.subGroupBys = $root.search.proto.GroupBys.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupByFilter message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.GroupByFilter
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.GroupByFilter} GroupByFilter
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByFilter.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupByFilter message.
             * @function verify
             * @memberof search.proto.GroupByFilter
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupByFilter.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.filters != null && message.hasOwnProperty("filters")) {
                    if (!Array.isArray(message.filters))
                        return "filters: array expected";
                    for (var i = 0; i < message.filters.length; ++i) {
                        var error = $root.search.proto.Query.verify(message.filters[i]);
                        if (error)
                            return "filters." + error;
                    }
                }
                if (message.subAggs != null && message.hasOwnProperty("subAggs")) {
                    var error = $root.search.proto.Aggregations.verify(message.subAggs);
                    if (error)
                        return "subAggs." + error;
                }
                if (message.subGroupBys != null && message.hasOwnProperty("subGroupBys")) {
                    var error = $root.search.proto.GroupBys.verify(message.subGroupBys);
                    if (error)
                        return "subGroupBys." + error;
                }
                return null;
            };

            /**
             * Creates a GroupByFilter message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.GroupByFilter
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.GroupByFilter} GroupByFilter
             */
            GroupByFilter.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.GroupByFilter)
                    return object;
                var message = new $root.search.proto.GroupByFilter();
                if (object.filters) {
                    if (!Array.isArray(object.filters))
                        throw TypeError(".search.proto.GroupByFilter.filters: array expected");
                    message.filters = [];
                    for (var i = 0; i < object.filters.length; ++i) {
                        if (typeof object.filters[i] !== "object")
                            throw TypeError(".search.proto.GroupByFilter.filters: object expected");
                        message.filters[i] = $root.search.proto.Query.fromObject(object.filters[i]);
                    }
                }
                if (object.subAggs != null) {
                    if (typeof object.subAggs !== "object")
                        throw TypeError(".search.proto.GroupByFilter.subAggs: object expected");
                    message.subAggs = $root.search.proto.Aggregations.fromObject(object.subAggs);
                }
                if (object.subGroupBys != null) {
                    if (typeof object.subGroupBys !== "object")
                        throw TypeError(".search.proto.GroupByFilter.subGroupBys: object expected");
                    message.subGroupBys = $root.search.proto.GroupBys.fromObject(object.subGroupBys);
                }
                return message;
            };

            /**
             * Creates a plain object from a GroupByFilter message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.GroupByFilter
             * @static
             * @param {search.proto.GroupByFilter} message GroupByFilter
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupByFilter.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.filters = [];
                if (options.defaults) {
                    object.subAggs = null;
                    object.subGroupBys = null;
                }
                if (message.filters && message.filters.length) {
                    object.filters = [];
                    for (var j = 0; j < message.filters.length; ++j)
                        object.filters[j] = $root.search.proto.Query.toObject(message.filters[j], options);
                }
                if (message.subAggs != null && message.hasOwnProperty("subAggs"))
                    object.subAggs = $root.search.proto.Aggregations.toObject(message.subAggs, options);
                if (message.subGroupBys != null && message.hasOwnProperty("subGroupBys"))
                    object.subGroupBys = $root.search.proto.GroupBys.toObject(message.subGroupBys, options);
                return object;
            };

            /**
             * Converts this GroupByFilter to JSON.
             * @function toJSON
             * @memberof search.proto.GroupByFilter
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupByFilter.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GroupByFilter;
        })();

        proto.GeoPoint = (function() {

            /**
             * Properties of a GeoPoint.
             * @memberof search.proto
             * @interface IGeoPoint
             * @property {number|null} [lat] GeoPoint lat
             * @property {number|null} [lon] GeoPoint lon
             */

            /**
             * Constructs a new GeoPoint.
             * @memberof search.proto
             * @classdesc Represents a GeoPoint.
             * @implements IGeoPoint
             * @constructor
             * @param {search.proto.IGeoPoint=} [properties] Properties to set
             */
            function GeoPoint(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GeoPoint lat.
             * @member {number} lat
             * @memberof search.proto.GeoPoint
             * @instance
             */
            GeoPoint.prototype.lat = 0;

            /**
             * GeoPoint lon.
             * @member {number} lon
             * @memberof search.proto.GeoPoint
             * @instance
             */
            GeoPoint.prototype.lon = 0;

            /**
             * Creates a new GeoPoint instance using the specified properties.
             * @function create
             * @memberof search.proto.GeoPoint
             * @static
             * @param {search.proto.IGeoPoint=} [properties] Properties to set
             * @returns {search.proto.GeoPoint} GeoPoint instance
             */
            GeoPoint.create = function create(properties) {
                return new GeoPoint(properties);
            };

            /**
             * Encodes the specified GeoPoint message. Does not implicitly {@link search.proto.GeoPoint.verify|verify} messages.
             * @function encode
             * @memberof search.proto.GeoPoint
             * @static
             * @param {search.proto.IGeoPoint} message GeoPoint message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GeoPoint.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.lat != null && Object.hasOwnProperty.call(message, "lat"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.lat);
                if (message.lon != null && Object.hasOwnProperty.call(message, "lon"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.lon);
                return writer;
            };

            /**
             * Encodes the specified GeoPoint message, length delimited. Does not implicitly {@link search.proto.GeoPoint.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.GeoPoint
             * @static
             * @param {search.proto.IGeoPoint} message GeoPoint message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GeoPoint.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GeoPoint message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.GeoPoint
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.GeoPoint} GeoPoint
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GeoPoint.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.GeoPoint();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.lat = reader.double();
                        break;
                    case 2:
                        message.lon = reader.double();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GeoPoint message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.GeoPoint
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.GeoPoint} GeoPoint
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GeoPoint.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GeoPoint message.
             * @function verify
             * @memberof search.proto.GeoPoint
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GeoPoint.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.lat != null && message.hasOwnProperty("lat"))
                    if (typeof message.lat !== "number")
                        return "lat: number expected";
                if (message.lon != null && message.hasOwnProperty("lon"))
                    if (typeof message.lon !== "number")
                        return "lon: number expected";
                return null;
            };

            /**
             * Creates a GeoPoint message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.GeoPoint
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.GeoPoint} GeoPoint
             */
            GeoPoint.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.GeoPoint)
                    return object;
                var message = new $root.search.proto.GeoPoint();
                if (object.lat != null)
                    message.lat = Number(object.lat);
                if (object.lon != null)
                    message.lon = Number(object.lon);
                return message;
            };

            /**
             * Creates a plain object from a GeoPoint message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.GeoPoint
             * @static
             * @param {search.proto.GeoPoint} message GeoPoint
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GeoPoint.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.lat = 0;
                    object.lon = 0;
                }
                if (message.lat != null && message.hasOwnProperty("lat"))
                    object.lat = options.json && !isFinite(message.lat) ? String(message.lat) : message.lat;
                if (message.lon != null && message.hasOwnProperty("lon"))
                    object.lon = options.json && !isFinite(message.lon) ? String(message.lon) : message.lon;
                return object;
            };

            /**
             * Converts this GeoPoint to JSON.
             * @function toJSON
             * @memberof search.proto.GeoPoint
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GeoPoint.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GeoPoint;
        })();

        proto.GroupByGeoDistance = (function() {

            /**
             * Properties of a GroupByGeoDistance.
             * @memberof search.proto
             * @interface IGroupByGeoDistance
             * @property {string|null} [fieldName] GroupByGeoDistance fieldName
             * @property {search.proto.IGeoPoint|null} [origin] GroupByGeoDistance origin
             * @property {Array.<search.proto.IRange>|null} [ranges] GroupByGeoDistance ranges
             * @property {search.proto.IAggregations|null} [subAggs] GroupByGeoDistance subAggs
             * @property {search.proto.IGroupBys|null} [subGroupBys] GroupByGeoDistance subGroupBys
             */

            /**
             * Constructs a new GroupByGeoDistance.
             * @memberof search.proto
             * @classdesc Represents a GroupByGeoDistance.
             * @implements IGroupByGeoDistance
             * @constructor
             * @param {search.proto.IGroupByGeoDistance=} [properties] Properties to set
             */
            function GroupByGeoDistance(properties) {
                this.ranges = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupByGeoDistance fieldName.
             * @member {string} fieldName
             * @memberof search.proto.GroupByGeoDistance
             * @instance
             */
            GroupByGeoDistance.prototype.fieldName = "";

            /**
             * GroupByGeoDistance origin.
             * @member {search.proto.IGeoPoint|null|undefined} origin
             * @memberof search.proto.GroupByGeoDistance
             * @instance
             */
            GroupByGeoDistance.prototype.origin = null;

            /**
             * GroupByGeoDistance ranges.
             * @member {Array.<search.proto.IRange>} ranges
             * @memberof search.proto.GroupByGeoDistance
             * @instance
             */
            GroupByGeoDistance.prototype.ranges = $util.emptyArray;

            /**
             * GroupByGeoDistance subAggs.
             * @member {search.proto.IAggregations|null|undefined} subAggs
             * @memberof search.proto.GroupByGeoDistance
             * @instance
             */
            GroupByGeoDistance.prototype.subAggs = null;

            /**
             * GroupByGeoDistance subGroupBys.
             * @member {search.proto.IGroupBys|null|undefined} subGroupBys
             * @memberof search.proto.GroupByGeoDistance
             * @instance
             */
            GroupByGeoDistance.prototype.subGroupBys = null;

            /**
             * Creates a new GroupByGeoDistance instance using the specified properties.
             * @function create
             * @memberof search.proto.GroupByGeoDistance
             * @static
             * @param {search.proto.IGroupByGeoDistance=} [properties] Properties to set
             * @returns {search.proto.GroupByGeoDistance} GroupByGeoDistance instance
             */
            GroupByGeoDistance.create = function create(properties) {
                return new GroupByGeoDistance(properties);
            };

            /**
             * Encodes the specified GroupByGeoDistance message. Does not implicitly {@link search.proto.GroupByGeoDistance.verify|verify} messages.
             * @function encode
             * @memberof search.proto.GroupByGeoDistance
             * @static
             * @param {search.proto.IGroupByGeoDistance} message GroupByGeoDistance message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByGeoDistance.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fieldName != null && Object.hasOwnProperty.call(message, "fieldName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fieldName);
                if (message.origin != null && Object.hasOwnProperty.call(message, "origin"))
                    $root.search.proto.GeoPoint.encode(message.origin, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.ranges != null && message.ranges.length)
                    for (var i = 0; i < message.ranges.length; ++i)
                        $root.search.proto.Range.encode(message.ranges[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.subAggs != null && Object.hasOwnProperty.call(message, "subAggs"))
                    $root.search.proto.Aggregations.encode(message.subAggs, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.subGroupBys != null && Object.hasOwnProperty.call(message, "subGroupBys"))
                    $root.search.proto.GroupBys.encode(message.subGroupBys, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GroupByGeoDistance message, length delimited. Does not implicitly {@link search.proto.GroupByGeoDistance.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.GroupByGeoDistance
             * @static
             * @param {search.proto.IGroupByGeoDistance} message GroupByGeoDistance message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByGeoDistance.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupByGeoDistance message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.GroupByGeoDistance
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.GroupByGeoDistance} GroupByGeoDistance
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByGeoDistance.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.GroupByGeoDistance();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fieldName = reader.string();
                        break;
                    case 2:
                        message.origin = $root.search.proto.GeoPoint.decode(reader, reader.uint32());
                        break;
                    case 3:
                        if (!(message.ranges && message.ranges.length))
                            message.ranges = [];
                        message.ranges.push($root.search.proto.Range.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        message.subAggs = $root.search.proto.Aggregations.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.subGroupBys = $root.search.proto.GroupBys.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupByGeoDistance message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.GroupByGeoDistance
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.GroupByGeoDistance} GroupByGeoDistance
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByGeoDistance.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupByGeoDistance message.
             * @function verify
             * @memberof search.proto.GroupByGeoDistance
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupByGeoDistance.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    if (!$util.isString(message.fieldName))
                        return "fieldName: string expected";
                if (message.origin != null && message.hasOwnProperty("origin")) {
                    var error = $root.search.proto.GeoPoint.verify(message.origin);
                    if (error)
                        return "origin." + error;
                }
                if (message.ranges != null && message.hasOwnProperty("ranges")) {
                    if (!Array.isArray(message.ranges))
                        return "ranges: array expected";
                    for (var i = 0; i < message.ranges.length; ++i) {
                        var error = $root.search.proto.Range.verify(message.ranges[i]);
                        if (error)
                            return "ranges." + error;
                    }
                }
                if (message.subAggs != null && message.hasOwnProperty("subAggs")) {
                    var error = $root.search.proto.Aggregations.verify(message.subAggs);
                    if (error)
                        return "subAggs." + error;
                }
                if (message.subGroupBys != null && message.hasOwnProperty("subGroupBys")) {
                    var error = $root.search.proto.GroupBys.verify(message.subGroupBys);
                    if (error)
                        return "subGroupBys." + error;
                }
                return null;
            };

            /**
             * Creates a GroupByGeoDistance message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.GroupByGeoDistance
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.GroupByGeoDistance} GroupByGeoDistance
             */
            GroupByGeoDistance.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.GroupByGeoDistance)
                    return object;
                var message = new $root.search.proto.GroupByGeoDistance();
                if (object.fieldName != null)
                    message.fieldName = String(object.fieldName);
                if (object.origin != null) {
                    if (typeof object.origin !== "object")
                        throw TypeError(".search.proto.GroupByGeoDistance.origin: object expected");
                    message.origin = $root.search.proto.GeoPoint.fromObject(object.origin);
                }
                if (object.ranges) {
                    if (!Array.isArray(object.ranges))
                        throw TypeError(".search.proto.GroupByGeoDistance.ranges: array expected");
                    message.ranges = [];
                    for (var i = 0; i < object.ranges.length; ++i) {
                        if (typeof object.ranges[i] !== "object")
                            throw TypeError(".search.proto.GroupByGeoDistance.ranges: object expected");
                        message.ranges[i] = $root.search.proto.Range.fromObject(object.ranges[i]);
                    }
                }
                if (object.subAggs != null) {
                    if (typeof object.subAggs !== "object")
                        throw TypeError(".search.proto.GroupByGeoDistance.subAggs: object expected");
                    message.subAggs = $root.search.proto.Aggregations.fromObject(object.subAggs);
                }
                if (object.subGroupBys != null) {
                    if (typeof object.subGroupBys !== "object")
                        throw TypeError(".search.proto.GroupByGeoDistance.subGroupBys: object expected");
                    message.subGroupBys = $root.search.proto.GroupBys.fromObject(object.subGroupBys);
                }
                return message;
            };

            /**
             * Creates a plain object from a GroupByGeoDistance message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.GroupByGeoDistance
             * @static
             * @param {search.proto.GroupByGeoDistance} message GroupByGeoDistance
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupByGeoDistance.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.ranges = [];
                if (options.defaults) {
                    object.fieldName = "";
                    object.origin = null;
                    object.subAggs = null;
                    object.subGroupBys = null;
                }
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    object.fieldName = message.fieldName;
                if (message.origin != null && message.hasOwnProperty("origin"))
                    object.origin = $root.search.proto.GeoPoint.toObject(message.origin, options);
                if (message.ranges && message.ranges.length) {
                    object.ranges = [];
                    for (var j = 0; j < message.ranges.length; ++j)
                        object.ranges[j] = $root.search.proto.Range.toObject(message.ranges[j], options);
                }
                if (message.subAggs != null && message.hasOwnProperty("subAggs"))
                    object.subAggs = $root.search.proto.Aggregations.toObject(message.subAggs, options);
                if (message.subGroupBys != null && message.hasOwnProperty("subGroupBys"))
                    object.subGroupBys = $root.search.proto.GroupBys.toObject(message.subGroupBys, options);
                return object;
            };

            /**
             * Converts this GroupByGeoDistance to JSON.
             * @function toJSON
             * @memberof search.proto.GroupByGeoDistance
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupByGeoDistance.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GroupByGeoDistance;
        })();

        proto.GroupByGeoGrid = (function() {

            /**
             * Properties of a GroupByGeoGrid.
             * @memberof search.proto
             * @interface IGroupByGeoGrid
             * @property {string|null} [fieldName] GroupByGeoGrid fieldName
             * @property {search.proto.GeoHashPrecision|null} [precision] GroupByGeoGrid precision
             * @property {number|null} [size] GroupByGeoGrid size
             * @property {search.proto.IAggregations|null} [subAggs] GroupByGeoGrid subAggs
             * @property {search.proto.IGroupBys|null} [subGroupBys] GroupByGeoGrid subGroupBys
             */

            /**
             * Constructs a new GroupByGeoGrid.
             * @memberof search.proto
             * @classdesc Represents a GroupByGeoGrid.
             * @implements IGroupByGeoGrid
             * @constructor
             * @param {search.proto.IGroupByGeoGrid=} [properties] Properties to set
             */
            function GroupByGeoGrid(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupByGeoGrid fieldName.
             * @member {string} fieldName
             * @memberof search.proto.GroupByGeoGrid
             * @instance
             */
            GroupByGeoGrid.prototype.fieldName = "";

            /**
             * GroupByGeoGrid precision.
             * @member {search.proto.GeoHashPrecision} precision
             * @memberof search.proto.GroupByGeoGrid
             * @instance
             */
            GroupByGeoGrid.prototype.precision = 1;

            /**
             * GroupByGeoGrid size.
             * @member {number} size
             * @memberof search.proto.GroupByGeoGrid
             * @instance
             */
            GroupByGeoGrid.prototype.size = 0;

            /**
             * GroupByGeoGrid subAggs.
             * @member {search.proto.IAggregations|null|undefined} subAggs
             * @memberof search.proto.GroupByGeoGrid
             * @instance
             */
            GroupByGeoGrid.prototype.subAggs = null;

            /**
             * GroupByGeoGrid subGroupBys.
             * @member {search.proto.IGroupBys|null|undefined} subGroupBys
             * @memberof search.proto.GroupByGeoGrid
             * @instance
             */
            GroupByGeoGrid.prototype.subGroupBys = null;

            /**
             * Creates a new GroupByGeoGrid instance using the specified properties.
             * @function create
             * @memberof search.proto.GroupByGeoGrid
             * @static
             * @param {search.proto.IGroupByGeoGrid=} [properties] Properties to set
             * @returns {search.proto.GroupByGeoGrid} GroupByGeoGrid instance
             */
            GroupByGeoGrid.create = function create(properties) {
                return new GroupByGeoGrid(properties);
            };

            /**
             * Encodes the specified GroupByGeoGrid message. Does not implicitly {@link search.proto.GroupByGeoGrid.verify|verify} messages.
             * @function encode
             * @memberof search.proto.GroupByGeoGrid
             * @static
             * @param {search.proto.IGroupByGeoGrid} message GroupByGeoGrid message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByGeoGrid.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fieldName != null && Object.hasOwnProperty.call(message, "fieldName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fieldName);
                if (message.precision != null && Object.hasOwnProperty.call(message, "precision"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.precision);
                if (message.size != null && Object.hasOwnProperty.call(message, "size"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.size);
                if (message.subAggs != null && Object.hasOwnProperty.call(message, "subAggs"))
                    $root.search.proto.Aggregations.encode(message.subAggs, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.subGroupBys != null && Object.hasOwnProperty.call(message, "subGroupBys"))
                    $root.search.proto.GroupBys.encode(message.subGroupBys, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GroupByGeoGrid message, length delimited. Does not implicitly {@link search.proto.GroupByGeoGrid.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.GroupByGeoGrid
             * @static
             * @param {search.proto.IGroupByGeoGrid} message GroupByGeoGrid message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByGeoGrid.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupByGeoGrid message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.GroupByGeoGrid
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.GroupByGeoGrid} GroupByGeoGrid
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByGeoGrid.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.GroupByGeoGrid();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fieldName = reader.string();
                        break;
                    case 2:
                        message.precision = reader.int32();
                        break;
                    case 3:
                        message.size = reader.int32();
                        break;
                    case 4:
                        message.subAggs = $root.search.proto.Aggregations.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.subGroupBys = $root.search.proto.GroupBys.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupByGeoGrid message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.GroupByGeoGrid
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.GroupByGeoGrid} GroupByGeoGrid
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByGeoGrid.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupByGeoGrid message.
             * @function verify
             * @memberof search.proto.GroupByGeoGrid
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupByGeoGrid.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    if (!$util.isString(message.fieldName))
                        return "fieldName: string expected";
                if (message.precision != null && message.hasOwnProperty("precision"))
                    switch (message.precision) {
                    default:
                        return "precision: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                        break;
                    }
                if (message.size != null && message.hasOwnProperty("size"))
                    if (!$util.isInteger(message.size))
                        return "size: integer expected";
                if (message.subAggs != null && message.hasOwnProperty("subAggs")) {
                    var error = $root.search.proto.Aggregations.verify(message.subAggs);
                    if (error)
                        return "subAggs." + error;
                }
                if (message.subGroupBys != null && message.hasOwnProperty("subGroupBys")) {
                    var error = $root.search.proto.GroupBys.verify(message.subGroupBys);
                    if (error)
                        return "subGroupBys." + error;
                }
                return null;
            };

            /**
             * Creates a GroupByGeoGrid message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.GroupByGeoGrid
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.GroupByGeoGrid} GroupByGeoGrid
             */
            GroupByGeoGrid.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.GroupByGeoGrid)
                    return object;
                var message = new $root.search.proto.GroupByGeoGrid();
                if (object.fieldName != null)
                    message.fieldName = String(object.fieldName);
                switch (object.precision) {
                case "GHP_5009KM_4992KM_1":
                case 1:
                    message.precision = 1;
                    break;
                case "GHP_1252KM_624KM_2":
                case 2:
                    message.precision = 2;
                    break;
                case "GHP_156KM_156KM_3":
                case 3:
                    message.precision = 3;
                    break;
                case "GHP_39KM_19KM_4":
                case 4:
                    message.precision = 4;
                    break;
                case "GHP_4900M_4900M_5":
                case 5:
                    message.precision = 5;
                    break;
                case "GHP_1200M_609M_6":
                case 6:
                    message.precision = 6;
                    break;
                case "GHP_152M_152M_7":
                case 7:
                    message.precision = 7;
                    break;
                case "GHP_38M_19M_8":
                case 8:
                    message.precision = 8;
                    break;
                case "GHP_480CM_480CM_9":
                case 9:
                    message.precision = 9;
                    break;
                case "GHP_120CM_595MM_10":
                case 10:
                    message.precision = 10;
                    break;
                case "GHP_149MM_149MM_11":
                case 11:
                    message.precision = 11;
                    break;
                case "GHP_37MM_19MM_12":
                case 12:
                    message.precision = 12;
                    break;
                }
                if (object.size != null)
                    message.size = object.size | 0;
                if (object.subAggs != null) {
                    if (typeof object.subAggs !== "object")
                        throw TypeError(".search.proto.GroupByGeoGrid.subAggs: object expected");
                    message.subAggs = $root.search.proto.Aggregations.fromObject(object.subAggs);
                }
                if (object.subGroupBys != null) {
                    if (typeof object.subGroupBys !== "object")
                        throw TypeError(".search.proto.GroupByGeoGrid.subGroupBys: object expected");
                    message.subGroupBys = $root.search.proto.GroupBys.fromObject(object.subGroupBys);
                }
                return message;
            };

            /**
             * Creates a plain object from a GroupByGeoGrid message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.GroupByGeoGrid
             * @static
             * @param {search.proto.GroupByGeoGrid} message GroupByGeoGrid
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupByGeoGrid.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.fieldName = "";
                    object.precision = options.enums === String ? "GHP_5009KM_4992KM_1" : 1;
                    object.size = 0;
                    object.subAggs = null;
                    object.subGroupBys = null;
                }
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    object.fieldName = message.fieldName;
                if (message.precision != null && message.hasOwnProperty("precision"))
                    object.precision = options.enums === String ? $root.search.proto.GeoHashPrecision[message.precision] : message.precision;
                if (message.size != null && message.hasOwnProperty("size"))
                    object.size = message.size;
                if (message.subAggs != null && message.hasOwnProperty("subAggs"))
                    object.subAggs = $root.search.proto.Aggregations.toObject(message.subAggs, options);
                if (message.subGroupBys != null && message.hasOwnProperty("subGroupBys"))
                    object.subGroupBys = $root.search.proto.GroupBys.toObject(message.subGroupBys, options);
                return object;
            };

            /**
             * Converts this GroupByGeoGrid to JSON.
             * @function toJSON
             * @memberof search.proto.GroupByGeoGrid
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupByGeoGrid.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GroupByGeoGrid;
        })();

        /**
         * GeoHashPrecision enum.
         * @name search.proto.GeoHashPrecision
         * @enum {number}
         * @property {number} GHP_5009KM_4992KM_1=1 GHP_5009KM_4992KM_1 value
         * @property {number} GHP_1252KM_624KM_2=2 GHP_1252KM_624KM_2 value
         * @property {number} GHP_156KM_156KM_3=3 GHP_156KM_156KM_3 value
         * @property {number} GHP_39KM_19KM_4=4 GHP_39KM_19KM_4 value
         * @property {number} GHP_4900M_4900M_5=5 GHP_4900M_4900M_5 value
         * @property {number} GHP_1200M_609M_6=6 GHP_1200M_609M_6 value
         * @property {number} GHP_152M_152M_7=7 GHP_152M_152M_7 value
         * @property {number} GHP_38M_19M_8=8 GHP_38M_19M_8 value
         * @property {number} GHP_480CM_480CM_9=9 GHP_480CM_480CM_9 value
         * @property {number} GHP_120CM_595MM_10=10 GHP_120CM_595MM_10 value
         * @property {number} GHP_149MM_149MM_11=11 GHP_149MM_149MM_11 value
         * @property {number} GHP_37MM_19MM_12=12 GHP_37MM_19MM_12 value
         */
        proto.GeoHashPrecision = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "GHP_5009KM_4992KM_1"] = 1;
            values[valuesById[2] = "GHP_1252KM_624KM_2"] = 2;
            values[valuesById[3] = "GHP_156KM_156KM_3"] = 3;
            values[valuesById[4] = "GHP_39KM_19KM_4"] = 4;
            values[valuesById[5] = "GHP_4900M_4900M_5"] = 5;
            values[valuesById[6] = "GHP_1200M_609M_6"] = 6;
            values[valuesById[7] = "GHP_152M_152M_7"] = 7;
            values[valuesById[8] = "GHP_38M_19M_8"] = 8;
            values[valuesById[9] = "GHP_480CM_480CM_9"] = 9;
            values[valuesById[10] = "GHP_120CM_595MM_10"] = 10;
            values[valuesById[11] = "GHP_149MM_149MM_11"] = 11;
            values[valuesById[12] = "GHP_37MM_19MM_12"] = 12;
            return values;
        })();

        proto.GeoGrid = (function() {

            /**
             * Properties of a GeoGrid.
             * @memberof search.proto
             * @interface IGeoGrid
             * @property {search.proto.IGeoPoint|null} [topLeft] GeoGrid topLeft
             * @property {search.proto.IGeoPoint|null} [bottomRight] GeoGrid bottomRight
             */

            /**
             * Constructs a new GeoGrid.
             * @memberof search.proto
             * @classdesc Represents a GeoGrid.
             * @implements IGeoGrid
             * @constructor
             * @param {search.proto.IGeoGrid=} [properties] Properties to set
             */
            function GeoGrid(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GeoGrid topLeft.
             * @member {search.proto.IGeoPoint|null|undefined} topLeft
             * @memberof search.proto.GeoGrid
             * @instance
             */
            GeoGrid.prototype.topLeft = null;

            /**
             * GeoGrid bottomRight.
             * @member {search.proto.IGeoPoint|null|undefined} bottomRight
             * @memberof search.proto.GeoGrid
             * @instance
             */
            GeoGrid.prototype.bottomRight = null;

            /**
             * Creates a new GeoGrid instance using the specified properties.
             * @function create
             * @memberof search.proto.GeoGrid
             * @static
             * @param {search.proto.IGeoGrid=} [properties] Properties to set
             * @returns {search.proto.GeoGrid} GeoGrid instance
             */
            GeoGrid.create = function create(properties) {
                return new GeoGrid(properties);
            };

            /**
             * Encodes the specified GeoGrid message. Does not implicitly {@link search.proto.GeoGrid.verify|verify} messages.
             * @function encode
             * @memberof search.proto.GeoGrid
             * @static
             * @param {search.proto.IGeoGrid} message GeoGrid message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GeoGrid.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.topLeft != null && Object.hasOwnProperty.call(message, "topLeft"))
                    $root.search.proto.GeoPoint.encode(message.topLeft, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.bottomRight != null && Object.hasOwnProperty.call(message, "bottomRight"))
                    $root.search.proto.GeoPoint.encode(message.bottomRight, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GeoGrid message, length delimited. Does not implicitly {@link search.proto.GeoGrid.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.GeoGrid
             * @static
             * @param {search.proto.IGeoGrid} message GeoGrid message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GeoGrid.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GeoGrid message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.GeoGrid
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.GeoGrid} GeoGrid
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GeoGrid.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.GeoGrid();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.topLeft = $root.search.proto.GeoPoint.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.bottomRight = $root.search.proto.GeoPoint.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GeoGrid message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.GeoGrid
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.GeoGrid} GeoGrid
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GeoGrid.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GeoGrid message.
             * @function verify
             * @memberof search.proto.GeoGrid
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GeoGrid.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.topLeft != null && message.hasOwnProperty("topLeft")) {
                    var error = $root.search.proto.GeoPoint.verify(message.topLeft);
                    if (error)
                        return "topLeft." + error;
                }
                if (message.bottomRight != null && message.hasOwnProperty("bottomRight")) {
                    var error = $root.search.proto.GeoPoint.verify(message.bottomRight);
                    if (error)
                        return "bottomRight." + error;
                }
                return null;
            };

            /**
             * Creates a GeoGrid message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.GeoGrid
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.GeoGrid} GeoGrid
             */
            GeoGrid.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.GeoGrid)
                    return object;
                var message = new $root.search.proto.GeoGrid();
                if (object.topLeft != null) {
                    if (typeof object.topLeft !== "object")
                        throw TypeError(".search.proto.GeoGrid.topLeft: object expected");
                    message.topLeft = $root.search.proto.GeoPoint.fromObject(object.topLeft);
                }
                if (object.bottomRight != null) {
                    if (typeof object.bottomRight !== "object")
                        throw TypeError(".search.proto.GeoGrid.bottomRight: object expected");
                    message.bottomRight = $root.search.proto.GeoPoint.fromObject(object.bottomRight);
                }
                return message;
            };

            /**
             * Creates a plain object from a GeoGrid message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.GeoGrid
             * @static
             * @param {search.proto.GeoGrid} message GeoGrid
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GeoGrid.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.topLeft = null;
                    object.bottomRight = null;
                }
                if (message.topLeft != null && message.hasOwnProperty("topLeft"))
                    object.topLeft = $root.search.proto.GeoPoint.toObject(message.topLeft, options);
                if (message.bottomRight != null && message.hasOwnProperty("bottomRight"))
                    object.bottomRight = $root.search.proto.GeoPoint.toObject(message.bottomRight, options);
                return object;
            };

            /**
             * Converts this GeoGrid to JSON.
             * @function toJSON
             * @memberof search.proto.GeoGrid
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GeoGrid.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GeoGrid;
        })();

        proto.AvgAggregationResult = (function() {

            /**
             * Properties of an AvgAggregationResult.
             * @memberof search.proto
             * @interface IAvgAggregationResult
             * @property {number|null} [value] AvgAggregationResult value
             */

            /**
             * Constructs a new AvgAggregationResult.
             * @memberof search.proto
             * @classdesc Represents an AvgAggregationResult.
             * @implements IAvgAggregationResult
             * @constructor
             * @param {search.proto.IAvgAggregationResult=} [properties] Properties to set
             */
            function AvgAggregationResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AvgAggregationResult value.
             * @member {number} value
             * @memberof search.proto.AvgAggregationResult
             * @instance
             */
            AvgAggregationResult.prototype.value = 0;

            /**
             * Creates a new AvgAggregationResult instance using the specified properties.
             * @function create
             * @memberof search.proto.AvgAggregationResult
             * @static
             * @param {search.proto.IAvgAggregationResult=} [properties] Properties to set
             * @returns {search.proto.AvgAggregationResult} AvgAggregationResult instance
             */
            AvgAggregationResult.create = function create(properties) {
                return new AvgAggregationResult(properties);
            };

            /**
             * Encodes the specified AvgAggregationResult message. Does not implicitly {@link search.proto.AvgAggregationResult.verify|verify} messages.
             * @function encode
             * @memberof search.proto.AvgAggregationResult
             * @static
             * @param {search.proto.IAvgAggregationResult} message AvgAggregationResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AvgAggregationResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.value);
                return writer;
            };

            /**
             * Encodes the specified AvgAggregationResult message, length delimited. Does not implicitly {@link search.proto.AvgAggregationResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.AvgAggregationResult
             * @static
             * @param {search.proto.IAvgAggregationResult} message AvgAggregationResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AvgAggregationResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AvgAggregationResult message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.AvgAggregationResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.AvgAggregationResult} AvgAggregationResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AvgAggregationResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.AvgAggregationResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.value = reader.double();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AvgAggregationResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.AvgAggregationResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.AvgAggregationResult} AvgAggregationResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AvgAggregationResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AvgAggregationResult message.
             * @function verify
             * @memberof search.proto.AvgAggregationResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AvgAggregationResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value !== "number")
                        return "value: number expected";
                return null;
            };

            /**
             * Creates an AvgAggregationResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.AvgAggregationResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.AvgAggregationResult} AvgAggregationResult
             */
            AvgAggregationResult.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.AvgAggregationResult)
                    return object;
                var message = new $root.search.proto.AvgAggregationResult();
                if (object.value != null)
                    message.value = Number(object.value);
                return message;
            };

            /**
             * Creates a plain object from an AvgAggregationResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.AvgAggregationResult
             * @static
             * @param {search.proto.AvgAggregationResult} message AvgAggregationResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AvgAggregationResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.value = 0;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                return object;
            };

            /**
             * Converts this AvgAggregationResult to JSON.
             * @function toJSON
             * @memberof search.proto.AvgAggregationResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AvgAggregationResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AvgAggregationResult;
        })();

        proto.TopRowsAggregationResult = (function() {

            /**
             * Properties of a TopRowsAggregationResult.
             * @memberof search.proto
             * @interface ITopRowsAggregationResult
             * @property {Array.<Uint8Array>|null} [rows] TopRowsAggregationResult rows
             */

            /**
             * Constructs a new TopRowsAggregationResult.
             * @memberof search.proto
             * @classdesc Represents a TopRowsAggregationResult.
             * @implements ITopRowsAggregationResult
             * @constructor
             * @param {search.proto.ITopRowsAggregationResult=} [properties] Properties to set
             */
            function TopRowsAggregationResult(properties) {
                this.rows = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TopRowsAggregationResult rows.
             * @member {Array.<Uint8Array>} rows
             * @memberof search.proto.TopRowsAggregationResult
             * @instance
             */
            TopRowsAggregationResult.prototype.rows = $util.emptyArray;

            /**
             * Creates a new TopRowsAggregationResult instance using the specified properties.
             * @function create
             * @memberof search.proto.TopRowsAggregationResult
             * @static
             * @param {search.proto.ITopRowsAggregationResult=} [properties] Properties to set
             * @returns {search.proto.TopRowsAggregationResult} TopRowsAggregationResult instance
             */
            TopRowsAggregationResult.create = function create(properties) {
                return new TopRowsAggregationResult(properties);
            };

            /**
             * Encodes the specified TopRowsAggregationResult message. Does not implicitly {@link search.proto.TopRowsAggregationResult.verify|verify} messages.
             * @function encode
             * @memberof search.proto.TopRowsAggregationResult
             * @static
             * @param {search.proto.ITopRowsAggregationResult} message TopRowsAggregationResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TopRowsAggregationResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.rows != null && message.rows.length)
                    for (var i = 0; i < message.rows.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.rows[i]);
                return writer;
            };

            /**
             * Encodes the specified TopRowsAggregationResult message, length delimited. Does not implicitly {@link search.proto.TopRowsAggregationResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.TopRowsAggregationResult
             * @static
             * @param {search.proto.ITopRowsAggregationResult} message TopRowsAggregationResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TopRowsAggregationResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TopRowsAggregationResult message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.TopRowsAggregationResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.TopRowsAggregationResult} TopRowsAggregationResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TopRowsAggregationResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.TopRowsAggregationResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.rows && message.rows.length))
                            message.rows = [];
                        message.rows.push(reader.bytes());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TopRowsAggregationResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.TopRowsAggregationResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.TopRowsAggregationResult} TopRowsAggregationResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TopRowsAggregationResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TopRowsAggregationResult message.
             * @function verify
             * @memberof search.proto.TopRowsAggregationResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TopRowsAggregationResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.rows != null && message.hasOwnProperty("rows")) {
                    if (!Array.isArray(message.rows))
                        return "rows: array expected";
                    for (var i = 0; i < message.rows.length; ++i)
                        if (!(message.rows[i] && typeof message.rows[i].length === "number" || $util.isString(message.rows[i])))
                            return "rows: buffer[] expected";
                }
                return null;
            };

            /**
             * Creates a TopRowsAggregationResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.TopRowsAggregationResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.TopRowsAggregationResult} TopRowsAggregationResult
             */
            TopRowsAggregationResult.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.TopRowsAggregationResult)
                    return object;
                var message = new $root.search.proto.TopRowsAggregationResult();
                if (object.rows) {
                    if (!Array.isArray(object.rows))
                        throw TypeError(".search.proto.TopRowsAggregationResult.rows: array expected");
                    message.rows = [];
                    for (var i = 0; i < object.rows.length; ++i)
                        if (typeof object.rows[i] === "string")
                            $util.base64.decode(object.rows[i], message.rows[i] = $util.newBuffer($util.base64.length(object.rows[i])), 0);
                        else if (object.rows[i].length)
                            message.rows[i] = object.rows[i];
                }
                return message;
            };

            /**
             * Creates a plain object from a TopRowsAggregationResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.TopRowsAggregationResult
             * @static
             * @param {search.proto.TopRowsAggregationResult} message TopRowsAggregationResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TopRowsAggregationResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.rows = [];
                if (message.rows && message.rows.length) {
                    object.rows = [];
                    for (var j = 0; j < message.rows.length; ++j)
                        object.rows[j] = options.bytes === String ? $util.base64.encode(message.rows[j], 0, message.rows[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.rows[j]) : message.rows[j];
                }
                return object;
            };

            /**
             * Converts this TopRowsAggregationResult to JSON.
             * @function toJSON
             * @memberof search.proto.TopRowsAggregationResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TopRowsAggregationResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TopRowsAggregationResult;
        })();

        proto.PercentilesAggregationItem = (function() {

            /**
             * Properties of a PercentilesAggregationItem.
             * @memberof search.proto
             * @interface IPercentilesAggregationItem
             * @property {number|null} [key] PercentilesAggregationItem key
             * @property {Uint8Array|null} [value] PercentilesAggregationItem value
             */

            /**
             * Constructs a new PercentilesAggregationItem.
             * @memberof search.proto
             * @classdesc Represents a PercentilesAggregationItem.
             * @implements IPercentilesAggregationItem
             * @constructor
             * @param {search.proto.IPercentilesAggregationItem=} [properties] Properties to set
             */
            function PercentilesAggregationItem(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PercentilesAggregationItem key.
             * @member {number} key
             * @memberof search.proto.PercentilesAggregationItem
             * @instance
             */
            PercentilesAggregationItem.prototype.key = 0;

            /**
             * PercentilesAggregationItem value.
             * @member {Uint8Array} value
             * @memberof search.proto.PercentilesAggregationItem
             * @instance
             */
            PercentilesAggregationItem.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new PercentilesAggregationItem instance using the specified properties.
             * @function create
             * @memberof search.proto.PercentilesAggregationItem
             * @static
             * @param {search.proto.IPercentilesAggregationItem=} [properties] Properties to set
             * @returns {search.proto.PercentilesAggregationItem} PercentilesAggregationItem instance
             */
            PercentilesAggregationItem.create = function create(properties) {
                return new PercentilesAggregationItem(properties);
            };

            /**
             * Encodes the specified PercentilesAggregationItem message. Does not implicitly {@link search.proto.PercentilesAggregationItem.verify|verify} messages.
             * @function encode
             * @memberof search.proto.PercentilesAggregationItem
             * @static
             * @param {search.proto.IPercentilesAggregationItem} message PercentilesAggregationItem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PercentilesAggregationItem.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.key);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                return writer;
            };

            /**
             * Encodes the specified PercentilesAggregationItem message, length delimited. Does not implicitly {@link search.proto.PercentilesAggregationItem.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.PercentilesAggregationItem
             * @static
             * @param {search.proto.IPercentilesAggregationItem} message PercentilesAggregationItem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PercentilesAggregationItem.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PercentilesAggregationItem message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.PercentilesAggregationItem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.PercentilesAggregationItem} PercentilesAggregationItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PercentilesAggregationItem.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.PercentilesAggregationItem();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.double();
                        break;
                    case 2:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PercentilesAggregationItem message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.PercentilesAggregationItem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.PercentilesAggregationItem} PercentilesAggregationItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PercentilesAggregationItem.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PercentilesAggregationItem message.
             * @function verify
             * @memberof search.proto.PercentilesAggregationItem
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PercentilesAggregationItem.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (typeof message.key !== "number")
                        return "key: number expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates a PercentilesAggregationItem message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.PercentilesAggregationItem
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.PercentilesAggregationItem} PercentilesAggregationItem
             */
            PercentilesAggregationItem.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.PercentilesAggregationItem)
                    return object;
                var message = new $root.search.proto.PercentilesAggregationItem();
                if (object.key != null)
                    message.key = Number(object.key);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from a PercentilesAggregationItem message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.PercentilesAggregationItem
             * @static
             * @param {search.proto.PercentilesAggregationItem} message PercentilesAggregationItem
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PercentilesAggregationItem.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.key = 0;
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = options.json && !isFinite(message.key) ? String(message.key) : message.key;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this PercentilesAggregationItem to JSON.
             * @function toJSON
             * @memberof search.proto.PercentilesAggregationItem
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PercentilesAggregationItem.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PercentilesAggregationItem;
        })();

        proto.PercentilesAggregationResult = (function() {

            /**
             * Properties of a PercentilesAggregationResult.
             * @memberof search.proto
             * @interface IPercentilesAggregationResult
             * @property {Array.<search.proto.IPercentilesAggregationItem>|null} [percentilesAggregationItems] PercentilesAggregationResult percentilesAggregationItems
             */

            /**
             * Constructs a new PercentilesAggregationResult.
             * @memberof search.proto
             * @classdesc Represents a PercentilesAggregationResult.
             * @implements IPercentilesAggregationResult
             * @constructor
             * @param {search.proto.IPercentilesAggregationResult=} [properties] Properties to set
             */
            function PercentilesAggregationResult(properties) {
                this.percentilesAggregationItems = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PercentilesAggregationResult percentilesAggregationItems.
             * @member {Array.<search.proto.IPercentilesAggregationItem>} percentilesAggregationItems
             * @memberof search.proto.PercentilesAggregationResult
             * @instance
             */
            PercentilesAggregationResult.prototype.percentilesAggregationItems = $util.emptyArray;

            /**
             * Creates a new PercentilesAggregationResult instance using the specified properties.
             * @function create
             * @memberof search.proto.PercentilesAggregationResult
             * @static
             * @param {search.proto.IPercentilesAggregationResult=} [properties] Properties to set
             * @returns {search.proto.PercentilesAggregationResult} PercentilesAggregationResult instance
             */
            PercentilesAggregationResult.create = function create(properties) {
                return new PercentilesAggregationResult(properties);
            };

            /**
             * Encodes the specified PercentilesAggregationResult message. Does not implicitly {@link search.proto.PercentilesAggregationResult.verify|verify} messages.
             * @function encode
             * @memberof search.proto.PercentilesAggregationResult
             * @static
             * @param {search.proto.IPercentilesAggregationResult} message PercentilesAggregationResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PercentilesAggregationResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.percentilesAggregationItems != null && message.percentilesAggregationItems.length)
                    for (var i = 0; i < message.percentilesAggregationItems.length; ++i)
                        $root.search.proto.PercentilesAggregationItem.encode(message.percentilesAggregationItems[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified PercentilesAggregationResult message, length delimited. Does not implicitly {@link search.proto.PercentilesAggregationResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.PercentilesAggregationResult
             * @static
             * @param {search.proto.IPercentilesAggregationResult} message PercentilesAggregationResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PercentilesAggregationResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PercentilesAggregationResult message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.PercentilesAggregationResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.PercentilesAggregationResult} PercentilesAggregationResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PercentilesAggregationResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.PercentilesAggregationResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.percentilesAggregationItems && message.percentilesAggregationItems.length))
                            message.percentilesAggregationItems = [];
                        message.percentilesAggregationItems.push($root.search.proto.PercentilesAggregationItem.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PercentilesAggregationResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.PercentilesAggregationResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.PercentilesAggregationResult} PercentilesAggregationResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PercentilesAggregationResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PercentilesAggregationResult message.
             * @function verify
             * @memberof search.proto.PercentilesAggregationResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PercentilesAggregationResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.percentilesAggregationItems != null && message.hasOwnProperty("percentilesAggregationItems")) {
                    if (!Array.isArray(message.percentilesAggregationItems))
                        return "percentilesAggregationItems: array expected";
                    for (var i = 0; i < message.percentilesAggregationItems.length; ++i) {
                        var error = $root.search.proto.PercentilesAggregationItem.verify(message.percentilesAggregationItems[i]);
                        if (error)
                            return "percentilesAggregationItems." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a PercentilesAggregationResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.PercentilesAggregationResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.PercentilesAggregationResult} PercentilesAggregationResult
             */
            PercentilesAggregationResult.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.PercentilesAggregationResult)
                    return object;
                var message = new $root.search.proto.PercentilesAggregationResult();
                if (object.percentilesAggregationItems) {
                    if (!Array.isArray(object.percentilesAggregationItems))
                        throw TypeError(".search.proto.PercentilesAggregationResult.percentilesAggregationItems: array expected");
                    message.percentilesAggregationItems = [];
                    for (var i = 0; i < object.percentilesAggregationItems.length; ++i) {
                        if (typeof object.percentilesAggregationItems[i] !== "object")
                            throw TypeError(".search.proto.PercentilesAggregationResult.percentilesAggregationItems: object expected");
                        message.percentilesAggregationItems[i] = $root.search.proto.PercentilesAggregationItem.fromObject(object.percentilesAggregationItems[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a PercentilesAggregationResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.PercentilesAggregationResult
             * @static
             * @param {search.proto.PercentilesAggregationResult} message PercentilesAggregationResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PercentilesAggregationResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.percentilesAggregationItems = [];
                if (message.percentilesAggregationItems && message.percentilesAggregationItems.length) {
                    object.percentilesAggregationItems = [];
                    for (var j = 0; j < message.percentilesAggregationItems.length; ++j)
                        object.percentilesAggregationItems[j] = $root.search.proto.PercentilesAggregationItem.toObject(message.percentilesAggregationItems[j], options);
                }
                return object;
            };

            /**
             * Converts this PercentilesAggregationResult to JSON.
             * @function toJSON
             * @memberof search.proto.PercentilesAggregationResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PercentilesAggregationResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PercentilesAggregationResult;
        })();

        proto.DistinctCountAggregationResult = (function() {

            /**
             * Properties of a DistinctCountAggregationResult.
             * @memberof search.proto
             * @interface IDistinctCountAggregationResult
             * @property {number|Long|null} [value] DistinctCountAggregationResult value
             */

            /**
             * Constructs a new DistinctCountAggregationResult.
             * @memberof search.proto
             * @classdesc Represents a DistinctCountAggregationResult.
             * @implements IDistinctCountAggregationResult
             * @constructor
             * @param {search.proto.IDistinctCountAggregationResult=} [properties] Properties to set
             */
            function DistinctCountAggregationResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DistinctCountAggregationResult value.
             * @member {number|Long} value
             * @memberof search.proto.DistinctCountAggregationResult
             * @instance
             */
            DistinctCountAggregationResult.prototype.value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new DistinctCountAggregationResult instance using the specified properties.
             * @function create
             * @memberof search.proto.DistinctCountAggregationResult
             * @static
             * @param {search.proto.IDistinctCountAggregationResult=} [properties] Properties to set
             * @returns {search.proto.DistinctCountAggregationResult} DistinctCountAggregationResult instance
             */
            DistinctCountAggregationResult.create = function create(properties) {
                return new DistinctCountAggregationResult(properties);
            };

            /**
             * Encodes the specified DistinctCountAggregationResult message. Does not implicitly {@link search.proto.DistinctCountAggregationResult.verify|verify} messages.
             * @function encode
             * @memberof search.proto.DistinctCountAggregationResult
             * @static
             * @param {search.proto.IDistinctCountAggregationResult} message DistinctCountAggregationResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DistinctCountAggregationResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.value);
                return writer;
            };

            /**
             * Encodes the specified DistinctCountAggregationResult message, length delimited. Does not implicitly {@link search.proto.DistinctCountAggregationResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.DistinctCountAggregationResult
             * @static
             * @param {search.proto.IDistinctCountAggregationResult} message DistinctCountAggregationResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DistinctCountAggregationResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DistinctCountAggregationResult message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.DistinctCountAggregationResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.DistinctCountAggregationResult} DistinctCountAggregationResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DistinctCountAggregationResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.DistinctCountAggregationResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.value = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DistinctCountAggregationResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.DistinctCountAggregationResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.DistinctCountAggregationResult} DistinctCountAggregationResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DistinctCountAggregationResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DistinctCountAggregationResult message.
             * @function verify
             * @memberof search.proto.DistinctCountAggregationResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DistinctCountAggregationResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                        return "value: integer|Long expected";
                return null;
            };

            /**
             * Creates a DistinctCountAggregationResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.DistinctCountAggregationResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.DistinctCountAggregationResult} DistinctCountAggregationResult
             */
            DistinctCountAggregationResult.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.DistinctCountAggregationResult)
                    return object;
                var message = new $root.search.proto.DistinctCountAggregationResult();
                if (object.value != null)
                    if ($util.Long)
                        (message.value = $util.Long.fromValue(object.value)).unsigned = false;
                    else if (typeof object.value === "string")
                        message.value = parseInt(object.value, 10);
                    else if (typeof object.value === "number")
                        message.value = object.value;
                    else if (typeof object.value === "object")
                        message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a DistinctCountAggregationResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.DistinctCountAggregationResult
             * @static
             * @param {search.proto.DistinctCountAggregationResult} message DistinctCountAggregationResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DistinctCountAggregationResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.value = options.longs === String ? "0" : 0;
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value === "number")
                        object.value = options.longs === String ? String(message.value) : message.value;
                    else
                        object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber() : message.value;
                return object;
            };

            /**
             * Converts this DistinctCountAggregationResult to JSON.
             * @function toJSON
             * @memberof search.proto.DistinctCountAggregationResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DistinctCountAggregationResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DistinctCountAggregationResult;
        })();

        proto.MaxAggregationResult = (function() {

            /**
             * Properties of a MaxAggregationResult.
             * @memberof search.proto
             * @interface IMaxAggregationResult
             * @property {number|null} [value] MaxAggregationResult value
             */

            /**
             * Constructs a new MaxAggregationResult.
             * @memberof search.proto
             * @classdesc Represents a MaxAggregationResult.
             * @implements IMaxAggregationResult
             * @constructor
             * @param {search.proto.IMaxAggregationResult=} [properties] Properties to set
             */
            function MaxAggregationResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MaxAggregationResult value.
             * @member {number} value
             * @memberof search.proto.MaxAggregationResult
             * @instance
             */
            MaxAggregationResult.prototype.value = 0;

            /**
             * Creates a new MaxAggregationResult instance using the specified properties.
             * @function create
             * @memberof search.proto.MaxAggregationResult
             * @static
             * @param {search.proto.IMaxAggregationResult=} [properties] Properties to set
             * @returns {search.proto.MaxAggregationResult} MaxAggregationResult instance
             */
            MaxAggregationResult.create = function create(properties) {
                return new MaxAggregationResult(properties);
            };

            /**
             * Encodes the specified MaxAggregationResult message. Does not implicitly {@link search.proto.MaxAggregationResult.verify|verify} messages.
             * @function encode
             * @memberof search.proto.MaxAggregationResult
             * @static
             * @param {search.proto.IMaxAggregationResult} message MaxAggregationResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MaxAggregationResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.value);
                return writer;
            };

            /**
             * Encodes the specified MaxAggregationResult message, length delimited. Does not implicitly {@link search.proto.MaxAggregationResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.MaxAggregationResult
             * @static
             * @param {search.proto.IMaxAggregationResult} message MaxAggregationResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MaxAggregationResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MaxAggregationResult message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.MaxAggregationResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.MaxAggregationResult} MaxAggregationResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MaxAggregationResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.MaxAggregationResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.value = reader.double();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MaxAggregationResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.MaxAggregationResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.MaxAggregationResult} MaxAggregationResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MaxAggregationResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MaxAggregationResult message.
             * @function verify
             * @memberof search.proto.MaxAggregationResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MaxAggregationResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value !== "number")
                        return "value: number expected";
                return null;
            };

            /**
             * Creates a MaxAggregationResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.MaxAggregationResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.MaxAggregationResult} MaxAggregationResult
             */
            MaxAggregationResult.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.MaxAggregationResult)
                    return object;
                var message = new $root.search.proto.MaxAggregationResult();
                if (object.value != null)
                    message.value = Number(object.value);
                return message;
            };

            /**
             * Creates a plain object from a MaxAggregationResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.MaxAggregationResult
             * @static
             * @param {search.proto.MaxAggregationResult} message MaxAggregationResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MaxAggregationResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.value = 0;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                return object;
            };

            /**
             * Converts this MaxAggregationResult to JSON.
             * @function toJSON
             * @memberof search.proto.MaxAggregationResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MaxAggregationResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MaxAggregationResult;
        })();

        proto.MinAggregationResult = (function() {

            /**
             * Properties of a MinAggregationResult.
             * @memberof search.proto
             * @interface IMinAggregationResult
             * @property {number|null} [value] MinAggregationResult value
             */

            /**
             * Constructs a new MinAggregationResult.
             * @memberof search.proto
             * @classdesc Represents a MinAggregationResult.
             * @implements IMinAggregationResult
             * @constructor
             * @param {search.proto.IMinAggregationResult=} [properties] Properties to set
             */
            function MinAggregationResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MinAggregationResult value.
             * @member {number} value
             * @memberof search.proto.MinAggregationResult
             * @instance
             */
            MinAggregationResult.prototype.value = 0;

            /**
             * Creates a new MinAggregationResult instance using the specified properties.
             * @function create
             * @memberof search.proto.MinAggregationResult
             * @static
             * @param {search.proto.IMinAggregationResult=} [properties] Properties to set
             * @returns {search.proto.MinAggregationResult} MinAggregationResult instance
             */
            MinAggregationResult.create = function create(properties) {
                return new MinAggregationResult(properties);
            };

            /**
             * Encodes the specified MinAggregationResult message. Does not implicitly {@link search.proto.MinAggregationResult.verify|verify} messages.
             * @function encode
             * @memberof search.proto.MinAggregationResult
             * @static
             * @param {search.proto.IMinAggregationResult} message MinAggregationResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MinAggregationResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.value);
                return writer;
            };

            /**
             * Encodes the specified MinAggregationResult message, length delimited. Does not implicitly {@link search.proto.MinAggregationResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.MinAggregationResult
             * @static
             * @param {search.proto.IMinAggregationResult} message MinAggregationResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MinAggregationResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MinAggregationResult message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.MinAggregationResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.MinAggregationResult} MinAggregationResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MinAggregationResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.MinAggregationResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.value = reader.double();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MinAggregationResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.MinAggregationResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.MinAggregationResult} MinAggregationResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MinAggregationResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MinAggregationResult message.
             * @function verify
             * @memberof search.proto.MinAggregationResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MinAggregationResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value !== "number")
                        return "value: number expected";
                return null;
            };

            /**
             * Creates a MinAggregationResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.MinAggregationResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.MinAggregationResult} MinAggregationResult
             */
            MinAggregationResult.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.MinAggregationResult)
                    return object;
                var message = new $root.search.proto.MinAggregationResult();
                if (object.value != null)
                    message.value = Number(object.value);
                return message;
            };

            /**
             * Creates a plain object from a MinAggregationResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.MinAggregationResult
             * @static
             * @param {search.proto.MinAggregationResult} message MinAggregationResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MinAggregationResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.value = 0;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                return object;
            };

            /**
             * Converts this MinAggregationResult to JSON.
             * @function toJSON
             * @memberof search.proto.MinAggregationResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MinAggregationResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MinAggregationResult;
        })();

        proto.SumAggregationResult = (function() {

            /**
             * Properties of a SumAggregationResult.
             * @memberof search.proto
             * @interface ISumAggregationResult
             * @property {number|null} [value] SumAggregationResult value
             */

            /**
             * Constructs a new SumAggregationResult.
             * @memberof search.proto
             * @classdesc Represents a SumAggregationResult.
             * @implements ISumAggregationResult
             * @constructor
             * @param {search.proto.ISumAggregationResult=} [properties] Properties to set
             */
            function SumAggregationResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SumAggregationResult value.
             * @member {number} value
             * @memberof search.proto.SumAggregationResult
             * @instance
             */
            SumAggregationResult.prototype.value = 0;

            /**
             * Creates a new SumAggregationResult instance using the specified properties.
             * @function create
             * @memberof search.proto.SumAggregationResult
             * @static
             * @param {search.proto.ISumAggregationResult=} [properties] Properties to set
             * @returns {search.proto.SumAggregationResult} SumAggregationResult instance
             */
            SumAggregationResult.create = function create(properties) {
                return new SumAggregationResult(properties);
            };

            /**
             * Encodes the specified SumAggregationResult message. Does not implicitly {@link search.proto.SumAggregationResult.verify|verify} messages.
             * @function encode
             * @memberof search.proto.SumAggregationResult
             * @static
             * @param {search.proto.ISumAggregationResult} message SumAggregationResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SumAggregationResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.value);
                return writer;
            };

            /**
             * Encodes the specified SumAggregationResult message, length delimited. Does not implicitly {@link search.proto.SumAggregationResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.SumAggregationResult
             * @static
             * @param {search.proto.ISumAggregationResult} message SumAggregationResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SumAggregationResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SumAggregationResult message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.SumAggregationResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.SumAggregationResult} SumAggregationResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SumAggregationResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.SumAggregationResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.value = reader.double();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SumAggregationResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.SumAggregationResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.SumAggregationResult} SumAggregationResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SumAggregationResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SumAggregationResult message.
             * @function verify
             * @memberof search.proto.SumAggregationResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SumAggregationResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value !== "number")
                        return "value: number expected";
                return null;
            };

            /**
             * Creates a SumAggregationResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.SumAggregationResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.SumAggregationResult} SumAggregationResult
             */
            SumAggregationResult.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.SumAggregationResult)
                    return object;
                var message = new $root.search.proto.SumAggregationResult();
                if (object.value != null)
                    message.value = Number(object.value);
                return message;
            };

            /**
             * Creates a plain object from a SumAggregationResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.SumAggregationResult
             * @static
             * @param {search.proto.SumAggregationResult} message SumAggregationResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SumAggregationResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.value = 0;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                return object;
            };

            /**
             * Converts this SumAggregationResult to JSON.
             * @function toJSON
             * @memberof search.proto.SumAggregationResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SumAggregationResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SumAggregationResult;
        })();

        proto.CountAggregationResult = (function() {

            /**
             * Properties of a CountAggregationResult.
             * @memberof search.proto
             * @interface ICountAggregationResult
             * @property {number|Long|null} [value] CountAggregationResult value
             */

            /**
             * Constructs a new CountAggregationResult.
             * @memberof search.proto
             * @classdesc Represents a CountAggregationResult.
             * @implements ICountAggregationResult
             * @constructor
             * @param {search.proto.ICountAggregationResult=} [properties] Properties to set
             */
            function CountAggregationResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CountAggregationResult value.
             * @member {number|Long} value
             * @memberof search.proto.CountAggregationResult
             * @instance
             */
            CountAggregationResult.prototype.value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new CountAggregationResult instance using the specified properties.
             * @function create
             * @memberof search.proto.CountAggregationResult
             * @static
             * @param {search.proto.ICountAggregationResult=} [properties] Properties to set
             * @returns {search.proto.CountAggregationResult} CountAggregationResult instance
             */
            CountAggregationResult.create = function create(properties) {
                return new CountAggregationResult(properties);
            };

            /**
             * Encodes the specified CountAggregationResult message. Does not implicitly {@link search.proto.CountAggregationResult.verify|verify} messages.
             * @function encode
             * @memberof search.proto.CountAggregationResult
             * @static
             * @param {search.proto.ICountAggregationResult} message CountAggregationResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CountAggregationResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.value);
                return writer;
            };

            /**
             * Encodes the specified CountAggregationResult message, length delimited. Does not implicitly {@link search.proto.CountAggregationResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.CountAggregationResult
             * @static
             * @param {search.proto.ICountAggregationResult} message CountAggregationResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CountAggregationResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CountAggregationResult message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.CountAggregationResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.CountAggregationResult} CountAggregationResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CountAggregationResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.CountAggregationResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.value = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CountAggregationResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.CountAggregationResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.CountAggregationResult} CountAggregationResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CountAggregationResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CountAggregationResult message.
             * @function verify
             * @memberof search.proto.CountAggregationResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CountAggregationResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                        return "value: integer|Long expected";
                return null;
            };

            /**
             * Creates a CountAggregationResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.CountAggregationResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.CountAggregationResult} CountAggregationResult
             */
            CountAggregationResult.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.CountAggregationResult)
                    return object;
                var message = new $root.search.proto.CountAggregationResult();
                if (object.value != null)
                    if ($util.Long)
                        (message.value = $util.Long.fromValue(object.value)).unsigned = false;
                    else if (typeof object.value === "string")
                        message.value = parseInt(object.value, 10);
                    else if (typeof object.value === "number")
                        message.value = object.value;
                    else if (typeof object.value === "object")
                        message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a CountAggregationResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.CountAggregationResult
             * @static
             * @param {search.proto.CountAggregationResult} message CountAggregationResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CountAggregationResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.value = options.longs === String ? "0" : 0;
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value === "number")
                        object.value = options.longs === String ? String(message.value) : message.value;
                    else
                        object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber() : message.value;
                return object;
            };

            /**
             * Converts this CountAggregationResult to JSON.
             * @function toJSON
             * @memberof search.proto.CountAggregationResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CountAggregationResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CountAggregationResult;
        })();

        proto.AggregationResult = (function() {

            /**
             * Properties of an AggregationResult.
             * @memberof search.proto
             * @interface IAggregationResult
             * @property {string|null} [name] AggregationResult name
             * @property {search.proto.AggregationType|null} [type] AggregationResult type
             * @property {Uint8Array|null} [aggResult] AggregationResult aggResult
             */

            /**
             * Constructs a new AggregationResult.
             * @memberof search.proto
             * @classdesc Represents an AggregationResult.
             * @implements IAggregationResult
             * @constructor
             * @param {search.proto.IAggregationResult=} [properties] Properties to set
             */
            function AggregationResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AggregationResult name.
             * @member {string} name
             * @memberof search.proto.AggregationResult
             * @instance
             */
            AggregationResult.prototype.name = "";

            /**
             * AggregationResult type.
             * @member {search.proto.AggregationType} type
             * @memberof search.proto.AggregationResult
             * @instance
             */
            AggregationResult.prototype.type = 1;

            /**
             * AggregationResult aggResult.
             * @member {Uint8Array} aggResult
             * @memberof search.proto.AggregationResult
             * @instance
             */
            AggregationResult.prototype.aggResult = $util.newBuffer([]);

            /**
             * Creates a new AggregationResult instance using the specified properties.
             * @function create
             * @memberof search.proto.AggregationResult
             * @static
             * @param {search.proto.IAggregationResult=} [properties] Properties to set
             * @returns {search.proto.AggregationResult} AggregationResult instance
             */
            AggregationResult.create = function create(properties) {
                return new AggregationResult(properties);
            };

            /**
             * Encodes the specified AggregationResult message. Does not implicitly {@link search.proto.AggregationResult.verify|verify} messages.
             * @function encode
             * @memberof search.proto.AggregationResult
             * @static
             * @param {search.proto.IAggregationResult} message AggregationResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AggregationResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                if (message.aggResult != null && Object.hasOwnProperty.call(message, "aggResult"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.aggResult);
                return writer;
            };

            /**
             * Encodes the specified AggregationResult message, length delimited. Does not implicitly {@link search.proto.AggregationResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.AggregationResult
             * @static
             * @param {search.proto.IAggregationResult} message AggregationResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AggregationResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AggregationResult message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.AggregationResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.AggregationResult} AggregationResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AggregationResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.AggregationResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.type = reader.int32();
                        break;
                    case 3:
                        message.aggResult = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AggregationResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.AggregationResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.AggregationResult} AggregationResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AggregationResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AggregationResult message.
             * @function verify
             * @memberof search.proto.AggregationResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AggregationResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                        break;
                    }
                if (message.aggResult != null && message.hasOwnProperty("aggResult"))
                    if (!(message.aggResult && typeof message.aggResult.length === "number" || $util.isString(message.aggResult)))
                        return "aggResult: buffer expected";
                return null;
            };

            /**
             * Creates an AggregationResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.AggregationResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.AggregationResult} AggregationResult
             */
            AggregationResult.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.AggregationResult)
                    return object;
                var message = new $root.search.proto.AggregationResult();
                if (object.name != null)
                    message.name = String(object.name);
                switch (object.type) {
                case "AGG_AVG":
                case 1:
                    message.type = 1;
                    break;
                case "AGG_MAX":
                case 2:
                    message.type = 2;
                    break;
                case "AGG_MIN":
                case 3:
                    message.type = 3;
                    break;
                case "AGG_SUM":
                case 4:
                    message.type = 4;
                    break;
                case "AGG_COUNT":
                case 5:
                    message.type = 5;
                    break;
                case "AGG_DISTINCT_COUNT":
                case 6:
                    message.type = 6;
                    break;
                case "AGG_TOP_ROWS":
                case 7:
                    message.type = 7;
                    break;
                case "AGG_PERCENTILES":
                case 8:
                    message.type = 8;
                    break;
                }
                if (object.aggResult != null)
                    if (typeof object.aggResult === "string")
                        $util.base64.decode(object.aggResult, message.aggResult = $util.newBuffer($util.base64.length(object.aggResult)), 0);
                    else if (object.aggResult.length)
                        message.aggResult = object.aggResult;
                return message;
            };

            /**
             * Creates a plain object from an AggregationResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.AggregationResult
             * @static
             * @param {search.proto.AggregationResult} message AggregationResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AggregationResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.type = options.enums === String ? "AGG_AVG" : 1;
                    if (options.bytes === String)
                        object.aggResult = "";
                    else {
                        object.aggResult = [];
                        if (options.bytes !== Array)
                            object.aggResult = $util.newBuffer(object.aggResult);
                    }
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.search.proto.AggregationType[message.type] : message.type;
                if (message.aggResult != null && message.hasOwnProperty("aggResult"))
                    object.aggResult = options.bytes === String ? $util.base64.encode(message.aggResult, 0, message.aggResult.length) : options.bytes === Array ? Array.prototype.slice.call(message.aggResult) : message.aggResult;
                return object;
            };

            /**
             * Converts this AggregationResult to JSON.
             * @function toJSON
             * @memberof search.proto.AggregationResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AggregationResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AggregationResult;
        })();

        proto.AggregationsResult = (function() {

            /**
             * Properties of an AggregationsResult.
             * @memberof search.proto
             * @interface IAggregationsResult
             * @property {Array.<search.proto.IAggregationResult>|null} [aggResults] AggregationsResult aggResults
             */

            /**
             * Constructs a new AggregationsResult.
             * @memberof search.proto
             * @classdesc Represents an AggregationsResult.
             * @implements IAggregationsResult
             * @constructor
             * @param {search.proto.IAggregationsResult=} [properties] Properties to set
             */
            function AggregationsResult(properties) {
                this.aggResults = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AggregationsResult aggResults.
             * @member {Array.<search.proto.IAggregationResult>} aggResults
             * @memberof search.proto.AggregationsResult
             * @instance
             */
            AggregationsResult.prototype.aggResults = $util.emptyArray;

            /**
             * Creates a new AggregationsResult instance using the specified properties.
             * @function create
             * @memberof search.proto.AggregationsResult
             * @static
             * @param {search.proto.IAggregationsResult=} [properties] Properties to set
             * @returns {search.proto.AggregationsResult} AggregationsResult instance
             */
            AggregationsResult.create = function create(properties) {
                return new AggregationsResult(properties);
            };

            /**
             * Encodes the specified AggregationsResult message. Does not implicitly {@link search.proto.AggregationsResult.verify|verify} messages.
             * @function encode
             * @memberof search.proto.AggregationsResult
             * @static
             * @param {search.proto.IAggregationsResult} message AggregationsResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AggregationsResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.aggResults != null && message.aggResults.length)
                    for (var i = 0; i < message.aggResults.length; ++i)
                        $root.search.proto.AggregationResult.encode(message.aggResults[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified AggregationsResult message, length delimited. Does not implicitly {@link search.proto.AggregationsResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.AggregationsResult
             * @static
             * @param {search.proto.IAggregationsResult} message AggregationsResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AggregationsResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AggregationsResult message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.AggregationsResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.AggregationsResult} AggregationsResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AggregationsResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.AggregationsResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.aggResults && message.aggResults.length))
                            message.aggResults = [];
                        message.aggResults.push($root.search.proto.AggregationResult.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AggregationsResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.AggregationsResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.AggregationsResult} AggregationsResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AggregationsResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AggregationsResult message.
             * @function verify
             * @memberof search.proto.AggregationsResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AggregationsResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.aggResults != null && message.hasOwnProperty("aggResults")) {
                    if (!Array.isArray(message.aggResults))
                        return "aggResults: array expected";
                    for (var i = 0; i < message.aggResults.length; ++i) {
                        var error = $root.search.proto.AggregationResult.verify(message.aggResults[i]);
                        if (error)
                            return "aggResults." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an AggregationsResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.AggregationsResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.AggregationsResult} AggregationsResult
             */
            AggregationsResult.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.AggregationsResult)
                    return object;
                var message = new $root.search.proto.AggregationsResult();
                if (object.aggResults) {
                    if (!Array.isArray(object.aggResults))
                        throw TypeError(".search.proto.AggregationsResult.aggResults: array expected");
                    message.aggResults = [];
                    for (var i = 0; i < object.aggResults.length; ++i) {
                        if (typeof object.aggResults[i] !== "object")
                            throw TypeError(".search.proto.AggregationsResult.aggResults: object expected");
                        message.aggResults[i] = $root.search.proto.AggregationResult.fromObject(object.aggResults[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an AggregationsResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.AggregationsResult
             * @static
             * @param {search.proto.AggregationsResult} message AggregationsResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AggregationsResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.aggResults = [];
                if (message.aggResults && message.aggResults.length) {
                    object.aggResults = [];
                    for (var j = 0; j < message.aggResults.length; ++j)
                        object.aggResults[j] = $root.search.proto.AggregationResult.toObject(message.aggResults[j], options);
                }
                return object;
            };

            /**
             * Converts this AggregationsResult to JSON.
             * @function toJSON
             * @memberof search.proto.AggregationsResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AggregationsResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AggregationsResult;
        })();

        proto.GroupByFieldResultItem = (function() {

            /**
             * Properties of a GroupByFieldResultItem.
             * @memberof search.proto
             * @interface IGroupByFieldResultItem
             * @property {string|null} [key] GroupByFieldResultItem key
             * @property {number|Long|null} [rowCount] GroupByFieldResultItem rowCount
             * @property {search.proto.IAggregationsResult|null} [subAggsResult] GroupByFieldResultItem subAggsResult
             * @property {search.proto.IGroupBysResult|null} [subGroupBysResult] GroupByFieldResultItem subGroupBysResult
             */

            /**
             * Constructs a new GroupByFieldResultItem.
             * @memberof search.proto
             * @classdesc Represents a GroupByFieldResultItem.
             * @implements IGroupByFieldResultItem
             * @constructor
             * @param {search.proto.IGroupByFieldResultItem=} [properties] Properties to set
             */
            function GroupByFieldResultItem(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupByFieldResultItem key.
             * @member {string} key
             * @memberof search.proto.GroupByFieldResultItem
             * @instance
             */
            GroupByFieldResultItem.prototype.key = "";

            /**
             * GroupByFieldResultItem rowCount.
             * @member {number|Long} rowCount
             * @memberof search.proto.GroupByFieldResultItem
             * @instance
             */
            GroupByFieldResultItem.prototype.rowCount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * GroupByFieldResultItem subAggsResult.
             * @member {search.proto.IAggregationsResult|null|undefined} subAggsResult
             * @memberof search.proto.GroupByFieldResultItem
             * @instance
             */
            GroupByFieldResultItem.prototype.subAggsResult = null;

            /**
             * GroupByFieldResultItem subGroupBysResult.
             * @member {search.proto.IGroupBysResult|null|undefined} subGroupBysResult
             * @memberof search.proto.GroupByFieldResultItem
             * @instance
             */
            GroupByFieldResultItem.prototype.subGroupBysResult = null;

            /**
             * Creates a new GroupByFieldResultItem instance using the specified properties.
             * @function create
             * @memberof search.proto.GroupByFieldResultItem
             * @static
             * @param {search.proto.IGroupByFieldResultItem=} [properties] Properties to set
             * @returns {search.proto.GroupByFieldResultItem} GroupByFieldResultItem instance
             */
            GroupByFieldResultItem.create = function create(properties) {
                return new GroupByFieldResultItem(properties);
            };

            /**
             * Encodes the specified GroupByFieldResultItem message. Does not implicitly {@link search.proto.GroupByFieldResultItem.verify|verify} messages.
             * @function encode
             * @memberof search.proto.GroupByFieldResultItem
             * @static
             * @param {search.proto.IGroupByFieldResultItem} message GroupByFieldResultItem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByFieldResultItem.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                if (message.rowCount != null && Object.hasOwnProperty.call(message, "rowCount"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.rowCount);
                if (message.subAggsResult != null && Object.hasOwnProperty.call(message, "subAggsResult"))
                    $root.search.proto.AggregationsResult.encode(message.subAggsResult, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.subGroupBysResult != null && Object.hasOwnProperty.call(message, "subGroupBysResult"))
                    $root.search.proto.GroupBysResult.encode(message.subGroupBysResult, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GroupByFieldResultItem message, length delimited. Does not implicitly {@link search.proto.GroupByFieldResultItem.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.GroupByFieldResultItem
             * @static
             * @param {search.proto.IGroupByFieldResultItem} message GroupByFieldResultItem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByFieldResultItem.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupByFieldResultItem message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.GroupByFieldResultItem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.GroupByFieldResultItem} GroupByFieldResultItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByFieldResultItem.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.GroupByFieldResultItem();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.string();
                        break;
                    case 2:
                        message.rowCount = reader.int64();
                        break;
                    case 3:
                        message.subAggsResult = $root.search.proto.AggregationsResult.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.subGroupBysResult = $root.search.proto.GroupBysResult.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupByFieldResultItem message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.GroupByFieldResultItem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.GroupByFieldResultItem} GroupByFieldResultItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByFieldResultItem.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupByFieldResultItem message.
             * @function verify
             * @memberof search.proto.GroupByFieldResultItem
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupByFieldResultItem.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.rowCount != null && message.hasOwnProperty("rowCount"))
                    if (!$util.isInteger(message.rowCount) && !(message.rowCount && $util.isInteger(message.rowCount.low) && $util.isInteger(message.rowCount.high)))
                        return "rowCount: integer|Long expected";
                if (message.subAggsResult != null && message.hasOwnProperty("subAggsResult")) {
                    var error = $root.search.proto.AggregationsResult.verify(message.subAggsResult);
                    if (error)
                        return "subAggsResult." + error;
                }
                if (message.subGroupBysResult != null && message.hasOwnProperty("subGroupBysResult")) {
                    var error = $root.search.proto.GroupBysResult.verify(message.subGroupBysResult);
                    if (error)
                        return "subGroupBysResult." + error;
                }
                return null;
            };

            /**
             * Creates a GroupByFieldResultItem message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.GroupByFieldResultItem
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.GroupByFieldResultItem} GroupByFieldResultItem
             */
            GroupByFieldResultItem.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.GroupByFieldResultItem)
                    return object;
                var message = new $root.search.proto.GroupByFieldResultItem();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.rowCount != null)
                    if ($util.Long)
                        (message.rowCount = $util.Long.fromValue(object.rowCount)).unsigned = false;
                    else if (typeof object.rowCount === "string")
                        message.rowCount = parseInt(object.rowCount, 10);
                    else if (typeof object.rowCount === "number")
                        message.rowCount = object.rowCount;
                    else if (typeof object.rowCount === "object")
                        message.rowCount = new $util.LongBits(object.rowCount.low >>> 0, object.rowCount.high >>> 0).toNumber();
                if (object.subAggsResult != null) {
                    if (typeof object.subAggsResult !== "object")
                        throw TypeError(".search.proto.GroupByFieldResultItem.subAggsResult: object expected");
                    message.subAggsResult = $root.search.proto.AggregationsResult.fromObject(object.subAggsResult);
                }
                if (object.subGroupBysResult != null) {
                    if (typeof object.subGroupBysResult !== "object")
                        throw TypeError(".search.proto.GroupByFieldResultItem.subGroupBysResult: object expected");
                    message.subGroupBysResult = $root.search.proto.GroupBysResult.fromObject(object.subGroupBysResult);
                }
                return message;
            };

            /**
             * Creates a plain object from a GroupByFieldResultItem message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.GroupByFieldResultItem
             * @static
             * @param {search.proto.GroupByFieldResultItem} message GroupByFieldResultItem
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupByFieldResultItem.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.key = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.rowCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.rowCount = options.longs === String ? "0" : 0;
                    object.subAggsResult = null;
                    object.subGroupBysResult = null;
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.rowCount != null && message.hasOwnProperty("rowCount"))
                    if (typeof message.rowCount === "number")
                        object.rowCount = options.longs === String ? String(message.rowCount) : message.rowCount;
                    else
                        object.rowCount = options.longs === String ? $util.Long.prototype.toString.call(message.rowCount) : options.longs === Number ? new $util.LongBits(message.rowCount.low >>> 0, message.rowCount.high >>> 0).toNumber() : message.rowCount;
                if (message.subAggsResult != null && message.hasOwnProperty("subAggsResult"))
                    object.subAggsResult = $root.search.proto.AggregationsResult.toObject(message.subAggsResult, options);
                if (message.subGroupBysResult != null && message.hasOwnProperty("subGroupBysResult"))
                    object.subGroupBysResult = $root.search.proto.GroupBysResult.toObject(message.subGroupBysResult, options);
                return object;
            };

            /**
             * Converts this GroupByFieldResultItem to JSON.
             * @function toJSON
             * @memberof search.proto.GroupByFieldResultItem
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupByFieldResultItem.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GroupByFieldResultItem;
        })();

        proto.GroupByFieldResult = (function() {

            /**
             * Properties of a GroupByFieldResult.
             * @memberof search.proto
             * @interface IGroupByFieldResult
             * @property {Array.<search.proto.IGroupByFieldResultItem>|null} [groupByFieldResultItems] GroupByFieldResult groupByFieldResultItems
             */

            /**
             * Constructs a new GroupByFieldResult.
             * @memberof search.proto
             * @classdesc Represents a GroupByFieldResult.
             * @implements IGroupByFieldResult
             * @constructor
             * @param {search.proto.IGroupByFieldResult=} [properties] Properties to set
             */
            function GroupByFieldResult(properties) {
                this.groupByFieldResultItems = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupByFieldResult groupByFieldResultItems.
             * @member {Array.<search.proto.IGroupByFieldResultItem>} groupByFieldResultItems
             * @memberof search.proto.GroupByFieldResult
             * @instance
             */
            GroupByFieldResult.prototype.groupByFieldResultItems = $util.emptyArray;

            /**
             * Creates a new GroupByFieldResult instance using the specified properties.
             * @function create
             * @memberof search.proto.GroupByFieldResult
             * @static
             * @param {search.proto.IGroupByFieldResult=} [properties] Properties to set
             * @returns {search.proto.GroupByFieldResult} GroupByFieldResult instance
             */
            GroupByFieldResult.create = function create(properties) {
                return new GroupByFieldResult(properties);
            };

            /**
             * Encodes the specified GroupByFieldResult message. Does not implicitly {@link search.proto.GroupByFieldResult.verify|verify} messages.
             * @function encode
             * @memberof search.proto.GroupByFieldResult
             * @static
             * @param {search.proto.IGroupByFieldResult} message GroupByFieldResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByFieldResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupByFieldResultItems != null && message.groupByFieldResultItems.length)
                    for (var i = 0; i < message.groupByFieldResultItems.length; ++i)
                        $root.search.proto.GroupByFieldResultItem.encode(message.groupByFieldResultItems[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GroupByFieldResult message, length delimited. Does not implicitly {@link search.proto.GroupByFieldResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.GroupByFieldResult
             * @static
             * @param {search.proto.IGroupByFieldResult} message GroupByFieldResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByFieldResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupByFieldResult message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.GroupByFieldResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.GroupByFieldResult} GroupByFieldResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByFieldResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.GroupByFieldResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.groupByFieldResultItems && message.groupByFieldResultItems.length))
                            message.groupByFieldResultItems = [];
                        message.groupByFieldResultItems.push($root.search.proto.GroupByFieldResultItem.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupByFieldResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.GroupByFieldResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.GroupByFieldResult} GroupByFieldResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByFieldResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupByFieldResult message.
             * @function verify
             * @memberof search.proto.GroupByFieldResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupByFieldResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupByFieldResultItems != null && message.hasOwnProperty("groupByFieldResultItems")) {
                    if (!Array.isArray(message.groupByFieldResultItems))
                        return "groupByFieldResultItems: array expected";
                    for (var i = 0; i < message.groupByFieldResultItems.length; ++i) {
                        var error = $root.search.proto.GroupByFieldResultItem.verify(message.groupByFieldResultItems[i]);
                        if (error)
                            return "groupByFieldResultItems." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GroupByFieldResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.GroupByFieldResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.GroupByFieldResult} GroupByFieldResult
             */
            GroupByFieldResult.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.GroupByFieldResult)
                    return object;
                var message = new $root.search.proto.GroupByFieldResult();
                if (object.groupByFieldResultItems) {
                    if (!Array.isArray(object.groupByFieldResultItems))
                        throw TypeError(".search.proto.GroupByFieldResult.groupByFieldResultItems: array expected");
                    message.groupByFieldResultItems = [];
                    for (var i = 0; i < object.groupByFieldResultItems.length; ++i) {
                        if (typeof object.groupByFieldResultItems[i] !== "object")
                            throw TypeError(".search.proto.GroupByFieldResult.groupByFieldResultItems: object expected");
                        message.groupByFieldResultItems[i] = $root.search.proto.GroupByFieldResultItem.fromObject(object.groupByFieldResultItems[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GroupByFieldResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.GroupByFieldResult
             * @static
             * @param {search.proto.GroupByFieldResult} message GroupByFieldResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupByFieldResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.groupByFieldResultItems = [];
                if (message.groupByFieldResultItems && message.groupByFieldResultItems.length) {
                    object.groupByFieldResultItems = [];
                    for (var j = 0; j < message.groupByFieldResultItems.length; ++j)
                        object.groupByFieldResultItems[j] = $root.search.proto.GroupByFieldResultItem.toObject(message.groupByFieldResultItems[j], options);
                }
                return object;
            };

            /**
             * Converts this GroupByFieldResult to JSON.
             * @function toJSON
             * @memberof search.proto.GroupByFieldResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupByFieldResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GroupByFieldResult;
        })();

        proto.GroupByRangeResultItem = (function() {

            /**
             * Properties of a GroupByRangeResultItem.
             * @memberof search.proto
             * @interface IGroupByRangeResultItem
             * @property {number|null} [from] GroupByRangeResultItem from
             * @property {number|null} [to] GroupByRangeResultItem to
             * @property {number|Long|null} [rowCount] GroupByRangeResultItem rowCount
             * @property {search.proto.IAggregationsResult|null} [subAggsResult] GroupByRangeResultItem subAggsResult
             * @property {search.proto.IGroupBysResult|null} [subGroupBysResult] GroupByRangeResultItem subGroupBysResult
             */

            /**
             * Constructs a new GroupByRangeResultItem.
             * @memberof search.proto
             * @classdesc Represents a GroupByRangeResultItem.
             * @implements IGroupByRangeResultItem
             * @constructor
             * @param {search.proto.IGroupByRangeResultItem=} [properties] Properties to set
             */
            function GroupByRangeResultItem(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupByRangeResultItem from.
             * @member {number} from
             * @memberof search.proto.GroupByRangeResultItem
             * @instance
             */
            GroupByRangeResultItem.prototype.from = 0;

            /**
             * GroupByRangeResultItem to.
             * @member {number} to
             * @memberof search.proto.GroupByRangeResultItem
             * @instance
             */
            GroupByRangeResultItem.prototype.to = 0;

            /**
             * GroupByRangeResultItem rowCount.
             * @member {number|Long} rowCount
             * @memberof search.proto.GroupByRangeResultItem
             * @instance
             */
            GroupByRangeResultItem.prototype.rowCount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * GroupByRangeResultItem subAggsResult.
             * @member {search.proto.IAggregationsResult|null|undefined} subAggsResult
             * @memberof search.proto.GroupByRangeResultItem
             * @instance
             */
            GroupByRangeResultItem.prototype.subAggsResult = null;

            /**
             * GroupByRangeResultItem subGroupBysResult.
             * @member {search.proto.IGroupBysResult|null|undefined} subGroupBysResult
             * @memberof search.proto.GroupByRangeResultItem
             * @instance
             */
            GroupByRangeResultItem.prototype.subGroupBysResult = null;

            /**
             * Creates a new GroupByRangeResultItem instance using the specified properties.
             * @function create
             * @memberof search.proto.GroupByRangeResultItem
             * @static
             * @param {search.proto.IGroupByRangeResultItem=} [properties] Properties to set
             * @returns {search.proto.GroupByRangeResultItem} GroupByRangeResultItem instance
             */
            GroupByRangeResultItem.create = function create(properties) {
                return new GroupByRangeResultItem(properties);
            };

            /**
             * Encodes the specified GroupByRangeResultItem message. Does not implicitly {@link search.proto.GroupByRangeResultItem.verify|verify} messages.
             * @function encode
             * @memberof search.proto.GroupByRangeResultItem
             * @static
             * @param {search.proto.IGroupByRangeResultItem} message GroupByRangeResultItem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByRangeResultItem.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.from);
                if (message.to != null && Object.hasOwnProperty.call(message, "to"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.to);
                if (message.rowCount != null && Object.hasOwnProperty.call(message, "rowCount"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.rowCount);
                if (message.subAggsResult != null && Object.hasOwnProperty.call(message, "subAggsResult"))
                    $root.search.proto.AggregationsResult.encode(message.subAggsResult, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.subGroupBysResult != null && Object.hasOwnProperty.call(message, "subGroupBysResult"))
                    $root.search.proto.GroupBysResult.encode(message.subGroupBysResult, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GroupByRangeResultItem message, length delimited. Does not implicitly {@link search.proto.GroupByRangeResultItem.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.GroupByRangeResultItem
             * @static
             * @param {search.proto.IGroupByRangeResultItem} message GroupByRangeResultItem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByRangeResultItem.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupByRangeResultItem message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.GroupByRangeResultItem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.GroupByRangeResultItem} GroupByRangeResultItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByRangeResultItem.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.GroupByRangeResultItem();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.from = reader.double();
                        break;
                    case 2:
                        message.to = reader.double();
                        break;
                    case 3:
                        message.rowCount = reader.int64();
                        break;
                    case 4:
                        message.subAggsResult = $root.search.proto.AggregationsResult.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.subGroupBysResult = $root.search.proto.GroupBysResult.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupByRangeResultItem message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.GroupByRangeResultItem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.GroupByRangeResultItem} GroupByRangeResultItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByRangeResultItem.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupByRangeResultItem message.
             * @function verify
             * @memberof search.proto.GroupByRangeResultItem
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupByRangeResultItem.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.from != null && message.hasOwnProperty("from"))
                    if (typeof message.from !== "number")
                        return "from: number expected";
                if (message.to != null && message.hasOwnProperty("to"))
                    if (typeof message.to !== "number")
                        return "to: number expected";
                if (message.rowCount != null && message.hasOwnProperty("rowCount"))
                    if (!$util.isInteger(message.rowCount) && !(message.rowCount && $util.isInteger(message.rowCount.low) && $util.isInteger(message.rowCount.high)))
                        return "rowCount: integer|Long expected";
                if (message.subAggsResult != null && message.hasOwnProperty("subAggsResult")) {
                    var error = $root.search.proto.AggregationsResult.verify(message.subAggsResult);
                    if (error)
                        return "subAggsResult." + error;
                }
                if (message.subGroupBysResult != null && message.hasOwnProperty("subGroupBysResult")) {
                    var error = $root.search.proto.GroupBysResult.verify(message.subGroupBysResult);
                    if (error)
                        return "subGroupBysResult." + error;
                }
                return null;
            };

            /**
             * Creates a GroupByRangeResultItem message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.GroupByRangeResultItem
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.GroupByRangeResultItem} GroupByRangeResultItem
             */
            GroupByRangeResultItem.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.GroupByRangeResultItem)
                    return object;
                var message = new $root.search.proto.GroupByRangeResultItem();
                if (object.from != null)
                    message.from = Number(object.from);
                if (object.to != null)
                    message.to = Number(object.to);
                if (object.rowCount != null)
                    if ($util.Long)
                        (message.rowCount = $util.Long.fromValue(object.rowCount)).unsigned = false;
                    else if (typeof object.rowCount === "string")
                        message.rowCount = parseInt(object.rowCount, 10);
                    else if (typeof object.rowCount === "number")
                        message.rowCount = object.rowCount;
                    else if (typeof object.rowCount === "object")
                        message.rowCount = new $util.LongBits(object.rowCount.low >>> 0, object.rowCount.high >>> 0).toNumber();
                if (object.subAggsResult != null) {
                    if (typeof object.subAggsResult !== "object")
                        throw TypeError(".search.proto.GroupByRangeResultItem.subAggsResult: object expected");
                    message.subAggsResult = $root.search.proto.AggregationsResult.fromObject(object.subAggsResult);
                }
                if (object.subGroupBysResult != null) {
                    if (typeof object.subGroupBysResult !== "object")
                        throw TypeError(".search.proto.GroupByRangeResultItem.subGroupBysResult: object expected");
                    message.subGroupBysResult = $root.search.proto.GroupBysResult.fromObject(object.subGroupBysResult);
                }
                return message;
            };

            /**
             * Creates a plain object from a GroupByRangeResultItem message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.GroupByRangeResultItem
             * @static
             * @param {search.proto.GroupByRangeResultItem} message GroupByRangeResultItem
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupByRangeResultItem.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.from = 0;
                    object.to = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.rowCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.rowCount = options.longs === String ? "0" : 0;
                    object.subAggsResult = null;
                    object.subGroupBysResult = null;
                }
                if (message.from != null && message.hasOwnProperty("from"))
                    object.from = options.json && !isFinite(message.from) ? String(message.from) : message.from;
                if (message.to != null && message.hasOwnProperty("to"))
                    object.to = options.json && !isFinite(message.to) ? String(message.to) : message.to;
                if (message.rowCount != null && message.hasOwnProperty("rowCount"))
                    if (typeof message.rowCount === "number")
                        object.rowCount = options.longs === String ? String(message.rowCount) : message.rowCount;
                    else
                        object.rowCount = options.longs === String ? $util.Long.prototype.toString.call(message.rowCount) : options.longs === Number ? new $util.LongBits(message.rowCount.low >>> 0, message.rowCount.high >>> 0).toNumber() : message.rowCount;
                if (message.subAggsResult != null && message.hasOwnProperty("subAggsResult"))
                    object.subAggsResult = $root.search.proto.AggregationsResult.toObject(message.subAggsResult, options);
                if (message.subGroupBysResult != null && message.hasOwnProperty("subGroupBysResult"))
                    object.subGroupBysResult = $root.search.proto.GroupBysResult.toObject(message.subGroupBysResult, options);
                return object;
            };

            /**
             * Converts this GroupByRangeResultItem to JSON.
             * @function toJSON
             * @memberof search.proto.GroupByRangeResultItem
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupByRangeResultItem.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GroupByRangeResultItem;
        })();

        proto.GroupByRangeResult = (function() {

            /**
             * Properties of a GroupByRangeResult.
             * @memberof search.proto
             * @interface IGroupByRangeResult
             * @property {Array.<search.proto.IGroupByRangeResultItem>|null} [groupByRangeResultItems] GroupByRangeResult groupByRangeResultItems
             */

            /**
             * Constructs a new GroupByRangeResult.
             * @memberof search.proto
             * @classdesc Represents a GroupByRangeResult.
             * @implements IGroupByRangeResult
             * @constructor
             * @param {search.proto.IGroupByRangeResult=} [properties] Properties to set
             */
            function GroupByRangeResult(properties) {
                this.groupByRangeResultItems = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupByRangeResult groupByRangeResultItems.
             * @member {Array.<search.proto.IGroupByRangeResultItem>} groupByRangeResultItems
             * @memberof search.proto.GroupByRangeResult
             * @instance
             */
            GroupByRangeResult.prototype.groupByRangeResultItems = $util.emptyArray;

            /**
             * Creates a new GroupByRangeResult instance using the specified properties.
             * @function create
             * @memberof search.proto.GroupByRangeResult
             * @static
             * @param {search.proto.IGroupByRangeResult=} [properties] Properties to set
             * @returns {search.proto.GroupByRangeResult} GroupByRangeResult instance
             */
            GroupByRangeResult.create = function create(properties) {
                return new GroupByRangeResult(properties);
            };

            /**
             * Encodes the specified GroupByRangeResult message. Does not implicitly {@link search.proto.GroupByRangeResult.verify|verify} messages.
             * @function encode
             * @memberof search.proto.GroupByRangeResult
             * @static
             * @param {search.proto.IGroupByRangeResult} message GroupByRangeResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByRangeResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupByRangeResultItems != null && message.groupByRangeResultItems.length)
                    for (var i = 0; i < message.groupByRangeResultItems.length; ++i)
                        $root.search.proto.GroupByRangeResultItem.encode(message.groupByRangeResultItems[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GroupByRangeResult message, length delimited. Does not implicitly {@link search.proto.GroupByRangeResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.GroupByRangeResult
             * @static
             * @param {search.proto.IGroupByRangeResult} message GroupByRangeResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByRangeResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupByRangeResult message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.GroupByRangeResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.GroupByRangeResult} GroupByRangeResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByRangeResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.GroupByRangeResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.groupByRangeResultItems && message.groupByRangeResultItems.length))
                            message.groupByRangeResultItems = [];
                        message.groupByRangeResultItems.push($root.search.proto.GroupByRangeResultItem.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupByRangeResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.GroupByRangeResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.GroupByRangeResult} GroupByRangeResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByRangeResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupByRangeResult message.
             * @function verify
             * @memberof search.proto.GroupByRangeResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupByRangeResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupByRangeResultItems != null && message.hasOwnProperty("groupByRangeResultItems")) {
                    if (!Array.isArray(message.groupByRangeResultItems))
                        return "groupByRangeResultItems: array expected";
                    for (var i = 0; i < message.groupByRangeResultItems.length; ++i) {
                        var error = $root.search.proto.GroupByRangeResultItem.verify(message.groupByRangeResultItems[i]);
                        if (error)
                            return "groupByRangeResultItems." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GroupByRangeResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.GroupByRangeResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.GroupByRangeResult} GroupByRangeResult
             */
            GroupByRangeResult.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.GroupByRangeResult)
                    return object;
                var message = new $root.search.proto.GroupByRangeResult();
                if (object.groupByRangeResultItems) {
                    if (!Array.isArray(object.groupByRangeResultItems))
                        throw TypeError(".search.proto.GroupByRangeResult.groupByRangeResultItems: array expected");
                    message.groupByRangeResultItems = [];
                    for (var i = 0; i < object.groupByRangeResultItems.length; ++i) {
                        if (typeof object.groupByRangeResultItems[i] !== "object")
                            throw TypeError(".search.proto.GroupByRangeResult.groupByRangeResultItems: object expected");
                        message.groupByRangeResultItems[i] = $root.search.proto.GroupByRangeResultItem.fromObject(object.groupByRangeResultItems[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GroupByRangeResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.GroupByRangeResult
             * @static
             * @param {search.proto.GroupByRangeResult} message GroupByRangeResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupByRangeResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.groupByRangeResultItems = [];
                if (message.groupByRangeResultItems && message.groupByRangeResultItems.length) {
                    object.groupByRangeResultItems = [];
                    for (var j = 0; j < message.groupByRangeResultItems.length; ++j)
                        object.groupByRangeResultItems[j] = $root.search.proto.GroupByRangeResultItem.toObject(message.groupByRangeResultItems[j], options);
                }
                return object;
            };

            /**
             * Converts this GroupByRangeResult to JSON.
             * @function toJSON
             * @memberof search.proto.GroupByRangeResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupByRangeResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GroupByRangeResult;
        })();

        proto.GroupByGeoDistanceResultItem = (function() {

            /**
             * Properties of a GroupByGeoDistanceResultItem.
             * @memberof search.proto
             * @interface IGroupByGeoDistanceResultItem
             * @property {number|null} [from] GroupByGeoDistanceResultItem from
             * @property {number|null} [to] GroupByGeoDistanceResultItem to
             * @property {number|Long|null} [rowCount] GroupByGeoDistanceResultItem rowCount
             * @property {search.proto.IAggregationsResult|null} [subAggsResult] GroupByGeoDistanceResultItem subAggsResult
             * @property {search.proto.IGroupBysResult|null} [subGroupBysResult] GroupByGeoDistanceResultItem subGroupBysResult
             */

            /**
             * Constructs a new GroupByGeoDistanceResultItem.
             * @memberof search.proto
             * @classdesc Represents a GroupByGeoDistanceResultItem.
             * @implements IGroupByGeoDistanceResultItem
             * @constructor
             * @param {search.proto.IGroupByGeoDistanceResultItem=} [properties] Properties to set
             */
            function GroupByGeoDistanceResultItem(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupByGeoDistanceResultItem from.
             * @member {number} from
             * @memberof search.proto.GroupByGeoDistanceResultItem
             * @instance
             */
            GroupByGeoDistanceResultItem.prototype.from = 0;

            /**
             * GroupByGeoDistanceResultItem to.
             * @member {number} to
             * @memberof search.proto.GroupByGeoDistanceResultItem
             * @instance
             */
            GroupByGeoDistanceResultItem.prototype.to = 0;

            /**
             * GroupByGeoDistanceResultItem rowCount.
             * @member {number|Long} rowCount
             * @memberof search.proto.GroupByGeoDistanceResultItem
             * @instance
             */
            GroupByGeoDistanceResultItem.prototype.rowCount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * GroupByGeoDistanceResultItem subAggsResult.
             * @member {search.proto.IAggregationsResult|null|undefined} subAggsResult
             * @memberof search.proto.GroupByGeoDistanceResultItem
             * @instance
             */
            GroupByGeoDistanceResultItem.prototype.subAggsResult = null;

            /**
             * GroupByGeoDistanceResultItem subGroupBysResult.
             * @member {search.proto.IGroupBysResult|null|undefined} subGroupBysResult
             * @memberof search.proto.GroupByGeoDistanceResultItem
             * @instance
             */
            GroupByGeoDistanceResultItem.prototype.subGroupBysResult = null;

            /**
             * Creates a new GroupByGeoDistanceResultItem instance using the specified properties.
             * @function create
             * @memberof search.proto.GroupByGeoDistanceResultItem
             * @static
             * @param {search.proto.IGroupByGeoDistanceResultItem=} [properties] Properties to set
             * @returns {search.proto.GroupByGeoDistanceResultItem} GroupByGeoDistanceResultItem instance
             */
            GroupByGeoDistanceResultItem.create = function create(properties) {
                return new GroupByGeoDistanceResultItem(properties);
            };

            /**
             * Encodes the specified GroupByGeoDistanceResultItem message. Does not implicitly {@link search.proto.GroupByGeoDistanceResultItem.verify|verify} messages.
             * @function encode
             * @memberof search.proto.GroupByGeoDistanceResultItem
             * @static
             * @param {search.proto.IGroupByGeoDistanceResultItem} message GroupByGeoDistanceResultItem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByGeoDistanceResultItem.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.from);
                if (message.to != null && Object.hasOwnProperty.call(message, "to"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.to);
                if (message.rowCount != null && Object.hasOwnProperty.call(message, "rowCount"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.rowCount);
                if (message.subAggsResult != null && Object.hasOwnProperty.call(message, "subAggsResult"))
                    $root.search.proto.AggregationsResult.encode(message.subAggsResult, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.subGroupBysResult != null && Object.hasOwnProperty.call(message, "subGroupBysResult"))
                    $root.search.proto.GroupBysResult.encode(message.subGroupBysResult, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GroupByGeoDistanceResultItem message, length delimited. Does not implicitly {@link search.proto.GroupByGeoDistanceResultItem.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.GroupByGeoDistanceResultItem
             * @static
             * @param {search.proto.IGroupByGeoDistanceResultItem} message GroupByGeoDistanceResultItem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByGeoDistanceResultItem.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupByGeoDistanceResultItem message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.GroupByGeoDistanceResultItem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.GroupByGeoDistanceResultItem} GroupByGeoDistanceResultItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByGeoDistanceResultItem.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.GroupByGeoDistanceResultItem();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.from = reader.double();
                        break;
                    case 2:
                        message.to = reader.double();
                        break;
                    case 3:
                        message.rowCount = reader.int64();
                        break;
                    case 4:
                        message.subAggsResult = $root.search.proto.AggregationsResult.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.subGroupBysResult = $root.search.proto.GroupBysResult.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupByGeoDistanceResultItem message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.GroupByGeoDistanceResultItem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.GroupByGeoDistanceResultItem} GroupByGeoDistanceResultItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByGeoDistanceResultItem.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupByGeoDistanceResultItem message.
             * @function verify
             * @memberof search.proto.GroupByGeoDistanceResultItem
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupByGeoDistanceResultItem.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.from != null && message.hasOwnProperty("from"))
                    if (typeof message.from !== "number")
                        return "from: number expected";
                if (message.to != null && message.hasOwnProperty("to"))
                    if (typeof message.to !== "number")
                        return "to: number expected";
                if (message.rowCount != null && message.hasOwnProperty("rowCount"))
                    if (!$util.isInteger(message.rowCount) && !(message.rowCount && $util.isInteger(message.rowCount.low) && $util.isInteger(message.rowCount.high)))
                        return "rowCount: integer|Long expected";
                if (message.subAggsResult != null && message.hasOwnProperty("subAggsResult")) {
                    var error = $root.search.proto.AggregationsResult.verify(message.subAggsResult);
                    if (error)
                        return "subAggsResult." + error;
                }
                if (message.subGroupBysResult != null && message.hasOwnProperty("subGroupBysResult")) {
                    var error = $root.search.proto.GroupBysResult.verify(message.subGroupBysResult);
                    if (error)
                        return "subGroupBysResult." + error;
                }
                return null;
            };

            /**
             * Creates a GroupByGeoDistanceResultItem message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.GroupByGeoDistanceResultItem
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.GroupByGeoDistanceResultItem} GroupByGeoDistanceResultItem
             */
            GroupByGeoDistanceResultItem.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.GroupByGeoDistanceResultItem)
                    return object;
                var message = new $root.search.proto.GroupByGeoDistanceResultItem();
                if (object.from != null)
                    message.from = Number(object.from);
                if (object.to != null)
                    message.to = Number(object.to);
                if (object.rowCount != null)
                    if ($util.Long)
                        (message.rowCount = $util.Long.fromValue(object.rowCount)).unsigned = false;
                    else if (typeof object.rowCount === "string")
                        message.rowCount = parseInt(object.rowCount, 10);
                    else if (typeof object.rowCount === "number")
                        message.rowCount = object.rowCount;
                    else if (typeof object.rowCount === "object")
                        message.rowCount = new $util.LongBits(object.rowCount.low >>> 0, object.rowCount.high >>> 0).toNumber();
                if (object.subAggsResult != null) {
                    if (typeof object.subAggsResult !== "object")
                        throw TypeError(".search.proto.GroupByGeoDistanceResultItem.subAggsResult: object expected");
                    message.subAggsResult = $root.search.proto.AggregationsResult.fromObject(object.subAggsResult);
                }
                if (object.subGroupBysResult != null) {
                    if (typeof object.subGroupBysResult !== "object")
                        throw TypeError(".search.proto.GroupByGeoDistanceResultItem.subGroupBysResult: object expected");
                    message.subGroupBysResult = $root.search.proto.GroupBysResult.fromObject(object.subGroupBysResult);
                }
                return message;
            };

            /**
             * Creates a plain object from a GroupByGeoDistanceResultItem message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.GroupByGeoDistanceResultItem
             * @static
             * @param {search.proto.GroupByGeoDistanceResultItem} message GroupByGeoDistanceResultItem
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupByGeoDistanceResultItem.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.from = 0;
                    object.to = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.rowCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.rowCount = options.longs === String ? "0" : 0;
                    object.subAggsResult = null;
                    object.subGroupBysResult = null;
                }
                if (message.from != null && message.hasOwnProperty("from"))
                    object.from = options.json && !isFinite(message.from) ? String(message.from) : message.from;
                if (message.to != null && message.hasOwnProperty("to"))
                    object.to = options.json && !isFinite(message.to) ? String(message.to) : message.to;
                if (message.rowCount != null && message.hasOwnProperty("rowCount"))
                    if (typeof message.rowCount === "number")
                        object.rowCount = options.longs === String ? String(message.rowCount) : message.rowCount;
                    else
                        object.rowCount = options.longs === String ? $util.Long.prototype.toString.call(message.rowCount) : options.longs === Number ? new $util.LongBits(message.rowCount.low >>> 0, message.rowCount.high >>> 0).toNumber() : message.rowCount;
                if (message.subAggsResult != null && message.hasOwnProperty("subAggsResult"))
                    object.subAggsResult = $root.search.proto.AggregationsResult.toObject(message.subAggsResult, options);
                if (message.subGroupBysResult != null && message.hasOwnProperty("subGroupBysResult"))
                    object.subGroupBysResult = $root.search.proto.GroupBysResult.toObject(message.subGroupBysResult, options);
                return object;
            };

            /**
             * Converts this GroupByGeoDistanceResultItem to JSON.
             * @function toJSON
             * @memberof search.proto.GroupByGeoDistanceResultItem
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupByGeoDistanceResultItem.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GroupByGeoDistanceResultItem;
        })();

        proto.GroupByGeoDistanceResult = (function() {

            /**
             * Properties of a GroupByGeoDistanceResult.
             * @memberof search.proto
             * @interface IGroupByGeoDistanceResult
             * @property {Array.<search.proto.IGroupByGeoDistanceResultItem>|null} [groupByGeoDistanceResultItems] GroupByGeoDistanceResult groupByGeoDistanceResultItems
             */

            /**
             * Constructs a new GroupByGeoDistanceResult.
             * @memberof search.proto
             * @classdesc Represents a GroupByGeoDistanceResult.
             * @implements IGroupByGeoDistanceResult
             * @constructor
             * @param {search.proto.IGroupByGeoDistanceResult=} [properties] Properties to set
             */
            function GroupByGeoDistanceResult(properties) {
                this.groupByGeoDistanceResultItems = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupByGeoDistanceResult groupByGeoDistanceResultItems.
             * @member {Array.<search.proto.IGroupByGeoDistanceResultItem>} groupByGeoDistanceResultItems
             * @memberof search.proto.GroupByGeoDistanceResult
             * @instance
             */
            GroupByGeoDistanceResult.prototype.groupByGeoDistanceResultItems = $util.emptyArray;

            /**
             * Creates a new GroupByGeoDistanceResult instance using the specified properties.
             * @function create
             * @memberof search.proto.GroupByGeoDistanceResult
             * @static
             * @param {search.proto.IGroupByGeoDistanceResult=} [properties] Properties to set
             * @returns {search.proto.GroupByGeoDistanceResult} GroupByGeoDistanceResult instance
             */
            GroupByGeoDistanceResult.create = function create(properties) {
                return new GroupByGeoDistanceResult(properties);
            };

            /**
             * Encodes the specified GroupByGeoDistanceResult message. Does not implicitly {@link search.proto.GroupByGeoDistanceResult.verify|verify} messages.
             * @function encode
             * @memberof search.proto.GroupByGeoDistanceResult
             * @static
             * @param {search.proto.IGroupByGeoDistanceResult} message GroupByGeoDistanceResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByGeoDistanceResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupByGeoDistanceResultItems != null && message.groupByGeoDistanceResultItems.length)
                    for (var i = 0; i < message.groupByGeoDistanceResultItems.length; ++i)
                        $root.search.proto.GroupByGeoDistanceResultItem.encode(message.groupByGeoDistanceResultItems[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GroupByGeoDistanceResult message, length delimited. Does not implicitly {@link search.proto.GroupByGeoDistanceResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.GroupByGeoDistanceResult
             * @static
             * @param {search.proto.IGroupByGeoDistanceResult} message GroupByGeoDistanceResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByGeoDistanceResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupByGeoDistanceResult message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.GroupByGeoDistanceResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.GroupByGeoDistanceResult} GroupByGeoDistanceResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByGeoDistanceResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.GroupByGeoDistanceResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.groupByGeoDistanceResultItems && message.groupByGeoDistanceResultItems.length))
                            message.groupByGeoDistanceResultItems = [];
                        message.groupByGeoDistanceResultItems.push($root.search.proto.GroupByGeoDistanceResultItem.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupByGeoDistanceResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.GroupByGeoDistanceResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.GroupByGeoDistanceResult} GroupByGeoDistanceResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByGeoDistanceResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupByGeoDistanceResult message.
             * @function verify
             * @memberof search.proto.GroupByGeoDistanceResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupByGeoDistanceResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupByGeoDistanceResultItems != null && message.hasOwnProperty("groupByGeoDistanceResultItems")) {
                    if (!Array.isArray(message.groupByGeoDistanceResultItems))
                        return "groupByGeoDistanceResultItems: array expected";
                    for (var i = 0; i < message.groupByGeoDistanceResultItems.length; ++i) {
                        var error = $root.search.proto.GroupByGeoDistanceResultItem.verify(message.groupByGeoDistanceResultItems[i]);
                        if (error)
                            return "groupByGeoDistanceResultItems." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GroupByGeoDistanceResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.GroupByGeoDistanceResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.GroupByGeoDistanceResult} GroupByGeoDistanceResult
             */
            GroupByGeoDistanceResult.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.GroupByGeoDistanceResult)
                    return object;
                var message = new $root.search.proto.GroupByGeoDistanceResult();
                if (object.groupByGeoDistanceResultItems) {
                    if (!Array.isArray(object.groupByGeoDistanceResultItems))
                        throw TypeError(".search.proto.GroupByGeoDistanceResult.groupByGeoDistanceResultItems: array expected");
                    message.groupByGeoDistanceResultItems = [];
                    for (var i = 0; i < object.groupByGeoDistanceResultItems.length; ++i) {
                        if (typeof object.groupByGeoDistanceResultItems[i] !== "object")
                            throw TypeError(".search.proto.GroupByGeoDistanceResult.groupByGeoDistanceResultItems: object expected");
                        message.groupByGeoDistanceResultItems[i] = $root.search.proto.GroupByGeoDistanceResultItem.fromObject(object.groupByGeoDistanceResultItems[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GroupByGeoDistanceResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.GroupByGeoDistanceResult
             * @static
             * @param {search.proto.GroupByGeoDistanceResult} message GroupByGeoDistanceResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupByGeoDistanceResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.groupByGeoDistanceResultItems = [];
                if (message.groupByGeoDistanceResultItems && message.groupByGeoDistanceResultItems.length) {
                    object.groupByGeoDistanceResultItems = [];
                    for (var j = 0; j < message.groupByGeoDistanceResultItems.length; ++j)
                        object.groupByGeoDistanceResultItems[j] = $root.search.proto.GroupByGeoDistanceResultItem.toObject(message.groupByGeoDistanceResultItems[j], options);
                }
                return object;
            };

            /**
             * Converts this GroupByGeoDistanceResult to JSON.
             * @function toJSON
             * @memberof search.proto.GroupByGeoDistanceResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupByGeoDistanceResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GroupByGeoDistanceResult;
        })();

        proto.GroupByFilterResultItem = (function() {

            /**
             * Properties of a GroupByFilterResultItem.
             * @memberof search.proto
             * @interface IGroupByFilterResultItem
             * @property {number|Long|null} [rowCount] GroupByFilterResultItem rowCount
             * @property {search.proto.IAggregationsResult|null} [subAggsResult] GroupByFilterResultItem subAggsResult
             * @property {search.proto.IGroupBysResult|null} [subGroupBysResult] GroupByFilterResultItem subGroupBysResult
             */

            /**
             * Constructs a new GroupByFilterResultItem.
             * @memberof search.proto
             * @classdesc Represents a GroupByFilterResultItem.
             * @implements IGroupByFilterResultItem
             * @constructor
             * @param {search.proto.IGroupByFilterResultItem=} [properties] Properties to set
             */
            function GroupByFilterResultItem(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupByFilterResultItem rowCount.
             * @member {number|Long} rowCount
             * @memberof search.proto.GroupByFilterResultItem
             * @instance
             */
            GroupByFilterResultItem.prototype.rowCount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * GroupByFilterResultItem subAggsResult.
             * @member {search.proto.IAggregationsResult|null|undefined} subAggsResult
             * @memberof search.proto.GroupByFilterResultItem
             * @instance
             */
            GroupByFilterResultItem.prototype.subAggsResult = null;

            /**
             * GroupByFilterResultItem subGroupBysResult.
             * @member {search.proto.IGroupBysResult|null|undefined} subGroupBysResult
             * @memberof search.proto.GroupByFilterResultItem
             * @instance
             */
            GroupByFilterResultItem.prototype.subGroupBysResult = null;

            /**
             * Creates a new GroupByFilterResultItem instance using the specified properties.
             * @function create
             * @memberof search.proto.GroupByFilterResultItem
             * @static
             * @param {search.proto.IGroupByFilterResultItem=} [properties] Properties to set
             * @returns {search.proto.GroupByFilterResultItem} GroupByFilterResultItem instance
             */
            GroupByFilterResultItem.create = function create(properties) {
                return new GroupByFilterResultItem(properties);
            };

            /**
             * Encodes the specified GroupByFilterResultItem message. Does not implicitly {@link search.proto.GroupByFilterResultItem.verify|verify} messages.
             * @function encode
             * @memberof search.proto.GroupByFilterResultItem
             * @static
             * @param {search.proto.IGroupByFilterResultItem} message GroupByFilterResultItem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByFilterResultItem.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.rowCount != null && Object.hasOwnProperty.call(message, "rowCount"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.rowCount);
                if (message.subAggsResult != null && Object.hasOwnProperty.call(message, "subAggsResult"))
                    $root.search.proto.AggregationsResult.encode(message.subAggsResult, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.subGroupBysResult != null && Object.hasOwnProperty.call(message, "subGroupBysResult"))
                    $root.search.proto.GroupBysResult.encode(message.subGroupBysResult, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GroupByFilterResultItem message, length delimited. Does not implicitly {@link search.proto.GroupByFilterResultItem.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.GroupByFilterResultItem
             * @static
             * @param {search.proto.IGroupByFilterResultItem} message GroupByFilterResultItem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByFilterResultItem.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupByFilterResultItem message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.GroupByFilterResultItem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.GroupByFilterResultItem} GroupByFilterResultItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByFilterResultItem.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.GroupByFilterResultItem();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.rowCount = reader.int64();
                        break;
                    case 2:
                        message.subAggsResult = $root.search.proto.AggregationsResult.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.subGroupBysResult = $root.search.proto.GroupBysResult.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupByFilterResultItem message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.GroupByFilterResultItem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.GroupByFilterResultItem} GroupByFilterResultItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByFilterResultItem.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupByFilterResultItem message.
             * @function verify
             * @memberof search.proto.GroupByFilterResultItem
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupByFilterResultItem.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.rowCount != null && message.hasOwnProperty("rowCount"))
                    if (!$util.isInteger(message.rowCount) && !(message.rowCount && $util.isInteger(message.rowCount.low) && $util.isInteger(message.rowCount.high)))
                        return "rowCount: integer|Long expected";
                if (message.subAggsResult != null && message.hasOwnProperty("subAggsResult")) {
                    var error = $root.search.proto.AggregationsResult.verify(message.subAggsResult);
                    if (error)
                        return "subAggsResult." + error;
                }
                if (message.subGroupBysResult != null && message.hasOwnProperty("subGroupBysResult")) {
                    var error = $root.search.proto.GroupBysResult.verify(message.subGroupBysResult);
                    if (error)
                        return "subGroupBysResult." + error;
                }
                return null;
            };

            /**
             * Creates a GroupByFilterResultItem message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.GroupByFilterResultItem
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.GroupByFilterResultItem} GroupByFilterResultItem
             */
            GroupByFilterResultItem.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.GroupByFilterResultItem)
                    return object;
                var message = new $root.search.proto.GroupByFilterResultItem();
                if (object.rowCount != null)
                    if ($util.Long)
                        (message.rowCount = $util.Long.fromValue(object.rowCount)).unsigned = false;
                    else if (typeof object.rowCount === "string")
                        message.rowCount = parseInt(object.rowCount, 10);
                    else if (typeof object.rowCount === "number")
                        message.rowCount = object.rowCount;
                    else if (typeof object.rowCount === "object")
                        message.rowCount = new $util.LongBits(object.rowCount.low >>> 0, object.rowCount.high >>> 0).toNumber();
                if (object.subAggsResult != null) {
                    if (typeof object.subAggsResult !== "object")
                        throw TypeError(".search.proto.GroupByFilterResultItem.subAggsResult: object expected");
                    message.subAggsResult = $root.search.proto.AggregationsResult.fromObject(object.subAggsResult);
                }
                if (object.subGroupBysResult != null) {
                    if (typeof object.subGroupBysResult !== "object")
                        throw TypeError(".search.proto.GroupByFilterResultItem.subGroupBysResult: object expected");
                    message.subGroupBysResult = $root.search.proto.GroupBysResult.fromObject(object.subGroupBysResult);
                }
                return message;
            };

            /**
             * Creates a plain object from a GroupByFilterResultItem message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.GroupByFilterResultItem
             * @static
             * @param {search.proto.GroupByFilterResultItem} message GroupByFilterResultItem
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupByFilterResultItem.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.rowCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.rowCount = options.longs === String ? "0" : 0;
                    object.subAggsResult = null;
                    object.subGroupBysResult = null;
                }
                if (message.rowCount != null && message.hasOwnProperty("rowCount"))
                    if (typeof message.rowCount === "number")
                        object.rowCount = options.longs === String ? String(message.rowCount) : message.rowCount;
                    else
                        object.rowCount = options.longs === String ? $util.Long.prototype.toString.call(message.rowCount) : options.longs === Number ? new $util.LongBits(message.rowCount.low >>> 0, message.rowCount.high >>> 0).toNumber() : message.rowCount;
                if (message.subAggsResult != null && message.hasOwnProperty("subAggsResult"))
                    object.subAggsResult = $root.search.proto.AggregationsResult.toObject(message.subAggsResult, options);
                if (message.subGroupBysResult != null && message.hasOwnProperty("subGroupBysResult"))
                    object.subGroupBysResult = $root.search.proto.GroupBysResult.toObject(message.subGroupBysResult, options);
                return object;
            };

            /**
             * Converts this GroupByFilterResultItem to JSON.
             * @function toJSON
             * @memberof search.proto.GroupByFilterResultItem
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupByFilterResultItem.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GroupByFilterResultItem;
        })();

        proto.GroupByFilterResult = (function() {

            /**
             * Properties of a GroupByFilterResult.
             * @memberof search.proto
             * @interface IGroupByFilterResult
             * @property {Array.<search.proto.IGroupByFilterResultItem>|null} [groupByFilterResultItems] GroupByFilterResult groupByFilterResultItems
             */

            /**
             * Constructs a new GroupByFilterResult.
             * @memberof search.proto
             * @classdesc Represents a GroupByFilterResult.
             * @implements IGroupByFilterResult
             * @constructor
             * @param {search.proto.IGroupByFilterResult=} [properties] Properties to set
             */
            function GroupByFilterResult(properties) {
                this.groupByFilterResultItems = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupByFilterResult groupByFilterResultItems.
             * @member {Array.<search.proto.IGroupByFilterResultItem>} groupByFilterResultItems
             * @memberof search.proto.GroupByFilterResult
             * @instance
             */
            GroupByFilterResult.prototype.groupByFilterResultItems = $util.emptyArray;

            /**
             * Creates a new GroupByFilterResult instance using the specified properties.
             * @function create
             * @memberof search.proto.GroupByFilterResult
             * @static
             * @param {search.proto.IGroupByFilterResult=} [properties] Properties to set
             * @returns {search.proto.GroupByFilterResult} GroupByFilterResult instance
             */
            GroupByFilterResult.create = function create(properties) {
                return new GroupByFilterResult(properties);
            };

            /**
             * Encodes the specified GroupByFilterResult message. Does not implicitly {@link search.proto.GroupByFilterResult.verify|verify} messages.
             * @function encode
             * @memberof search.proto.GroupByFilterResult
             * @static
             * @param {search.proto.IGroupByFilterResult} message GroupByFilterResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByFilterResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupByFilterResultItems != null && message.groupByFilterResultItems.length)
                    for (var i = 0; i < message.groupByFilterResultItems.length; ++i)
                        $root.search.proto.GroupByFilterResultItem.encode(message.groupByFilterResultItems[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GroupByFilterResult message, length delimited. Does not implicitly {@link search.proto.GroupByFilterResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.GroupByFilterResult
             * @static
             * @param {search.proto.IGroupByFilterResult} message GroupByFilterResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByFilterResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupByFilterResult message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.GroupByFilterResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.GroupByFilterResult} GroupByFilterResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByFilterResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.GroupByFilterResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.groupByFilterResultItems && message.groupByFilterResultItems.length))
                            message.groupByFilterResultItems = [];
                        message.groupByFilterResultItems.push($root.search.proto.GroupByFilterResultItem.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupByFilterResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.GroupByFilterResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.GroupByFilterResult} GroupByFilterResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByFilterResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupByFilterResult message.
             * @function verify
             * @memberof search.proto.GroupByFilterResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupByFilterResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupByFilterResultItems != null && message.hasOwnProperty("groupByFilterResultItems")) {
                    if (!Array.isArray(message.groupByFilterResultItems))
                        return "groupByFilterResultItems: array expected";
                    for (var i = 0; i < message.groupByFilterResultItems.length; ++i) {
                        var error = $root.search.proto.GroupByFilterResultItem.verify(message.groupByFilterResultItems[i]);
                        if (error)
                            return "groupByFilterResultItems." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GroupByFilterResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.GroupByFilterResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.GroupByFilterResult} GroupByFilterResult
             */
            GroupByFilterResult.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.GroupByFilterResult)
                    return object;
                var message = new $root.search.proto.GroupByFilterResult();
                if (object.groupByFilterResultItems) {
                    if (!Array.isArray(object.groupByFilterResultItems))
                        throw TypeError(".search.proto.GroupByFilterResult.groupByFilterResultItems: array expected");
                    message.groupByFilterResultItems = [];
                    for (var i = 0; i < object.groupByFilterResultItems.length; ++i) {
                        if (typeof object.groupByFilterResultItems[i] !== "object")
                            throw TypeError(".search.proto.GroupByFilterResult.groupByFilterResultItems: object expected");
                        message.groupByFilterResultItems[i] = $root.search.proto.GroupByFilterResultItem.fromObject(object.groupByFilterResultItems[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GroupByFilterResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.GroupByFilterResult
             * @static
             * @param {search.proto.GroupByFilterResult} message GroupByFilterResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupByFilterResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.groupByFilterResultItems = [];
                if (message.groupByFilterResultItems && message.groupByFilterResultItems.length) {
                    object.groupByFilterResultItems = [];
                    for (var j = 0; j < message.groupByFilterResultItems.length; ++j)
                        object.groupByFilterResultItems[j] = $root.search.proto.GroupByFilterResultItem.toObject(message.groupByFilterResultItems[j], options);
                }
                return object;
            };

            /**
             * Converts this GroupByFilterResult to JSON.
             * @function toJSON
             * @memberof search.proto.GroupByFilterResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupByFilterResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GroupByFilterResult;
        })();

        proto.GroupByResult = (function() {

            /**
             * Properties of a GroupByResult.
             * @memberof search.proto
             * @interface IGroupByResult
             * @property {string|null} [name] GroupByResult name
             * @property {search.proto.GroupByType|null} [type] GroupByResult type
             * @property {Uint8Array|null} [groupByResult] GroupByResult groupByResult
             */

            /**
             * Constructs a new GroupByResult.
             * @memberof search.proto
             * @classdesc Represents a GroupByResult.
             * @implements IGroupByResult
             * @constructor
             * @param {search.proto.IGroupByResult=} [properties] Properties to set
             */
            function GroupByResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupByResult name.
             * @member {string} name
             * @memberof search.proto.GroupByResult
             * @instance
             */
            GroupByResult.prototype.name = "";

            /**
             * GroupByResult type.
             * @member {search.proto.GroupByType} type
             * @memberof search.proto.GroupByResult
             * @instance
             */
            GroupByResult.prototype.type = 1;

            /**
             * GroupByResult groupByResult.
             * @member {Uint8Array} groupByResult
             * @memberof search.proto.GroupByResult
             * @instance
             */
            GroupByResult.prototype.groupByResult = $util.newBuffer([]);

            /**
             * Creates a new GroupByResult instance using the specified properties.
             * @function create
             * @memberof search.proto.GroupByResult
             * @static
             * @param {search.proto.IGroupByResult=} [properties] Properties to set
             * @returns {search.proto.GroupByResult} GroupByResult instance
             */
            GroupByResult.create = function create(properties) {
                return new GroupByResult(properties);
            };

            /**
             * Encodes the specified GroupByResult message. Does not implicitly {@link search.proto.GroupByResult.verify|verify} messages.
             * @function encode
             * @memberof search.proto.GroupByResult
             * @static
             * @param {search.proto.IGroupByResult} message GroupByResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                if (message.groupByResult != null && Object.hasOwnProperty.call(message, "groupByResult"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.groupByResult);
                return writer;
            };

            /**
             * Encodes the specified GroupByResult message, length delimited. Does not implicitly {@link search.proto.GroupByResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.GroupByResult
             * @static
             * @param {search.proto.IGroupByResult} message GroupByResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupByResult message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.GroupByResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.GroupByResult} GroupByResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.GroupByResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.type = reader.int32();
                        break;
                    case 3:
                        message.groupByResult = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupByResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.GroupByResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.GroupByResult} GroupByResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupByResult message.
             * @function verify
             * @memberof search.proto.GroupByResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupByResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                        break;
                    }
                if (message.groupByResult != null && message.hasOwnProperty("groupByResult"))
                    if (!(message.groupByResult && typeof message.groupByResult.length === "number" || $util.isString(message.groupByResult)))
                        return "groupByResult: buffer expected";
                return null;
            };

            /**
             * Creates a GroupByResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.GroupByResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.GroupByResult} GroupByResult
             */
            GroupByResult.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.GroupByResult)
                    return object;
                var message = new $root.search.proto.GroupByResult();
                if (object.name != null)
                    message.name = String(object.name);
                switch (object.type) {
                case "GROUP_BY_FIELD":
                case 1:
                    message.type = 1;
                    break;
                case "GROUP_BY_RANGE":
                case 2:
                    message.type = 2;
                    break;
                case "GROUP_BY_FILTER":
                case 3:
                    message.type = 3;
                    break;
                case "GROUP_BY_GEO_DISTANCE":
                case 4:
                    message.type = 4;
                    break;
                case "GROUP_BY_HISTOGRAM":
                case 5:
                    message.type = 5;
                    break;
                case "GROUP_BY_DATE_HISTOGRAM":
                case 6:
                    message.type = 6;
                    break;
                case "GROUP_BY_GEO_GRID":
                case 7:
                    message.type = 7;
                    break;
                case "GROUP_BY_COMPOSITE":
                case 8:
                    message.type = 8;
                    break;
                }
                if (object.groupByResult != null)
                    if (typeof object.groupByResult === "string")
                        $util.base64.decode(object.groupByResult, message.groupByResult = $util.newBuffer($util.base64.length(object.groupByResult)), 0);
                    else if (object.groupByResult.length)
                        message.groupByResult = object.groupByResult;
                return message;
            };

            /**
             * Creates a plain object from a GroupByResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.GroupByResult
             * @static
             * @param {search.proto.GroupByResult} message GroupByResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupByResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.type = options.enums === String ? "GROUP_BY_FIELD" : 1;
                    if (options.bytes === String)
                        object.groupByResult = "";
                    else {
                        object.groupByResult = [];
                        if (options.bytes !== Array)
                            object.groupByResult = $util.newBuffer(object.groupByResult);
                    }
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.search.proto.GroupByType[message.type] : message.type;
                if (message.groupByResult != null && message.hasOwnProperty("groupByResult"))
                    object.groupByResult = options.bytes === String ? $util.base64.encode(message.groupByResult, 0, message.groupByResult.length) : options.bytes === Array ? Array.prototype.slice.call(message.groupByResult) : message.groupByResult;
                return object;
            };

            /**
             * Converts this GroupByResult to JSON.
             * @function toJSON
             * @memberof search.proto.GroupByResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupByResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GroupByResult;
        })();

        proto.GroupBysResult = (function() {

            /**
             * Properties of a GroupBysResult.
             * @memberof search.proto
             * @interface IGroupBysResult
             * @property {Array.<search.proto.IGroupByResult>|null} [groupByResults] GroupBysResult groupByResults
             */

            /**
             * Constructs a new GroupBysResult.
             * @memberof search.proto
             * @classdesc Represents a GroupBysResult.
             * @implements IGroupBysResult
             * @constructor
             * @param {search.proto.IGroupBysResult=} [properties] Properties to set
             */
            function GroupBysResult(properties) {
                this.groupByResults = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupBysResult groupByResults.
             * @member {Array.<search.proto.IGroupByResult>} groupByResults
             * @memberof search.proto.GroupBysResult
             * @instance
             */
            GroupBysResult.prototype.groupByResults = $util.emptyArray;

            /**
             * Creates a new GroupBysResult instance using the specified properties.
             * @function create
             * @memberof search.proto.GroupBysResult
             * @static
             * @param {search.proto.IGroupBysResult=} [properties] Properties to set
             * @returns {search.proto.GroupBysResult} GroupBysResult instance
             */
            GroupBysResult.create = function create(properties) {
                return new GroupBysResult(properties);
            };

            /**
             * Encodes the specified GroupBysResult message. Does not implicitly {@link search.proto.GroupBysResult.verify|verify} messages.
             * @function encode
             * @memberof search.proto.GroupBysResult
             * @static
             * @param {search.proto.IGroupBysResult} message GroupBysResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupBysResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupByResults != null && message.groupByResults.length)
                    for (var i = 0; i < message.groupByResults.length; ++i)
                        $root.search.proto.GroupByResult.encode(message.groupByResults[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GroupBysResult message, length delimited. Does not implicitly {@link search.proto.GroupBysResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.GroupBysResult
             * @static
             * @param {search.proto.IGroupBysResult} message GroupBysResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupBysResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupBysResult message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.GroupBysResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.GroupBysResult} GroupBysResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupBysResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.GroupBysResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.groupByResults && message.groupByResults.length))
                            message.groupByResults = [];
                        message.groupByResults.push($root.search.proto.GroupByResult.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupBysResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.GroupBysResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.GroupBysResult} GroupBysResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupBysResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupBysResult message.
             * @function verify
             * @memberof search.proto.GroupBysResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupBysResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupByResults != null && message.hasOwnProperty("groupByResults")) {
                    if (!Array.isArray(message.groupByResults))
                        return "groupByResults: array expected";
                    for (var i = 0; i < message.groupByResults.length; ++i) {
                        var error = $root.search.proto.GroupByResult.verify(message.groupByResults[i]);
                        if (error)
                            return "groupByResults." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GroupBysResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.GroupBysResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.GroupBysResult} GroupBysResult
             */
            GroupBysResult.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.GroupBysResult)
                    return object;
                var message = new $root.search.proto.GroupBysResult();
                if (object.groupByResults) {
                    if (!Array.isArray(object.groupByResults))
                        throw TypeError(".search.proto.GroupBysResult.groupByResults: array expected");
                    message.groupByResults = [];
                    for (var i = 0; i < object.groupByResults.length; ++i) {
                        if (typeof object.groupByResults[i] !== "object")
                            throw TypeError(".search.proto.GroupBysResult.groupByResults: object expected");
                        message.groupByResults[i] = $root.search.proto.GroupByResult.fromObject(object.groupByResults[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GroupBysResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.GroupBysResult
             * @static
             * @param {search.proto.GroupBysResult} message GroupBysResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupBysResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.groupByResults = [];
                if (message.groupByResults && message.groupByResults.length) {
                    object.groupByResults = [];
                    for (var j = 0; j < message.groupByResults.length; ++j)
                        object.groupByResults[j] = $root.search.proto.GroupByResult.toObject(message.groupByResults[j], options);
                }
                return object;
            };

            /**
             * Converts this GroupBysResult to JSON.
             * @function toJSON
             * @memberof search.proto.GroupBysResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupBysResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GroupBysResult;
        })();

        proto.GroupByHistogramItem = (function() {

            /**
             * Properties of a GroupByHistogramItem.
             * @memberof search.proto
             * @interface IGroupByHistogramItem
             * @property {Uint8Array|null} [key] GroupByHistogramItem key
             * @property {number|Long|null} [value] GroupByHistogramItem value
             * @property {search.proto.IAggregationsResult|null} [subAggsResult] GroupByHistogramItem subAggsResult
             * @property {search.proto.IGroupBysResult|null} [subGroupBysResult] GroupByHistogramItem subGroupBysResult
             */

            /**
             * Constructs a new GroupByHistogramItem.
             * @memberof search.proto
             * @classdesc Represents a GroupByHistogramItem.
             * @implements IGroupByHistogramItem
             * @constructor
             * @param {search.proto.IGroupByHistogramItem=} [properties] Properties to set
             */
            function GroupByHistogramItem(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupByHistogramItem key.
             * @member {Uint8Array} key
             * @memberof search.proto.GroupByHistogramItem
             * @instance
             */
            GroupByHistogramItem.prototype.key = $util.newBuffer([]);

            /**
             * GroupByHistogramItem value.
             * @member {number|Long} value
             * @memberof search.proto.GroupByHistogramItem
             * @instance
             */
            GroupByHistogramItem.prototype.value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * GroupByHistogramItem subAggsResult.
             * @member {search.proto.IAggregationsResult|null|undefined} subAggsResult
             * @memberof search.proto.GroupByHistogramItem
             * @instance
             */
            GroupByHistogramItem.prototype.subAggsResult = null;

            /**
             * GroupByHistogramItem subGroupBysResult.
             * @member {search.proto.IGroupBysResult|null|undefined} subGroupBysResult
             * @memberof search.proto.GroupByHistogramItem
             * @instance
             */
            GroupByHistogramItem.prototype.subGroupBysResult = null;

            /**
             * Creates a new GroupByHistogramItem instance using the specified properties.
             * @function create
             * @memberof search.proto.GroupByHistogramItem
             * @static
             * @param {search.proto.IGroupByHistogramItem=} [properties] Properties to set
             * @returns {search.proto.GroupByHistogramItem} GroupByHistogramItem instance
             */
            GroupByHistogramItem.create = function create(properties) {
                return new GroupByHistogramItem(properties);
            };

            /**
             * Encodes the specified GroupByHistogramItem message. Does not implicitly {@link search.proto.GroupByHistogramItem.verify|verify} messages.
             * @function encode
             * @memberof search.proto.GroupByHistogramItem
             * @static
             * @param {search.proto.IGroupByHistogramItem} message GroupByHistogramItem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByHistogramItem.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.value);
                if (message.subAggsResult != null && Object.hasOwnProperty.call(message, "subAggsResult"))
                    $root.search.proto.AggregationsResult.encode(message.subAggsResult, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.subGroupBysResult != null && Object.hasOwnProperty.call(message, "subGroupBysResult"))
                    $root.search.proto.GroupBysResult.encode(message.subGroupBysResult, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GroupByHistogramItem message, length delimited. Does not implicitly {@link search.proto.GroupByHistogramItem.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.GroupByHistogramItem
             * @static
             * @param {search.proto.IGroupByHistogramItem} message GroupByHistogramItem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByHistogramItem.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupByHistogramItem message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.GroupByHistogramItem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.GroupByHistogramItem} GroupByHistogramItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByHistogramItem.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.GroupByHistogramItem();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.bytes();
                        break;
                    case 2:
                        message.value = reader.int64();
                        break;
                    case 3:
                        message.subAggsResult = $root.search.proto.AggregationsResult.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.subGroupBysResult = $root.search.proto.GroupBysResult.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupByHistogramItem message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.GroupByHistogramItem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.GroupByHistogramItem} GroupByHistogramItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByHistogramItem.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupByHistogramItem message.
             * @function verify
             * @memberof search.proto.GroupByHistogramItem
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupByHistogramItem.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                        return "key: buffer expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                        return "value: integer|Long expected";
                if (message.subAggsResult != null && message.hasOwnProperty("subAggsResult")) {
                    var error = $root.search.proto.AggregationsResult.verify(message.subAggsResult);
                    if (error)
                        return "subAggsResult." + error;
                }
                if (message.subGroupBysResult != null && message.hasOwnProperty("subGroupBysResult")) {
                    var error = $root.search.proto.GroupBysResult.verify(message.subGroupBysResult);
                    if (error)
                        return "subGroupBysResult." + error;
                }
                return null;
            };

            /**
             * Creates a GroupByHistogramItem message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.GroupByHistogramItem
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.GroupByHistogramItem} GroupByHistogramItem
             */
            GroupByHistogramItem.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.GroupByHistogramItem)
                    return object;
                var message = new $root.search.proto.GroupByHistogramItem();
                if (object.key != null)
                    if (typeof object.key === "string")
                        $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                    else if (object.key.length)
                        message.key = object.key;
                if (object.value != null)
                    if ($util.Long)
                        (message.value = $util.Long.fromValue(object.value)).unsigned = false;
                    else if (typeof object.value === "string")
                        message.value = parseInt(object.value, 10);
                    else if (typeof object.value === "number")
                        message.value = object.value;
                    else if (typeof object.value === "object")
                        message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber();
                if (object.subAggsResult != null) {
                    if (typeof object.subAggsResult !== "object")
                        throw TypeError(".search.proto.GroupByHistogramItem.subAggsResult: object expected");
                    message.subAggsResult = $root.search.proto.AggregationsResult.fromObject(object.subAggsResult);
                }
                if (object.subGroupBysResult != null) {
                    if (typeof object.subGroupBysResult !== "object")
                        throw TypeError(".search.proto.GroupByHistogramItem.subGroupBysResult: object expected");
                    message.subGroupBysResult = $root.search.proto.GroupBysResult.fromObject(object.subGroupBysResult);
                }
                return message;
            };

            /**
             * Creates a plain object from a GroupByHistogramItem message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.GroupByHistogramItem
             * @static
             * @param {search.proto.GroupByHistogramItem} message GroupByHistogramItem
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupByHistogramItem.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.key = "";
                    else {
                        object.key = [];
                        if (options.bytes !== Array)
                            object.key = $util.newBuffer(object.key);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.value = options.longs === String ? "0" : 0;
                    object.subAggsResult = null;
                    object.subGroupBysResult = null;
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value === "number")
                        object.value = options.longs === String ? String(message.value) : message.value;
                    else
                        object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber() : message.value;
                if (message.subAggsResult != null && message.hasOwnProperty("subAggsResult"))
                    object.subAggsResult = $root.search.proto.AggregationsResult.toObject(message.subAggsResult, options);
                if (message.subGroupBysResult != null && message.hasOwnProperty("subGroupBysResult"))
                    object.subGroupBysResult = $root.search.proto.GroupBysResult.toObject(message.subGroupBysResult, options);
                return object;
            };

            /**
             * Converts this GroupByHistogramItem to JSON.
             * @function toJSON
             * @memberof search.proto.GroupByHistogramItem
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupByHistogramItem.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GroupByHistogramItem;
        })();

        proto.GroupByHistogramResult = (function() {

            /**
             * Properties of a GroupByHistogramResult.
             * @memberof search.proto
             * @interface IGroupByHistogramResult
             * @property {Array.<search.proto.IGroupByHistogramItem>|null} [groupByHistogramItems] GroupByHistogramResult groupByHistogramItems
             */

            /**
             * Constructs a new GroupByHistogramResult.
             * @memberof search.proto
             * @classdesc Represents a GroupByHistogramResult.
             * @implements IGroupByHistogramResult
             * @constructor
             * @param {search.proto.IGroupByHistogramResult=} [properties] Properties to set
             */
            function GroupByHistogramResult(properties) {
                this.groupByHistogramItems = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupByHistogramResult groupByHistogramItems.
             * @member {Array.<search.proto.IGroupByHistogramItem>} groupByHistogramItems
             * @memberof search.proto.GroupByHistogramResult
             * @instance
             */
            GroupByHistogramResult.prototype.groupByHistogramItems = $util.emptyArray;

            /**
             * Creates a new GroupByHistogramResult instance using the specified properties.
             * @function create
             * @memberof search.proto.GroupByHistogramResult
             * @static
             * @param {search.proto.IGroupByHistogramResult=} [properties] Properties to set
             * @returns {search.proto.GroupByHistogramResult} GroupByHistogramResult instance
             */
            GroupByHistogramResult.create = function create(properties) {
                return new GroupByHistogramResult(properties);
            };

            /**
             * Encodes the specified GroupByHistogramResult message. Does not implicitly {@link search.proto.GroupByHistogramResult.verify|verify} messages.
             * @function encode
             * @memberof search.proto.GroupByHistogramResult
             * @static
             * @param {search.proto.IGroupByHistogramResult} message GroupByHistogramResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByHistogramResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupByHistogramItems != null && message.groupByHistogramItems.length)
                    for (var i = 0; i < message.groupByHistogramItems.length; ++i)
                        $root.search.proto.GroupByHistogramItem.encode(message.groupByHistogramItems[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GroupByHistogramResult message, length delimited. Does not implicitly {@link search.proto.GroupByHistogramResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.GroupByHistogramResult
             * @static
             * @param {search.proto.IGroupByHistogramResult} message GroupByHistogramResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByHistogramResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupByHistogramResult message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.GroupByHistogramResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.GroupByHistogramResult} GroupByHistogramResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByHistogramResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.GroupByHistogramResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.groupByHistogramItems && message.groupByHistogramItems.length))
                            message.groupByHistogramItems = [];
                        message.groupByHistogramItems.push($root.search.proto.GroupByHistogramItem.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupByHistogramResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.GroupByHistogramResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.GroupByHistogramResult} GroupByHistogramResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByHistogramResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupByHistogramResult message.
             * @function verify
             * @memberof search.proto.GroupByHistogramResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupByHistogramResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupByHistogramItems != null && message.hasOwnProperty("groupByHistogramItems")) {
                    if (!Array.isArray(message.groupByHistogramItems))
                        return "groupByHistogramItems: array expected";
                    for (var i = 0; i < message.groupByHistogramItems.length; ++i) {
                        var error = $root.search.proto.GroupByHistogramItem.verify(message.groupByHistogramItems[i]);
                        if (error)
                            return "groupByHistogramItems." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GroupByHistogramResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.GroupByHistogramResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.GroupByHistogramResult} GroupByHistogramResult
             */
            GroupByHistogramResult.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.GroupByHistogramResult)
                    return object;
                var message = new $root.search.proto.GroupByHistogramResult();
                if (object.groupByHistogramItems) {
                    if (!Array.isArray(object.groupByHistogramItems))
                        throw TypeError(".search.proto.GroupByHistogramResult.groupByHistogramItems: array expected");
                    message.groupByHistogramItems = [];
                    for (var i = 0; i < object.groupByHistogramItems.length; ++i) {
                        if (typeof object.groupByHistogramItems[i] !== "object")
                            throw TypeError(".search.proto.GroupByHistogramResult.groupByHistogramItems: object expected");
                        message.groupByHistogramItems[i] = $root.search.proto.GroupByHistogramItem.fromObject(object.groupByHistogramItems[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GroupByHistogramResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.GroupByHistogramResult
             * @static
             * @param {search.proto.GroupByHistogramResult} message GroupByHistogramResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupByHistogramResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.groupByHistogramItems = [];
                if (message.groupByHistogramItems && message.groupByHistogramItems.length) {
                    object.groupByHistogramItems = [];
                    for (var j = 0; j < message.groupByHistogramItems.length; ++j)
                        object.groupByHistogramItems[j] = $root.search.proto.GroupByHistogramItem.toObject(message.groupByHistogramItems[j], options);
                }
                return object;
            };

            /**
             * Converts this GroupByHistogramResult to JSON.
             * @function toJSON
             * @memberof search.proto.GroupByHistogramResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupByHistogramResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GroupByHistogramResult;
        })();

        proto.GroupByDateHistogramItem = (function() {

            /**
             * Properties of a GroupByDateHistogramItem.
             * @memberof search.proto
             * @interface IGroupByDateHistogramItem
             * @property {number|Long|null} [timestamp] GroupByDateHistogramItem timestamp
             * @property {number|Long|null} [rowCount] GroupByDateHistogramItem rowCount
             * @property {search.proto.IAggregationsResult|null} [subAggsResult] GroupByDateHistogramItem subAggsResult
             * @property {search.proto.IGroupBysResult|null} [subGroupBysResult] GroupByDateHistogramItem subGroupBysResult
             */

            /**
             * Constructs a new GroupByDateHistogramItem.
             * @memberof search.proto
             * @classdesc Represents a GroupByDateHistogramItem.
             * @implements IGroupByDateHistogramItem
             * @constructor
             * @param {search.proto.IGroupByDateHistogramItem=} [properties] Properties to set
             */
            function GroupByDateHistogramItem(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupByDateHistogramItem timestamp.
             * @member {number|Long} timestamp
             * @memberof search.proto.GroupByDateHistogramItem
             * @instance
             */
            GroupByDateHistogramItem.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * GroupByDateHistogramItem rowCount.
             * @member {number|Long} rowCount
             * @memberof search.proto.GroupByDateHistogramItem
             * @instance
             */
            GroupByDateHistogramItem.prototype.rowCount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * GroupByDateHistogramItem subAggsResult.
             * @member {search.proto.IAggregationsResult|null|undefined} subAggsResult
             * @memberof search.proto.GroupByDateHistogramItem
             * @instance
             */
            GroupByDateHistogramItem.prototype.subAggsResult = null;

            /**
             * GroupByDateHistogramItem subGroupBysResult.
             * @member {search.proto.IGroupBysResult|null|undefined} subGroupBysResult
             * @memberof search.proto.GroupByDateHistogramItem
             * @instance
             */
            GroupByDateHistogramItem.prototype.subGroupBysResult = null;

            /**
             * Creates a new GroupByDateHistogramItem instance using the specified properties.
             * @function create
             * @memberof search.proto.GroupByDateHistogramItem
             * @static
             * @param {search.proto.IGroupByDateHistogramItem=} [properties] Properties to set
             * @returns {search.proto.GroupByDateHistogramItem} GroupByDateHistogramItem instance
             */
            GroupByDateHistogramItem.create = function create(properties) {
                return new GroupByDateHistogramItem(properties);
            };

            /**
             * Encodes the specified GroupByDateHistogramItem message. Does not implicitly {@link search.proto.GroupByDateHistogramItem.verify|verify} messages.
             * @function encode
             * @memberof search.proto.GroupByDateHistogramItem
             * @static
             * @param {search.proto.IGroupByDateHistogramItem} message GroupByDateHistogramItem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByDateHistogramItem.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.timestamp);
                if (message.rowCount != null && Object.hasOwnProperty.call(message, "rowCount"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.rowCount);
                if (message.subAggsResult != null && Object.hasOwnProperty.call(message, "subAggsResult"))
                    $root.search.proto.AggregationsResult.encode(message.subAggsResult, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.subGroupBysResult != null && Object.hasOwnProperty.call(message, "subGroupBysResult"))
                    $root.search.proto.GroupBysResult.encode(message.subGroupBysResult, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GroupByDateHistogramItem message, length delimited. Does not implicitly {@link search.proto.GroupByDateHistogramItem.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.GroupByDateHistogramItem
             * @static
             * @param {search.proto.IGroupByDateHistogramItem} message GroupByDateHistogramItem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByDateHistogramItem.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupByDateHistogramItem message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.GroupByDateHistogramItem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.GroupByDateHistogramItem} GroupByDateHistogramItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByDateHistogramItem.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.GroupByDateHistogramItem();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.timestamp = reader.int64();
                        break;
                    case 2:
                        message.rowCount = reader.int64();
                        break;
                    case 3:
                        message.subAggsResult = $root.search.proto.AggregationsResult.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.subGroupBysResult = $root.search.proto.GroupBysResult.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupByDateHistogramItem message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.GroupByDateHistogramItem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.GroupByDateHistogramItem} GroupByDateHistogramItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByDateHistogramItem.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupByDateHistogramItem message.
             * @function verify
             * @memberof search.proto.GroupByDateHistogramItem
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupByDateHistogramItem.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                if (message.rowCount != null && message.hasOwnProperty("rowCount"))
                    if (!$util.isInteger(message.rowCount) && !(message.rowCount && $util.isInteger(message.rowCount.low) && $util.isInteger(message.rowCount.high)))
                        return "rowCount: integer|Long expected";
                if (message.subAggsResult != null && message.hasOwnProperty("subAggsResult")) {
                    var error = $root.search.proto.AggregationsResult.verify(message.subAggsResult);
                    if (error)
                        return "subAggsResult." + error;
                }
                if (message.subGroupBysResult != null && message.hasOwnProperty("subGroupBysResult")) {
                    var error = $root.search.proto.GroupBysResult.verify(message.subGroupBysResult);
                    if (error)
                        return "subGroupBysResult." + error;
                }
                return null;
            };

            /**
             * Creates a GroupByDateHistogramItem message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.GroupByDateHistogramItem
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.GroupByDateHistogramItem} GroupByDateHistogramItem
             */
            GroupByDateHistogramItem.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.GroupByDateHistogramItem)
                    return object;
                var message = new $root.search.proto.GroupByDateHistogramItem();
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                if (object.rowCount != null)
                    if ($util.Long)
                        (message.rowCount = $util.Long.fromValue(object.rowCount)).unsigned = false;
                    else if (typeof object.rowCount === "string")
                        message.rowCount = parseInt(object.rowCount, 10);
                    else if (typeof object.rowCount === "number")
                        message.rowCount = object.rowCount;
                    else if (typeof object.rowCount === "object")
                        message.rowCount = new $util.LongBits(object.rowCount.low >>> 0, object.rowCount.high >>> 0).toNumber();
                if (object.subAggsResult != null) {
                    if (typeof object.subAggsResult !== "object")
                        throw TypeError(".search.proto.GroupByDateHistogramItem.subAggsResult: object expected");
                    message.subAggsResult = $root.search.proto.AggregationsResult.fromObject(object.subAggsResult);
                }
                if (object.subGroupBysResult != null) {
                    if (typeof object.subGroupBysResult !== "object")
                        throw TypeError(".search.proto.GroupByDateHistogramItem.subGroupBysResult: object expected");
                    message.subGroupBysResult = $root.search.proto.GroupBysResult.fromObject(object.subGroupBysResult);
                }
                return message;
            };

            /**
             * Creates a plain object from a GroupByDateHistogramItem message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.GroupByDateHistogramItem
             * @static
             * @param {search.proto.GroupByDateHistogramItem} message GroupByDateHistogramItem
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupByDateHistogramItem.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.rowCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.rowCount = options.longs === String ? "0" : 0;
                    object.subAggsResult = null;
                    object.subGroupBysResult = null;
                }
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                if (message.rowCount != null && message.hasOwnProperty("rowCount"))
                    if (typeof message.rowCount === "number")
                        object.rowCount = options.longs === String ? String(message.rowCount) : message.rowCount;
                    else
                        object.rowCount = options.longs === String ? $util.Long.prototype.toString.call(message.rowCount) : options.longs === Number ? new $util.LongBits(message.rowCount.low >>> 0, message.rowCount.high >>> 0).toNumber() : message.rowCount;
                if (message.subAggsResult != null && message.hasOwnProperty("subAggsResult"))
                    object.subAggsResult = $root.search.proto.AggregationsResult.toObject(message.subAggsResult, options);
                if (message.subGroupBysResult != null && message.hasOwnProperty("subGroupBysResult"))
                    object.subGroupBysResult = $root.search.proto.GroupBysResult.toObject(message.subGroupBysResult, options);
                return object;
            };

            /**
             * Converts this GroupByDateHistogramItem to JSON.
             * @function toJSON
             * @memberof search.proto.GroupByDateHistogramItem
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupByDateHistogramItem.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GroupByDateHistogramItem;
        })();

        proto.GroupByDateHistogramResult = (function() {

            /**
             * Properties of a GroupByDateHistogramResult.
             * @memberof search.proto
             * @interface IGroupByDateHistogramResult
             * @property {Array.<search.proto.IGroupByDateHistogramItem>|null} [groupByDateHistogramItems] GroupByDateHistogramResult groupByDateHistogramItems
             */

            /**
             * Constructs a new GroupByDateHistogramResult.
             * @memberof search.proto
             * @classdesc Represents a GroupByDateHistogramResult.
             * @implements IGroupByDateHistogramResult
             * @constructor
             * @param {search.proto.IGroupByDateHistogramResult=} [properties] Properties to set
             */
            function GroupByDateHistogramResult(properties) {
                this.groupByDateHistogramItems = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupByDateHistogramResult groupByDateHistogramItems.
             * @member {Array.<search.proto.IGroupByDateHistogramItem>} groupByDateHistogramItems
             * @memberof search.proto.GroupByDateHistogramResult
             * @instance
             */
            GroupByDateHistogramResult.prototype.groupByDateHistogramItems = $util.emptyArray;

            /**
             * Creates a new GroupByDateHistogramResult instance using the specified properties.
             * @function create
             * @memberof search.proto.GroupByDateHistogramResult
             * @static
             * @param {search.proto.IGroupByDateHistogramResult=} [properties] Properties to set
             * @returns {search.proto.GroupByDateHistogramResult} GroupByDateHistogramResult instance
             */
            GroupByDateHistogramResult.create = function create(properties) {
                return new GroupByDateHistogramResult(properties);
            };

            /**
             * Encodes the specified GroupByDateHistogramResult message. Does not implicitly {@link search.proto.GroupByDateHistogramResult.verify|verify} messages.
             * @function encode
             * @memberof search.proto.GroupByDateHistogramResult
             * @static
             * @param {search.proto.IGroupByDateHistogramResult} message GroupByDateHistogramResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByDateHistogramResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupByDateHistogramItems != null && message.groupByDateHistogramItems.length)
                    for (var i = 0; i < message.groupByDateHistogramItems.length; ++i)
                        $root.search.proto.GroupByDateHistogramItem.encode(message.groupByDateHistogramItems[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GroupByDateHistogramResult message, length delimited. Does not implicitly {@link search.proto.GroupByDateHistogramResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.GroupByDateHistogramResult
             * @static
             * @param {search.proto.IGroupByDateHistogramResult} message GroupByDateHistogramResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByDateHistogramResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupByDateHistogramResult message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.GroupByDateHistogramResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.GroupByDateHistogramResult} GroupByDateHistogramResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByDateHistogramResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.GroupByDateHistogramResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.groupByDateHistogramItems && message.groupByDateHistogramItems.length))
                            message.groupByDateHistogramItems = [];
                        message.groupByDateHistogramItems.push($root.search.proto.GroupByDateHistogramItem.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupByDateHistogramResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.GroupByDateHistogramResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.GroupByDateHistogramResult} GroupByDateHistogramResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByDateHistogramResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupByDateHistogramResult message.
             * @function verify
             * @memberof search.proto.GroupByDateHistogramResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupByDateHistogramResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupByDateHistogramItems != null && message.hasOwnProperty("groupByDateHistogramItems")) {
                    if (!Array.isArray(message.groupByDateHistogramItems))
                        return "groupByDateHistogramItems: array expected";
                    for (var i = 0; i < message.groupByDateHistogramItems.length; ++i) {
                        var error = $root.search.proto.GroupByDateHistogramItem.verify(message.groupByDateHistogramItems[i]);
                        if (error)
                            return "groupByDateHistogramItems." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GroupByDateHistogramResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.GroupByDateHistogramResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.GroupByDateHistogramResult} GroupByDateHistogramResult
             */
            GroupByDateHistogramResult.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.GroupByDateHistogramResult)
                    return object;
                var message = new $root.search.proto.GroupByDateHistogramResult();
                if (object.groupByDateHistogramItems) {
                    if (!Array.isArray(object.groupByDateHistogramItems))
                        throw TypeError(".search.proto.GroupByDateHistogramResult.groupByDateHistogramItems: array expected");
                    message.groupByDateHistogramItems = [];
                    for (var i = 0; i < object.groupByDateHistogramItems.length; ++i) {
                        if (typeof object.groupByDateHistogramItems[i] !== "object")
                            throw TypeError(".search.proto.GroupByDateHistogramResult.groupByDateHistogramItems: object expected");
                        message.groupByDateHistogramItems[i] = $root.search.proto.GroupByDateHistogramItem.fromObject(object.groupByDateHistogramItems[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GroupByDateHistogramResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.GroupByDateHistogramResult
             * @static
             * @param {search.proto.GroupByDateHistogramResult} message GroupByDateHistogramResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupByDateHistogramResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.groupByDateHistogramItems = [];
                if (message.groupByDateHistogramItems && message.groupByDateHistogramItems.length) {
                    object.groupByDateHistogramItems = [];
                    for (var j = 0; j < message.groupByDateHistogramItems.length; ++j)
                        object.groupByDateHistogramItems[j] = $root.search.proto.GroupByDateHistogramItem.toObject(message.groupByDateHistogramItems[j], options);
                }
                return object;
            };

            /**
             * Converts this GroupByDateHistogramResult to JSON.
             * @function toJSON
             * @memberof search.proto.GroupByDateHistogramResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupByDateHistogramResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GroupByDateHistogramResult;
        })();

        proto.GroupByGeoGridResultItem = (function() {

            /**
             * Properties of a GroupByGeoGridResultItem.
             * @memberof search.proto
             * @interface IGroupByGeoGridResultItem
             * @property {string|null} [key] GroupByGeoGridResultItem key
             * @property {search.proto.IGeoGrid|null} [geoGrid] GroupByGeoGridResultItem geoGrid
             * @property {number|Long|null} [rowCount] GroupByGeoGridResultItem rowCount
             * @property {search.proto.IAggregationsResult|null} [subAggsResult] GroupByGeoGridResultItem subAggsResult
             * @property {search.proto.IGroupBysResult|null} [subGroupBysResult] GroupByGeoGridResultItem subGroupBysResult
             */

            /**
             * Constructs a new GroupByGeoGridResultItem.
             * @memberof search.proto
             * @classdesc Represents a GroupByGeoGridResultItem.
             * @implements IGroupByGeoGridResultItem
             * @constructor
             * @param {search.proto.IGroupByGeoGridResultItem=} [properties] Properties to set
             */
            function GroupByGeoGridResultItem(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupByGeoGridResultItem key.
             * @member {string} key
             * @memberof search.proto.GroupByGeoGridResultItem
             * @instance
             */
            GroupByGeoGridResultItem.prototype.key = "";

            /**
             * GroupByGeoGridResultItem geoGrid.
             * @member {search.proto.IGeoGrid|null|undefined} geoGrid
             * @memberof search.proto.GroupByGeoGridResultItem
             * @instance
             */
            GroupByGeoGridResultItem.prototype.geoGrid = null;

            /**
             * GroupByGeoGridResultItem rowCount.
             * @member {number|Long} rowCount
             * @memberof search.proto.GroupByGeoGridResultItem
             * @instance
             */
            GroupByGeoGridResultItem.prototype.rowCount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * GroupByGeoGridResultItem subAggsResult.
             * @member {search.proto.IAggregationsResult|null|undefined} subAggsResult
             * @memberof search.proto.GroupByGeoGridResultItem
             * @instance
             */
            GroupByGeoGridResultItem.prototype.subAggsResult = null;

            /**
             * GroupByGeoGridResultItem subGroupBysResult.
             * @member {search.proto.IGroupBysResult|null|undefined} subGroupBysResult
             * @memberof search.proto.GroupByGeoGridResultItem
             * @instance
             */
            GroupByGeoGridResultItem.prototype.subGroupBysResult = null;

            /**
             * Creates a new GroupByGeoGridResultItem instance using the specified properties.
             * @function create
             * @memberof search.proto.GroupByGeoGridResultItem
             * @static
             * @param {search.proto.IGroupByGeoGridResultItem=} [properties] Properties to set
             * @returns {search.proto.GroupByGeoGridResultItem} GroupByGeoGridResultItem instance
             */
            GroupByGeoGridResultItem.create = function create(properties) {
                return new GroupByGeoGridResultItem(properties);
            };

            /**
             * Encodes the specified GroupByGeoGridResultItem message. Does not implicitly {@link search.proto.GroupByGeoGridResultItem.verify|verify} messages.
             * @function encode
             * @memberof search.proto.GroupByGeoGridResultItem
             * @static
             * @param {search.proto.IGroupByGeoGridResultItem} message GroupByGeoGridResultItem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByGeoGridResultItem.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                if (message.geoGrid != null && Object.hasOwnProperty.call(message, "geoGrid"))
                    $root.search.proto.GeoGrid.encode(message.geoGrid, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.rowCount != null && Object.hasOwnProperty.call(message, "rowCount"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.rowCount);
                if (message.subAggsResult != null && Object.hasOwnProperty.call(message, "subAggsResult"))
                    $root.search.proto.AggregationsResult.encode(message.subAggsResult, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.subGroupBysResult != null && Object.hasOwnProperty.call(message, "subGroupBysResult"))
                    $root.search.proto.GroupBysResult.encode(message.subGroupBysResult, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GroupByGeoGridResultItem message, length delimited. Does not implicitly {@link search.proto.GroupByGeoGridResultItem.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.GroupByGeoGridResultItem
             * @static
             * @param {search.proto.IGroupByGeoGridResultItem} message GroupByGeoGridResultItem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByGeoGridResultItem.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupByGeoGridResultItem message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.GroupByGeoGridResultItem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.GroupByGeoGridResultItem} GroupByGeoGridResultItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByGeoGridResultItem.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.GroupByGeoGridResultItem();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.string();
                        break;
                    case 2:
                        message.geoGrid = $root.search.proto.GeoGrid.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.rowCount = reader.int64();
                        break;
                    case 4:
                        message.subAggsResult = $root.search.proto.AggregationsResult.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.subGroupBysResult = $root.search.proto.GroupBysResult.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupByGeoGridResultItem message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.GroupByGeoGridResultItem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.GroupByGeoGridResultItem} GroupByGeoGridResultItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByGeoGridResultItem.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupByGeoGridResultItem message.
             * @function verify
             * @memberof search.proto.GroupByGeoGridResultItem
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupByGeoGridResultItem.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.geoGrid != null && message.hasOwnProperty("geoGrid")) {
                    var error = $root.search.proto.GeoGrid.verify(message.geoGrid);
                    if (error)
                        return "geoGrid." + error;
                }
                if (message.rowCount != null && message.hasOwnProperty("rowCount"))
                    if (!$util.isInteger(message.rowCount) && !(message.rowCount && $util.isInteger(message.rowCount.low) && $util.isInteger(message.rowCount.high)))
                        return "rowCount: integer|Long expected";
                if (message.subAggsResult != null && message.hasOwnProperty("subAggsResult")) {
                    var error = $root.search.proto.AggregationsResult.verify(message.subAggsResult);
                    if (error)
                        return "subAggsResult." + error;
                }
                if (message.subGroupBysResult != null && message.hasOwnProperty("subGroupBysResult")) {
                    var error = $root.search.proto.GroupBysResult.verify(message.subGroupBysResult);
                    if (error)
                        return "subGroupBysResult." + error;
                }
                return null;
            };

            /**
             * Creates a GroupByGeoGridResultItem message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.GroupByGeoGridResultItem
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.GroupByGeoGridResultItem} GroupByGeoGridResultItem
             */
            GroupByGeoGridResultItem.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.GroupByGeoGridResultItem)
                    return object;
                var message = new $root.search.proto.GroupByGeoGridResultItem();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.geoGrid != null) {
                    if (typeof object.geoGrid !== "object")
                        throw TypeError(".search.proto.GroupByGeoGridResultItem.geoGrid: object expected");
                    message.geoGrid = $root.search.proto.GeoGrid.fromObject(object.geoGrid);
                }
                if (object.rowCount != null)
                    if ($util.Long)
                        (message.rowCount = $util.Long.fromValue(object.rowCount)).unsigned = false;
                    else if (typeof object.rowCount === "string")
                        message.rowCount = parseInt(object.rowCount, 10);
                    else if (typeof object.rowCount === "number")
                        message.rowCount = object.rowCount;
                    else if (typeof object.rowCount === "object")
                        message.rowCount = new $util.LongBits(object.rowCount.low >>> 0, object.rowCount.high >>> 0).toNumber();
                if (object.subAggsResult != null) {
                    if (typeof object.subAggsResult !== "object")
                        throw TypeError(".search.proto.GroupByGeoGridResultItem.subAggsResult: object expected");
                    message.subAggsResult = $root.search.proto.AggregationsResult.fromObject(object.subAggsResult);
                }
                if (object.subGroupBysResult != null) {
                    if (typeof object.subGroupBysResult !== "object")
                        throw TypeError(".search.proto.GroupByGeoGridResultItem.subGroupBysResult: object expected");
                    message.subGroupBysResult = $root.search.proto.GroupBysResult.fromObject(object.subGroupBysResult);
                }
                return message;
            };

            /**
             * Creates a plain object from a GroupByGeoGridResultItem message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.GroupByGeoGridResultItem
             * @static
             * @param {search.proto.GroupByGeoGridResultItem} message GroupByGeoGridResultItem
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupByGeoGridResultItem.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.key = "";
                    object.geoGrid = null;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.rowCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.rowCount = options.longs === String ? "0" : 0;
                    object.subAggsResult = null;
                    object.subGroupBysResult = null;
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.geoGrid != null && message.hasOwnProperty("geoGrid"))
                    object.geoGrid = $root.search.proto.GeoGrid.toObject(message.geoGrid, options);
                if (message.rowCount != null && message.hasOwnProperty("rowCount"))
                    if (typeof message.rowCount === "number")
                        object.rowCount = options.longs === String ? String(message.rowCount) : message.rowCount;
                    else
                        object.rowCount = options.longs === String ? $util.Long.prototype.toString.call(message.rowCount) : options.longs === Number ? new $util.LongBits(message.rowCount.low >>> 0, message.rowCount.high >>> 0).toNumber() : message.rowCount;
                if (message.subAggsResult != null && message.hasOwnProperty("subAggsResult"))
                    object.subAggsResult = $root.search.proto.AggregationsResult.toObject(message.subAggsResult, options);
                if (message.subGroupBysResult != null && message.hasOwnProperty("subGroupBysResult"))
                    object.subGroupBysResult = $root.search.proto.GroupBysResult.toObject(message.subGroupBysResult, options);
                return object;
            };

            /**
             * Converts this GroupByGeoGridResultItem to JSON.
             * @function toJSON
             * @memberof search.proto.GroupByGeoGridResultItem
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupByGeoGridResultItem.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GroupByGeoGridResultItem;
        })();

        proto.GroupByGeoGridResult = (function() {

            /**
             * Properties of a GroupByGeoGridResult.
             * @memberof search.proto
             * @interface IGroupByGeoGridResult
             * @property {Array.<search.proto.IGroupByGeoGridResultItem>|null} [groupByGeoGridResultItems] GroupByGeoGridResult groupByGeoGridResultItems
             */

            /**
             * Constructs a new GroupByGeoGridResult.
             * @memberof search.proto
             * @classdesc Represents a GroupByGeoGridResult.
             * @implements IGroupByGeoGridResult
             * @constructor
             * @param {search.proto.IGroupByGeoGridResult=} [properties] Properties to set
             */
            function GroupByGeoGridResult(properties) {
                this.groupByGeoGridResultItems = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupByGeoGridResult groupByGeoGridResultItems.
             * @member {Array.<search.proto.IGroupByGeoGridResultItem>} groupByGeoGridResultItems
             * @memberof search.proto.GroupByGeoGridResult
             * @instance
             */
            GroupByGeoGridResult.prototype.groupByGeoGridResultItems = $util.emptyArray;

            /**
             * Creates a new GroupByGeoGridResult instance using the specified properties.
             * @function create
             * @memberof search.proto.GroupByGeoGridResult
             * @static
             * @param {search.proto.IGroupByGeoGridResult=} [properties] Properties to set
             * @returns {search.proto.GroupByGeoGridResult} GroupByGeoGridResult instance
             */
            GroupByGeoGridResult.create = function create(properties) {
                return new GroupByGeoGridResult(properties);
            };

            /**
             * Encodes the specified GroupByGeoGridResult message. Does not implicitly {@link search.proto.GroupByGeoGridResult.verify|verify} messages.
             * @function encode
             * @memberof search.proto.GroupByGeoGridResult
             * @static
             * @param {search.proto.IGroupByGeoGridResult} message GroupByGeoGridResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByGeoGridResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupByGeoGridResultItems != null && message.groupByGeoGridResultItems.length)
                    for (var i = 0; i < message.groupByGeoGridResultItems.length; ++i)
                        $root.search.proto.GroupByGeoGridResultItem.encode(message.groupByGeoGridResultItems[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GroupByGeoGridResult message, length delimited. Does not implicitly {@link search.proto.GroupByGeoGridResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.GroupByGeoGridResult
             * @static
             * @param {search.proto.IGroupByGeoGridResult} message GroupByGeoGridResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupByGeoGridResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupByGeoGridResult message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.GroupByGeoGridResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.GroupByGeoGridResult} GroupByGeoGridResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByGeoGridResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.GroupByGeoGridResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.groupByGeoGridResultItems && message.groupByGeoGridResultItems.length))
                            message.groupByGeoGridResultItems = [];
                        message.groupByGeoGridResultItems.push($root.search.proto.GroupByGeoGridResultItem.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupByGeoGridResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.GroupByGeoGridResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.GroupByGeoGridResult} GroupByGeoGridResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupByGeoGridResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupByGeoGridResult message.
             * @function verify
             * @memberof search.proto.GroupByGeoGridResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupByGeoGridResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupByGeoGridResultItems != null && message.hasOwnProperty("groupByGeoGridResultItems")) {
                    if (!Array.isArray(message.groupByGeoGridResultItems))
                        return "groupByGeoGridResultItems: array expected";
                    for (var i = 0; i < message.groupByGeoGridResultItems.length; ++i) {
                        var error = $root.search.proto.GroupByGeoGridResultItem.verify(message.groupByGeoGridResultItems[i]);
                        if (error)
                            return "groupByGeoGridResultItems." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GroupByGeoGridResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.GroupByGeoGridResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.GroupByGeoGridResult} GroupByGeoGridResult
             */
            GroupByGeoGridResult.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.GroupByGeoGridResult)
                    return object;
                var message = new $root.search.proto.GroupByGeoGridResult();
                if (object.groupByGeoGridResultItems) {
                    if (!Array.isArray(object.groupByGeoGridResultItems))
                        throw TypeError(".search.proto.GroupByGeoGridResult.groupByGeoGridResultItems: array expected");
                    message.groupByGeoGridResultItems = [];
                    for (var i = 0; i < object.groupByGeoGridResultItems.length; ++i) {
                        if (typeof object.groupByGeoGridResultItems[i] !== "object")
                            throw TypeError(".search.proto.GroupByGeoGridResult.groupByGeoGridResultItems: object expected");
                        message.groupByGeoGridResultItems[i] = $root.search.proto.GroupByGeoGridResultItem.fromObject(object.groupByGeoGridResultItems[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GroupByGeoGridResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.GroupByGeoGridResult
             * @static
             * @param {search.proto.GroupByGeoGridResult} message GroupByGeoGridResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupByGeoGridResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.groupByGeoGridResultItems = [];
                if (message.groupByGeoGridResultItems && message.groupByGeoGridResultItems.length) {
                    object.groupByGeoGridResultItems = [];
                    for (var j = 0; j < message.groupByGeoGridResultItems.length; ++j)
                        object.groupByGeoGridResultItems[j] = $root.search.proto.GroupByGeoGridResultItem.toObject(message.groupByGeoGridResultItems[j], options);
                }
                return object;
            };

            /**
             * Converts this GroupByGeoGridResult to JSON.
             * @function toJSON
             * @memberof search.proto.GroupByGeoGridResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupByGeoGridResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GroupByGeoGridResult;
        })();

        /**
         * QueryType enum.
         * @name search.proto.QueryType
         * @enum {number}
         * @property {number} MATCH_QUERY=1 MATCH_QUERY value
         * @property {number} MATCH_PHRASE_QUERY=2 MATCH_PHRASE_QUERY value
         * @property {number} TERM_QUERY=3 TERM_QUERY value
         * @property {number} RANGE_QUERY=4 RANGE_QUERY value
         * @property {number} PREFIX_QUERY=5 PREFIX_QUERY value
         * @property {number} BOOL_QUERY=6 BOOL_QUERY value
         * @property {number} CONST_SCORE_QUERY=7 CONST_SCORE_QUERY value
         * @property {number} FUNCTION_SCORE_QUERY=8 FUNCTION_SCORE_QUERY value
         * @property {number} NESTED_QUERY=9 NESTED_QUERY value
         * @property {number} WILDCARD_QUERY=10 WILDCARD_QUERY value
         * @property {number} MATCH_ALL_QUERY=11 MATCH_ALL_QUERY value
         * @property {number} GEO_BOUNDING_BOX_QUERY=12 GEO_BOUNDING_BOX_QUERY value
         * @property {number} GEO_DISTANCE_QUERY=13 GEO_DISTANCE_QUERY value
         * @property {number} GEO_POLYGON_QUERY=14 GEO_POLYGON_QUERY value
         * @property {number} TERMS_QUERY=15 TERMS_QUERY value
         * @property {number} EXISTS_QUERY=16 EXISTS_QUERY value
         * @property {number} KNN_VECTOR_QUERY=17 KNN_VECTOR_QUERY value
         * @property {number} FUNCTIONS_SCORE_QUERY=18 FUNCTIONS_SCORE_QUERY value
         */
        proto.QueryType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "MATCH_QUERY"] = 1;
            values[valuesById[2] = "MATCH_PHRASE_QUERY"] = 2;
            values[valuesById[3] = "TERM_QUERY"] = 3;
            values[valuesById[4] = "RANGE_QUERY"] = 4;
            values[valuesById[5] = "PREFIX_QUERY"] = 5;
            values[valuesById[6] = "BOOL_QUERY"] = 6;
            values[valuesById[7] = "CONST_SCORE_QUERY"] = 7;
            values[valuesById[8] = "FUNCTION_SCORE_QUERY"] = 8;
            values[valuesById[9] = "NESTED_QUERY"] = 9;
            values[valuesById[10] = "WILDCARD_QUERY"] = 10;
            values[valuesById[11] = "MATCH_ALL_QUERY"] = 11;
            values[valuesById[12] = "GEO_BOUNDING_BOX_QUERY"] = 12;
            values[valuesById[13] = "GEO_DISTANCE_QUERY"] = 13;
            values[valuesById[14] = "GEO_POLYGON_QUERY"] = 14;
            values[valuesById[15] = "TERMS_QUERY"] = 15;
            values[valuesById[16] = "EXISTS_QUERY"] = 16;
            values[valuesById[17] = "KNN_VECTOR_QUERY"] = 17;
            values[valuesById[18] = "FUNCTIONS_SCORE_QUERY"] = 18;
            return values;
        })();

        /**
         * QueryOperator enum.
         * @name search.proto.QueryOperator
         * @enum {number}
         * @property {number} OR=1 OR value
         * @property {number} AND=2 AND value
         */
        proto.QueryOperator = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "OR"] = 1;
            values[valuesById[2] = "AND"] = 2;
            return values;
        })();

        proto.MatchQuery = (function() {

            /**
             * Properties of a MatchQuery.
             * @memberof search.proto
             * @interface IMatchQuery
             * @property {string|null} [fieldName] MatchQuery fieldName
             * @property {string|null} [text] MatchQuery text
             * @property {number|null} [minimumShouldMatch] MatchQuery minimumShouldMatch
             * @property {search.proto.QueryOperator|null} [operator] MatchQuery operator
             * @property {number|null} [weight] MatchQuery weight
             */

            /**
             * Constructs a new MatchQuery.
             * @memberof search.proto
             * @classdesc Represents a MatchQuery.
             * @implements IMatchQuery
             * @constructor
             * @param {search.proto.IMatchQuery=} [properties] Properties to set
             */
            function MatchQuery(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MatchQuery fieldName.
             * @member {string} fieldName
             * @memberof search.proto.MatchQuery
             * @instance
             */
            MatchQuery.prototype.fieldName = "";

            /**
             * MatchQuery text.
             * @member {string} text
             * @memberof search.proto.MatchQuery
             * @instance
             */
            MatchQuery.prototype.text = "";

            /**
             * MatchQuery minimumShouldMatch.
             * @member {number} minimumShouldMatch
             * @memberof search.proto.MatchQuery
             * @instance
             */
            MatchQuery.prototype.minimumShouldMatch = 0;

            /**
             * MatchQuery operator.
             * @member {search.proto.QueryOperator} operator
             * @memberof search.proto.MatchQuery
             * @instance
             */
            MatchQuery.prototype.operator = 1;

            /**
             * MatchQuery weight.
             * @member {number} weight
             * @memberof search.proto.MatchQuery
             * @instance
             */
            MatchQuery.prototype.weight = 0;

            /**
             * Creates a new MatchQuery instance using the specified properties.
             * @function create
             * @memberof search.proto.MatchQuery
             * @static
             * @param {search.proto.IMatchQuery=} [properties] Properties to set
             * @returns {search.proto.MatchQuery} MatchQuery instance
             */
            MatchQuery.create = function create(properties) {
                return new MatchQuery(properties);
            };

            /**
             * Encodes the specified MatchQuery message. Does not implicitly {@link search.proto.MatchQuery.verify|verify} messages.
             * @function encode
             * @memberof search.proto.MatchQuery
             * @static
             * @param {search.proto.IMatchQuery} message MatchQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MatchQuery.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fieldName != null && Object.hasOwnProperty.call(message, "fieldName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fieldName);
                if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.text);
                if (message.minimumShouldMatch != null && Object.hasOwnProperty.call(message, "minimumShouldMatch"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.minimumShouldMatch);
                if (message.operator != null && Object.hasOwnProperty.call(message, "operator"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.operator);
                if (message.weight != null && Object.hasOwnProperty.call(message, "weight"))
                    writer.uint32(/* id 5, wireType 5 =*/45).float(message.weight);
                return writer;
            };

            /**
             * Encodes the specified MatchQuery message, length delimited. Does not implicitly {@link search.proto.MatchQuery.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.MatchQuery
             * @static
             * @param {search.proto.IMatchQuery} message MatchQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MatchQuery.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MatchQuery message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.MatchQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.MatchQuery} MatchQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MatchQuery.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.MatchQuery();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fieldName = reader.string();
                        break;
                    case 2:
                        message.text = reader.string();
                        break;
                    case 3:
                        message.minimumShouldMatch = reader.int32();
                        break;
                    case 4:
                        message.operator = reader.int32();
                        break;
                    case 5:
                        message.weight = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MatchQuery message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.MatchQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.MatchQuery} MatchQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MatchQuery.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MatchQuery message.
             * @function verify
             * @memberof search.proto.MatchQuery
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MatchQuery.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    if (!$util.isString(message.fieldName))
                        return "fieldName: string expected";
                if (message.text != null && message.hasOwnProperty("text"))
                    if (!$util.isString(message.text))
                        return "text: string expected";
                if (message.minimumShouldMatch != null && message.hasOwnProperty("minimumShouldMatch"))
                    if (!$util.isInteger(message.minimumShouldMatch))
                        return "minimumShouldMatch: integer expected";
                if (message.operator != null && message.hasOwnProperty("operator"))
                    switch (message.operator) {
                    default:
                        return "operator: enum value expected";
                    case 1:
                    case 2:
                        break;
                    }
                if (message.weight != null && message.hasOwnProperty("weight"))
                    if (typeof message.weight !== "number")
                        return "weight: number expected";
                return null;
            };

            /**
             * Creates a MatchQuery message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.MatchQuery
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.MatchQuery} MatchQuery
             */
            MatchQuery.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.MatchQuery)
                    return object;
                var message = new $root.search.proto.MatchQuery();
                if (object.fieldName != null)
                    message.fieldName = String(object.fieldName);
                if (object.text != null)
                    message.text = String(object.text);
                if (object.minimumShouldMatch != null)
                    message.minimumShouldMatch = object.minimumShouldMatch | 0;
                switch (object.operator) {
                case "OR":
                case 1:
                    message.operator = 1;
                    break;
                case "AND":
                case 2:
                    message.operator = 2;
                    break;
                }
                if (object.weight != null)
                    message.weight = Number(object.weight);
                return message;
            };

            /**
             * Creates a plain object from a MatchQuery message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.MatchQuery
             * @static
             * @param {search.proto.MatchQuery} message MatchQuery
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MatchQuery.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.fieldName = "";
                    object.text = "";
                    object.minimumShouldMatch = 0;
                    object.operator = options.enums === String ? "OR" : 1;
                    object.weight = 0;
                }
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    object.fieldName = message.fieldName;
                if (message.text != null && message.hasOwnProperty("text"))
                    object.text = message.text;
                if (message.minimumShouldMatch != null && message.hasOwnProperty("minimumShouldMatch"))
                    object.minimumShouldMatch = message.minimumShouldMatch;
                if (message.operator != null && message.hasOwnProperty("operator"))
                    object.operator = options.enums === String ? $root.search.proto.QueryOperator[message.operator] : message.operator;
                if (message.weight != null && message.hasOwnProperty("weight"))
                    object.weight = options.json && !isFinite(message.weight) ? String(message.weight) : message.weight;
                return object;
            };

            /**
             * Converts this MatchQuery to JSON.
             * @function toJSON
             * @memberof search.proto.MatchQuery
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MatchQuery.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MatchQuery;
        })();

        proto.MatchPhraseQuery = (function() {

            /**
             * Properties of a MatchPhraseQuery.
             * @memberof search.proto
             * @interface IMatchPhraseQuery
             * @property {string|null} [fieldName] MatchPhraseQuery fieldName
             * @property {string|null} [text] MatchPhraseQuery text
             * @property {number|null} [weight] MatchPhraseQuery weight
             */

            /**
             * Constructs a new MatchPhraseQuery.
             * @memberof search.proto
             * @classdesc Represents a MatchPhraseQuery.
             * @implements IMatchPhraseQuery
             * @constructor
             * @param {search.proto.IMatchPhraseQuery=} [properties] Properties to set
             */
            function MatchPhraseQuery(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MatchPhraseQuery fieldName.
             * @member {string} fieldName
             * @memberof search.proto.MatchPhraseQuery
             * @instance
             */
            MatchPhraseQuery.prototype.fieldName = "";

            /**
             * MatchPhraseQuery text.
             * @member {string} text
             * @memberof search.proto.MatchPhraseQuery
             * @instance
             */
            MatchPhraseQuery.prototype.text = "";

            /**
             * MatchPhraseQuery weight.
             * @member {number} weight
             * @memberof search.proto.MatchPhraseQuery
             * @instance
             */
            MatchPhraseQuery.prototype.weight = 0;

            /**
             * Creates a new MatchPhraseQuery instance using the specified properties.
             * @function create
             * @memberof search.proto.MatchPhraseQuery
             * @static
             * @param {search.proto.IMatchPhraseQuery=} [properties] Properties to set
             * @returns {search.proto.MatchPhraseQuery} MatchPhraseQuery instance
             */
            MatchPhraseQuery.create = function create(properties) {
                return new MatchPhraseQuery(properties);
            };

            /**
             * Encodes the specified MatchPhraseQuery message. Does not implicitly {@link search.proto.MatchPhraseQuery.verify|verify} messages.
             * @function encode
             * @memberof search.proto.MatchPhraseQuery
             * @static
             * @param {search.proto.IMatchPhraseQuery} message MatchPhraseQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MatchPhraseQuery.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fieldName != null && Object.hasOwnProperty.call(message, "fieldName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fieldName);
                if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.text);
                if (message.weight != null && Object.hasOwnProperty.call(message, "weight"))
                    writer.uint32(/* id 3, wireType 5 =*/29).float(message.weight);
                return writer;
            };

            /**
             * Encodes the specified MatchPhraseQuery message, length delimited. Does not implicitly {@link search.proto.MatchPhraseQuery.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.MatchPhraseQuery
             * @static
             * @param {search.proto.IMatchPhraseQuery} message MatchPhraseQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MatchPhraseQuery.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MatchPhraseQuery message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.MatchPhraseQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.MatchPhraseQuery} MatchPhraseQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MatchPhraseQuery.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.MatchPhraseQuery();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fieldName = reader.string();
                        break;
                    case 2:
                        message.text = reader.string();
                        break;
                    case 3:
                        message.weight = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MatchPhraseQuery message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.MatchPhraseQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.MatchPhraseQuery} MatchPhraseQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MatchPhraseQuery.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MatchPhraseQuery message.
             * @function verify
             * @memberof search.proto.MatchPhraseQuery
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MatchPhraseQuery.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    if (!$util.isString(message.fieldName))
                        return "fieldName: string expected";
                if (message.text != null && message.hasOwnProperty("text"))
                    if (!$util.isString(message.text))
                        return "text: string expected";
                if (message.weight != null && message.hasOwnProperty("weight"))
                    if (typeof message.weight !== "number")
                        return "weight: number expected";
                return null;
            };

            /**
             * Creates a MatchPhraseQuery message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.MatchPhraseQuery
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.MatchPhraseQuery} MatchPhraseQuery
             */
            MatchPhraseQuery.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.MatchPhraseQuery)
                    return object;
                var message = new $root.search.proto.MatchPhraseQuery();
                if (object.fieldName != null)
                    message.fieldName = String(object.fieldName);
                if (object.text != null)
                    message.text = String(object.text);
                if (object.weight != null)
                    message.weight = Number(object.weight);
                return message;
            };

            /**
             * Creates a plain object from a MatchPhraseQuery message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.MatchPhraseQuery
             * @static
             * @param {search.proto.MatchPhraseQuery} message MatchPhraseQuery
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MatchPhraseQuery.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.fieldName = "";
                    object.text = "";
                    object.weight = 0;
                }
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    object.fieldName = message.fieldName;
                if (message.text != null && message.hasOwnProperty("text"))
                    object.text = message.text;
                if (message.weight != null && message.hasOwnProperty("weight"))
                    object.weight = options.json && !isFinite(message.weight) ? String(message.weight) : message.weight;
                return object;
            };

            /**
             * Converts this MatchPhraseQuery to JSON.
             * @function toJSON
             * @memberof search.proto.MatchPhraseQuery
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MatchPhraseQuery.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MatchPhraseQuery;
        })();

        proto.MatchAllQuery = (function() {

            /**
             * Properties of a MatchAllQuery.
             * @memberof search.proto
             * @interface IMatchAllQuery
             */

            /**
             * Constructs a new MatchAllQuery.
             * @memberof search.proto
             * @classdesc Represents a MatchAllQuery.
             * @implements IMatchAllQuery
             * @constructor
             * @param {search.proto.IMatchAllQuery=} [properties] Properties to set
             */
            function MatchAllQuery(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new MatchAllQuery instance using the specified properties.
             * @function create
             * @memberof search.proto.MatchAllQuery
             * @static
             * @param {search.proto.IMatchAllQuery=} [properties] Properties to set
             * @returns {search.proto.MatchAllQuery} MatchAllQuery instance
             */
            MatchAllQuery.create = function create(properties) {
                return new MatchAllQuery(properties);
            };

            /**
             * Encodes the specified MatchAllQuery message. Does not implicitly {@link search.proto.MatchAllQuery.verify|verify} messages.
             * @function encode
             * @memberof search.proto.MatchAllQuery
             * @static
             * @param {search.proto.IMatchAllQuery} message MatchAllQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MatchAllQuery.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified MatchAllQuery message, length delimited. Does not implicitly {@link search.proto.MatchAllQuery.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.MatchAllQuery
             * @static
             * @param {search.proto.IMatchAllQuery} message MatchAllQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MatchAllQuery.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MatchAllQuery message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.MatchAllQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.MatchAllQuery} MatchAllQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MatchAllQuery.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.MatchAllQuery();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MatchAllQuery message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.MatchAllQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.MatchAllQuery} MatchAllQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MatchAllQuery.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MatchAllQuery message.
             * @function verify
             * @memberof search.proto.MatchAllQuery
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MatchAllQuery.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a MatchAllQuery message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.MatchAllQuery
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.MatchAllQuery} MatchAllQuery
             */
            MatchAllQuery.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.MatchAllQuery)
                    return object;
                return new $root.search.proto.MatchAllQuery();
            };

            /**
             * Creates a plain object from a MatchAllQuery message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.MatchAllQuery
             * @static
             * @param {search.proto.MatchAllQuery} message MatchAllQuery
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MatchAllQuery.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this MatchAllQuery to JSON.
             * @function toJSON
             * @memberof search.proto.MatchAllQuery
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MatchAllQuery.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MatchAllQuery;
        })();

        proto.TermQuery = (function() {

            /**
             * Properties of a TermQuery.
             * @memberof search.proto
             * @interface ITermQuery
             * @property {string|null} [fieldName] TermQuery fieldName
             * @property {Uint8Array|null} [term] TermQuery term
             * @property {number|null} [weight] TermQuery weight
             */

            /**
             * Constructs a new TermQuery.
             * @memberof search.proto
             * @classdesc Represents a TermQuery.
             * @implements ITermQuery
             * @constructor
             * @param {search.proto.ITermQuery=} [properties] Properties to set
             */
            function TermQuery(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TermQuery fieldName.
             * @member {string} fieldName
             * @memberof search.proto.TermQuery
             * @instance
             */
            TermQuery.prototype.fieldName = "";

            /**
             * TermQuery term.
             * @member {Uint8Array} term
             * @memberof search.proto.TermQuery
             * @instance
             */
            TermQuery.prototype.term = $util.newBuffer([]);

            /**
             * TermQuery weight.
             * @member {number} weight
             * @memberof search.proto.TermQuery
             * @instance
             */
            TermQuery.prototype.weight = 0;

            /**
             * Creates a new TermQuery instance using the specified properties.
             * @function create
             * @memberof search.proto.TermQuery
             * @static
             * @param {search.proto.ITermQuery=} [properties] Properties to set
             * @returns {search.proto.TermQuery} TermQuery instance
             */
            TermQuery.create = function create(properties) {
                return new TermQuery(properties);
            };

            /**
             * Encodes the specified TermQuery message. Does not implicitly {@link search.proto.TermQuery.verify|verify} messages.
             * @function encode
             * @memberof search.proto.TermQuery
             * @static
             * @param {search.proto.ITermQuery} message TermQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TermQuery.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fieldName != null && Object.hasOwnProperty.call(message, "fieldName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fieldName);
                if (message.term != null && Object.hasOwnProperty.call(message, "term"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.term);
                if (message.weight != null && Object.hasOwnProperty.call(message, "weight"))
                    writer.uint32(/* id 3, wireType 5 =*/29).float(message.weight);
                return writer;
            };

            /**
             * Encodes the specified TermQuery message, length delimited. Does not implicitly {@link search.proto.TermQuery.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.TermQuery
             * @static
             * @param {search.proto.ITermQuery} message TermQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TermQuery.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TermQuery message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.TermQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.TermQuery} TermQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TermQuery.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.TermQuery();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fieldName = reader.string();
                        break;
                    case 2:
                        message.term = reader.bytes();
                        break;
                    case 3:
                        message.weight = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TermQuery message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.TermQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.TermQuery} TermQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TermQuery.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TermQuery message.
             * @function verify
             * @memberof search.proto.TermQuery
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TermQuery.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    if (!$util.isString(message.fieldName))
                        return "fieldName: string expected";
                if (message.term != null && message.hasOwnProperty("term"))
                    if (!(message.term && typeof message.term.length === "number" || $util.isString(message.term)))
                        return "term: buffer expected";
                if (message.weight != null && message.hasOwnProperty("weight"))
                    if (typeof message.weight !== "number")
                        return "weight: number expected";
                return null;
            };

            /**
             * Creates a TermQuery message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.TermQuery
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.TermQuery} TermQuery
             */
            TermQuery.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.TermQuery)
                    return object;
                var message = new $root.search.proto.TermQuery();
                if (object.fieldName != null)
                    message.fieldName = String(object.fieldName);
                if (object.term != null)
                    if (typeof object.term === "string")
                        $util.base64.decode(object.term, message.term = $util.newBuffer($util.base64.length(object.term)), 0);
                    else if (object.term.length)
                        message.term = object.term;
                if (object.weight != null)
                    message.weight = Number(object.weight);
                return message;
            };

            /**
             * Creates a plain object from a TermQuery message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.TermQuery
             * @static
             * @param {search.proto.TermQuery} message TermQuery
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TermQuery.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.fieldName = "";
                    if (options.bytes === String)
                        object.term = "";
                    else {
                        object.term = [];
                        if (options.bytes !== Array)
                            object.term = $util.newBuffer(object.term);
                    }
                    object.weight = 0;
                }
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    object.fieldName = message.fieldName;
                if (message.term != null && message.hasOwnProperty("term"))
                    object.term = options.bytes === String ? $util.base64.encode(message.term, 0, message.term.length) : options.bytes === Array ? Array.prototype.slice.call(message.term) : message.term;
                if (message.weight != null && message.hasOwnProperty("weight"))
                    object.weight = options.json && !isFinite(message.weight) ? String(message.weight) : message.weight;
                return object;
            };

            /**
             * Converts this TermQuery to JSON.
             * @function toJSON
             * @memberof search.proto.TermQuery
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TermQuery.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TermQuery;
        })();

        proto.TermsQuery = (function() {

            /**
             * Properties of a TermsQuery.
             * @memberof search.proto
             * @interface ITermsQuery
             * @property {string|null} [fieldName] TermsQuery fieldName
             * @property {Array.<Uint8Array>|null} [terms] TermsQuery terms
             * @property {number|null} [weight] TermsQuery weight
             */

            /**
             * Constructs a new TermsQuery.
             * @memberof search.proto
             * @classdesc Represents a TermsQuery.
             * @implements ITermsQuery
             * @constructor
             * @param {search.proto.ITermsQuery=} [properties] Properties to set
             */
            function TermsQuery(properties) {
                this.terms = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TermsQuery fieldName.
             * @member {string} fieldName
             * @memberof search.proto.TermsQuery
             * @instance
             */
            TermsQuery.prototype.fieldName = "";

            /**
             * TermsQuery terms.
             * @member {Array.<Uint8Array>} terms
             * @memberof search.proto.TermsQuery
             * @instance
             */
            TermsQuery.prototype.terms = $util.emptyArray;

            /**
             * TermsQuery weight.
             * @member {number} weight
             * @memberof search.proto.TermsQuery
             * @instance
             */
            TermsQuery.prototype.weight = 0;

            /**
             * Creates a new TermsQuery instance using the specified properties.
             * @function create
             * @memberof search.proto.TermsQuery
             * @static
             * @param {search.proto.ITermsQuery=} [properties] Properties to set
             * @returns {search.proto.TermsQuery} TermsQuery instance
             */
            TermsQuery.create = function create(properties) {
                return new TermsQuery(properties);
            };

            /**
             * Encodes the specified TermsQuery message. Does not implicitly {@link search.proto.TermsQuery.verify|verify} messages.
             * @function encode
             * @memberof search.proto.TermsQuery
             * @static
             * @param {search.proto.ITermsQuery} message TermsQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TermsQuery.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fieldName != null && Object.hasOwnProperty.call(message, "fieldName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fieldName);
                if (message.terms != null && message.terms.length)
                    for (var i = 0; i < message.terms.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.terms[i]);
                if (message.weight != null && Object.hasOwnProperty.call(message, "weight"))
                    writer.uint32(/* id 3, wireType 5 =*/29).float(message.weight);
                return writer;
            };

            /**
             * Encodes the specified TermsQuery message, length delimited. Does not implicitly {@link search.proto.TermsQuery.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.TermsQuery
             * @static
             * @param {search.proto.ITermsQuery} message TermsQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TermsQuery.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TermsQuery message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.TermsQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.TermsQuery} TermsQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TermsQuery.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.TermsQuery();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fieldName = reader.string();
                        break;
                    case 2:
                        if (!(message.terms && message.terms.length))
                            message.terms = [];
                        message.terms.push(reader.bytes());
                        break;
                    case 3:
                        message.weight = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TermsQuery message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.TermsQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.TermsQuery} TermsQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TermsQuery.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TermsQuery message.
             * @function verify
             * @memberof search.proto.TermsQuery
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TermsQuery.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    if (!$util.isString(message.fieldName))
                        return "fieldName: string expected";
                if (message.terms != null && message.hasOwnProperty("terms")) {
                    if (!Array.isArray(message.terms))
                        return "terms: array expected";
                    for (var i = 0; i < message.terms.length; ++i)
                        if (!(message.terms[i] && typeof message.terms[i].length === "number" || $util.isString(message.terms[i])))
                            return "terms: buffer[] expected";
                }
                if (message.weight != null && message.hasOwnProperty("weight"))
                    if (typeof message.weight !== "number")
                        return "weight: number expected";
                return null;
            };

            /**
             * Creates a TermsQuery message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.TermsQuery
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.TermsQuery} TermsQuery
             */
            TermsQuery.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.TermsQuery)
                    return object;
                var message = new $root.search.proto.TermsQuery();
                if (object.fieldName != null)
                    message.fieldName = String(object.fieldName);
                if (object.terms) {
                    if (!Array.isArray(object.terms))
                        throw TypeError(".search.proto.TermsQuery.terms: array expected");
                    message.terms = [];
                    for (var i = 0; i < object.terms.length; ++i)
                        if (typeof object.terms[i] === "string")
                            $util.base64.decode(object.terms[i], message.terms[i] = $util.newBuffer($util.base64.length(object.terms[i])), 0);
                        else if (object.terms[i].length)
                            message.terms[i] = object.terms[i];
                }
                if (object.weight != null)
                    message.weight = Number(object.weight);
                return message;
            };

            /**
             * Creates a plain object from a TermsQuery message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.TermsQuery
             * @static
             * @param {search.proto.TermsQuery} message TermsQuery
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TermsQuery.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.terms = [];
                if (options.defaults) {
                    object.fieldName = "";
                    object.weight = 0;
                }
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    object.fieldName = message.fieldName;
                if (message.terms && message.terms.length) {
                    object.terms = [];
                    for (var j = 0; j < message.terms.length; ++j)
                        object.terms[j] = options.bytes === String ? $util.base64.encode(message.terms[j], 0, message.terms[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.terms[j]) : message.terms[j];
                }
                if (message.weight != null && message.hasOwnProperty("weight"))
                    object.weight = options.json && !isFinite(message.weight) ? String(message.weight) : message.weight;
                return object;
            };

            /**
             * Converts this TermsQuery to JSON.
             * @function toJSON
             * @memberof search.proto.TermsQuery
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TermsQuery.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TermsQuery;
        })();

        proto.RangeQuery = (function() {

            /**
             * Properties of a RangeQuery.
             * @memberof search.proto
             * @interface IRangeQuery
             * @property {string|null} [fieldName] RangeQuery fieldName
             * @property {Uint8Array|null} [rangeFrom] RangeQuery rangeFrom
             * @property {Uint8Array|null} [rangeTo] RangeQuery rangeTo
             * @property {boolean|null} [includeLower] RangeQuery includeLower
             * @property {boolean|null} [includeUpper] RangeQuery includeUpper
             */

            /**
             * Constructs a new RangeQuery.
             * @memberof search.proto
             * @classdesc Represents a RangeQuery.
             * @implements IRangeQuery
             * @constructor
             * @param {search.proto.IRangeQuery=} [properties] Properties to set
             */
            function RangeQuery(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RangeQuery fieldName.
             * @member {string} fieldName
             * @memberof search.proto.RangeQuery
             * @instance
             */
            RangeQuery.prototype.fieldName = "";

            /**
             * RangeQuery rangeFrom.
             * @member {Uint8Array} rangeFrom
             * @memberof search.proto.RangeQuery
             * @instance
             */
            RangeQuery.prototype.rangeFrom = $util.newBuffer([]);

            /**
             * RangeQuery rangeTo.
             * @member {Uint8Array} rangeTo
             * @memberof search.proto.RangeQuery
             * @instance
             */
            RangeQuery.prototype.rangeTo = $util.newBuffer([]);

            /**
             * RangeQuery includeLower.
             * @member {boolean} includeLower
             * @memberof search.proto.RangeQuery
             * @instance
             */
            RangeQuery.prototype.includeLower = false;

            /**
             * RangeQuery includeUpper.
             * @member {boolean} includeUpper
             * @memberof search.proto.RangeQuery
             * @instance
             */
            RangeQuery.prototype.includeUpper = false;

            /**
             * Creates a new RangeQuery instance using the specified properties.
             * @function create
             * @memberof search.proto.RangeQuery
             * @static
             * @param {search.proto.IRangeQuery=} [properties] Properties to set
             * @returns {search.proto.RangeQuery} RangeQuery instance
             */
            RangeQuery.create = function create(properties) {
                return new RangeQuery(properties);
            };

            /**
             * Encodes the specified RangeQuery message. Does not implicitly {@link search.proto.RangeQuery.verify|verify} messages.
             * @function encode
             * @memberof search.proto.RangeQuery
             * @static
             * @param {search.proto.IRangeQuery} message RangeQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RangeQuery.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fieldName != null && Object.hasOwnProperty.call(message, "fieldName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fieldName);
                if (message.rangeFrom != null && Object.hasOwnProperty.call(message, "rangeFrom"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.rangeFrom);
                if (message.rangeTo != null && Object.hasOwnProperty.call(message, "rangeTo"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.rangeTo);
                if (message.includeLower != null && Object.hasOwnProperty.call(message, "includeLower"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.includeLower);
                if (message.includeUpper != null && Object.hasOwnProperty.call(message, "includeUpper"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.includeUpper);
                return writer;
            };

            /**
             * Encodes the specified RangeQuery message, length delimited. Does not implicitly {@link search.proto.RangeQuery.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.RangeQuery
             * @static
             * @param {search.proto.IRangeQuery} message RangeQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RangeQuery.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RangeQuery message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.RangeQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.RangeQuery} RangeQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RangeQuery.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.RangeQuery();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fieldName = reader.string();
                        break;
                    case 2:
                        message.rangeFrom = reader.bytes();
                        break;
                    case 3:
                        message.rangeTo = reader.bytes();
                        break;
                    case 4:
                        message.includeLower = reader.bool();
                        break;
                    case 5:
                        message.includeUpper = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RangeQuery message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.RangeQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.RangeQuery} RangeQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RangeQuery.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RangeQuery message.
             * @function verify
             * @memberof search.proto.RangeQuery
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RangeQuery.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    if (!$util.isString(message.fieldName))
                        return "fieldName: string expected";
                if (message.rangeFrom != null && message.hasOwnProperty("rangeFrom"))
                    if (!(message.rangeFrom && typeof message.rangeFrom.length === "number" || $util.isString(message.rangeFrom)))
                        return "rangeFrom: buffer expected";
                if (message.rangeTo != null && message.hasOwnProperty("rangeTo"))
                    if (!(message.rangeTo && typeof message.rangeTo.length === "number" || $util.isString(message.rangeTo)))
                        return "rangeTo: buffer expected";
                if (message.includeLower != null && message.hasOwnProperty("includeLower"))
                    if (typeof message.includeLower !== "boolean")
                        return "includeLower: boolean expected";
                if (message.includeUpper != null && message.hasOwnProperty("includeUpper"))
                    if (typeof message.includeUpper !== "boolean")
                        return "includeUpper: boolean expected";
                return null;
            };

            /**
             * Creates a RangeQuery message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.RangeQuery
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.RangeQuery} RangeQuery
             */
            RangeQuery.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.RangeQuery)
                    return object;
                var message = new $root.search.proto.RangeQuery();
                if (object.fieldName != null)
                    message.fieldName = String(object.fieldName);
                if (object.rangeFrom != null)
                    if (typeof object.rangeFrom === "string")
                        $util.base64.decode(object.rangeFrom, message.rangeFrom = $util.newBuffer($util.base64.length(object.rangeFrom)), 0);
                    else if (object.rangeFrom.length)
                        message.rangeFrom = object.rangeFrom;
                if (object.rangeTo != null)
                    if (typeof object.rangeTo === "string")
                        $util.base64.decode(object.rangeTo, message.rangeTo = $util.newBuffer($util.base64.length(object.rangeTo)), 0);
                    else if (object.rangeTo.length)
                        message.rangeTo = object.rangeTo;
                if (object.includeLower != null)
                    message.includeLower = Boolean(object.includeLower);
                if (object.includeUpper != null)
                    message.includeUpper = Boolean(object.includeUpper);
                return message;
            };

            /**
             * Creates a plain object from a RangeQuery message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.RangeQuery
             * @static
             * @param {search.proto.RangeQuery} message RangeQuery
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RangeQuery.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.fieldName = "";
                    if (options.bytes === String)
                        object.rangeFrom = "";
                    else {
                        object.rangeFrom = [];
                        if (options.bytes !== Array)
                            object.rangeFrom = $util.newBuffer(object.rangeFrom);
                    }
                    if (options.bytes === String)
                        object.rangeTo = "";
                    else {
                        object.rangeTo = [];
                        if (options.bytes !== Array)
                            object.rangeTo = $util.newBuffer(object.rangeTo);
                    }
                    object.includeLower = false;
                    object.includeUpper = false;
                }
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    object.fieldName = message.fieldName;
                if (message.rangeFrom != null && message.hasOwnProperty("rangeFrom"))
                    object.rangeFrom = options.bytes === String ? $util.base64.encode(message.rangeFrom, 0, message.rangeFrom.length) : options.bytes === Array ? Array.prototype.slice.call(message.rangeFrom) : message.rangeFrom;
                if (message.rangeTo != null && message.hasOwnProperty("rangeTo"))
                    object.rangeTo = options.bytes === String ? $util.base64.encode(message.rangeTo, 0, message.rangeTo.length) : options.bytes === Array ? Array.prototype.slice.call(message.rangeTo) : message.rangeTo;
                if (message.includeLower != null && message.hasOwnProperty("includeLower"))
                    object.includeLower = message.includeLower;
                if (message.includeUpper != null && message.hasOwnProperty("includeUpper"))
                    object.includeUpper = message.includeUpper;
                return object;
            };

            /**
             * Converts this RangeQuery to JSON.
             * @function toJSON
             * @memberof search.proto.RangeQuery
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RangeQuery.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RangeQuery;
        })();

        proto.PrefixQuery = (function() {

            /**
             * Properties of a PrefixQuery.
             * @memberof search.proto
             * @interface IPrefixQuery
             * @property {string|null} [fieldName] PrefixQuery fieldName
             * @property {string|null} [prefix] PrefixQuery prefix
             * @property {number|null} [weight] PrefixQuery weight
             */

            /**
             * Constructs a new PrefixQuery.
             * @memberof search.proto
             * @classdesc Represents a PrefixQuery.
             * @implements IPrefixQuery
             * @constructor
             * @param {search.proto.IPrefixQuery=} [properties] Properties to set
             */
            function PrefixQuery(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PrefixQuery fieldName.
             * @member {string} fieldName
             * @memberof search.proto.PrefixQuery
             * @instance
             */
            PrefixQuery.prototype.fieldName = "";

            /**
             * PrefixQuery prefix.
             * @member {string} prefix
             * @memberof search.proto.PrefixQuery
             * @instance
             */
            PrefixQuery.prototype.prefix = "";

            /**
             * PrefixQuery weight.
             * @member {number} weight
             * @memberof search.proto.PrefixQuery
             * @instance
             */
            PrefixQuery.prototype.weight = 0;

            /**
             * Creates a new PrefixQuery instance using the specified properties.
             * @function create
             * @memberof search.proto.PrefixQuery
             * @static
             * @param {search.proto.IPrefixQuery=} [properties] Properties to set
             * @returns {search.proto.PrefixQuery} PrefixQuery instance
             */
            PrefixQuery.create = function create(properties) {
                return new PrefixQuery(properties);
            };

            /**
             * Encodes the specified PrefixQuery message. Does not implicitly {@link search.proto.PrefixQuery.verify|verify} messages.
             * @function encode
             * @memberof search.proto.PrefixQuery
             * @static
             * @param {search.proto.IPrefixQuery} message PrefixQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PrefixQuery.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fieldName != null && Object.hasOwnProperty.call(message, "fieldName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fieldName);
                if (message.prefix != null && Object.hasOwnProperty.call(message, "prefix"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.prefix);
                if (message.weight != null && Object.hasOwnProperty.call(message, "weight"))
                    writer.uint32(/* id 3, wireType 5 =*/29).float(message.weight);
                return writer;
            };

            /**
             * Encodes the specified PrefixQuery message, length delimited. Does not implicitly {@link search.proto.PrefixQuery.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.PrefixQuery
             * @static
             * @param {search.proto.IPrefixQuery} message PrefixQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PrefixQuery.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PrefixQuery message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.PrefixQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.PrefixQuery} PrefixQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PrefixQuery.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.PrefixQuery();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fieldName = reader.string();
                        break;
                    case 2:
                        message.prefix = reader.string();
                        break;
                    case 3:
                        message.weight = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PrefixQuery message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.PrefixQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.PrefixQuery} PrefixQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PrefixQuery.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PrefixQuery message.
             * @function verify
             * @memberof search.proto.PrefixQuery
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PrefixQuery.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    if (!$util.isString(message.fieldName))
                        return "fieldName: string expected";
                if (message.prefix != null && message.hasOwnProperty("prefix"))
                    if (!$util.isString(message.prefix))
                        return "prefix: string expected";
                if (message.weight != null && message.hasOwnProperty("weight"))
                    if (typeof message.weight !== "number")
                        return "weight: number expected";
                return null;
            };

            /**
             * Creates a PrefixQuery message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.PrefixQuery
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.PrefixQuery} PrefixQuery
             */
            PrefixQuery.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.PrefixQuery)
                    return object;
                var message = new $root.search.proto.PrefixQuery();
                if (object.fieldName != null)
                    message.fieldName = String(object.fieldName);
                if (object.prefix != null)
                    message.prefix = String(object.prefix);
                if (object.weight != null)
                    message.weight = Number(object.weight);
                return message;
            };

            /**
             * Creates a plain object from a PrefixQuery message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.PrefixQuery
             * @static
             * @param {search.proto.PrefixQuery} message PrefixQuery
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PrefixQuery.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.fieldName = "";
                    object.prefix = "";
                    object.weight = 0;
                }
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    object.fieldName = message.fieldName;
                if (message.prefix != null && message.hasOwnProperty("prefix"))
                    object.prefix = message.prefix;
                if (message.weight != null && message.hasOwnProperty("weight"))
                    object.weight = options.json && !isFinite(message.weight) ? String(message.weight) : message.weight;
                return object;
            };

            /**
             * Converts this PrefixQuery to JSON.
             * @function toJSON
             * @memberof search.proto.PrefixQuery
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PrefixQuery.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PrefixQuery;
        })();

        proto.WildcardQuery = (function() {

            /**
             * Properties of a WildcardQuery.
             * @memberof search.proto
             * @interface IWildcardQuery
             * @property {string|null} [fieldName] WildcardQuery fieldName
             * @property {string|null} [value] WildcardQuery value
             * @property {number|null} [weight] WildcardQuery weight
             */

            /**
             * Constructs a new WildcardQuery.
             * @memberof search.proto
             * @classdesc Represents a WildcardQuery.
             * @implements IWildcardQuery
             * @constructor
             * @param {search.proto.IWildcardQuery=} [properties] Properties to set
             */
            function WildcardQuery(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WildcardQuery fieldName.
             * @member {string} fieldName
             * @memberof search.proto.WildcardQuery
             * @instance
             */
            WildcardQuery.prototype.fieldName = "";

            /**
             * WildcardQuery value.
             * @member {string} value
             * @memberof search.proto.WildcardQuery
             * @instance
             */
            WildcardQuery.prototype.value = "";

            /**
             * WildcardQuery weight.
             * @member {number} weight
             * @memberof search.proto.WildcardQuery
             * @instance
             */
            WildcardQuery.prototype.weight = 0;

            /**
             * Creates a new WildcardQuery instance using the specified properties.
             * @function create
             * @memberof search.proto.WildcardQuery
             * @static
             * @param {search.proto.IWildcardQuery=} [properties] Properties to set
             * @returns {search.proto.WildcardQuery} WildcardQuery instance
             */
            WildcardQuery.create = function create(properties) {
                return new WildcardQuery(properties);
            };

            /**
             * Encodes the specified WildcardQuery message. Does not implicitly {@link search.proto.WildcardQuery.verify|verify} messages.
             * @function encode
             * @memberof search.proto.WildcardQuery
             * @static
             * @param {search.proto.IWildcardQuery} message WildcardQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WildcardQuery.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fieldName != null && Object.hasOwnProperty.call(message, "fieldName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fieldName);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
                if (message.weight != null && Object.hasOwnProperty.call(message, "weight"))
                    writer.uint32(/* id 3, wireType 5 =*/29).float(message.weight);
                return writer;
            };

            /**
             * Encodes the specified WildcardQuery message, length delimited. Does not implicitly {@link search.proto.WildcardQuery.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.WildcardQuery
             * @static
             * @param {search.proto.IWildcardQuery} message WildcardQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WildcardQuery.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WildcardQuery message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.WildcardQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.WildcardQuery} WildcardQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WildcardQuery.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.WildcardQuery();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fieldName = reader.string();
                        break;
                    case 2:
                        message.value = reader.string();
                        break;
                    case 3:
                        message.weight = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WildcardQuery message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.WildcardQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.WildcardQuery} WildcardQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WildcardQuery.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WildcardQuery message.
             * @function verify
             * @memberof search.proto.WildcardQuery
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WildcardQuery.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    if (!$util.isString(message.fieldName))
                        return "fieldName: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isString(message.value))
                        return "value: string expected";
                if (message.weight != null && message.hasOwnProperty("weight"))
                    if (typeof message.weight !== "number")
                        return "weight: number expected";
                return null;
            };

            /**
             * Creates a WildcardQuery message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.WildcardQuery
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.WildcardQuery} WildcardQuery
             */
            WildcardQuery.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.WildcardQuery)
                    return object;
                var message = new $root.search.proto.WildcardQuery();
                if (object.fieldName != null)
                    message.fieldName = String(object.fieldName);
                if (object.value != null)
                    message.value = String(object.value);
                if (object.weight != null)
                    message.weight = Number(object.weight);
                return message;
            };

            /**
             * Creates a plain object from a WildcardQuery message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.WildcardQuery
             * @static
             * @param {search.proto.WildcardQuery} message WildcardQuery
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WildcardQuery.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.fieldName = "";
                    object.value = "";
                    object.weight = 0;
                }
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    object.fieldName = message.fieldName;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                if (message.weight != null && message.hasOwnProperty("weight"))
                    object.weight = options.json && !isFinite(message.weight) ? String(message.weight) : message.weight;
                return object;
            };

            /**
             * Converts this WildcardQuery to JSON.
             * @function toJSON
             * @memberof search.proto.WildcardQuery
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WildcardQuery.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WildcardQuery;
        })();

        proto.BoolQuery = (function() {

            /**
             * Properties of a BoolQuery.
             * @memberof search.proto
             * @interface IBoolQuery
             * @property {Array.<search.proto.IQuery>|null} [mustQueries] BoolQuery mustQueries
             * @property {Array.<search.proto.IQuery>|null} [mustNotQueries] BoolQuery mustNotQueries
             * @property {Array.<search.proto.IQuery>|null} [filterQueries] BoolQuery filterQueries
             * @property {Array.<search.proto.IQuery>|null} [shouldQueries] BoolQuery shouldQueries
             * @property {number|null} [minimumShouldMatch] BoolQuery minimumShouldMatch
             */

            /**
             * Constructs a new BoolQuery.
             * @memberof search.proto
             * @classdesc Represents a BoolQuery.
             * @implements IBoolQuery
             * @constructor
             * @param {search.proto.IBoolQuery=} [properties] Properties to set
             */
            function BoolQuery(properties) {
                this.mustQueries = [];
                this.mustNotQueries = [];
                this.filterQueries = [];
                this.shouldQueries = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BoolQuery mustQueries.
             * @member {Array.<search.proto.IQuery>} mustQueries
             * @memberof search.proto.BoolQuery
             * @instance
             */
            BoolQuery.prototype.mustQueries = $util.emptyArray;

            /**
             * BoolQuery mustNotQueries.
             * @member {Array.<search.proto.IQuery>} mustNotQueries
             * @memberof search.proto.BoolQuery
             * @instance
             */
            BoolQuery.prototype.mustNotQueries = $util.emptyArray;

            /**
             * BoolQuery filterQueries.
             * @member {Array.<search.proto.IQuery>} filterQueries
             * @memberof search.proto.BoolQuery
             * @instance
             */
            BoolQuery.prototype.filterQueries = $util.emptyArray;

            /**
             * BoolQuery shouldQueries.
             * @member {Array.<search.proto.IQuery>} shouldQueries
             * @memberof search.proto.BoolQuery
             * @instance
             */
            BoolQuery.prototype.shouldQueries = $util.emptyArray;

            /**
             * BoolQuery minimumShouldMatch.
             * @member {number} minimumShouldMatch
             * @memberof search.proto.BoolQuery
             * @instance
             */
            BoolQuery.prototype.minimumShouldMatch = 0;

            /**
             * Creates a new BoolQuery instance using the specified properties.
             * @function create
             * @memberof search.proto.BoolQuery
             * @static
             * @param {search.proto.IBoolQuery=} [properties] Properties to set
             * @returns {search.proto.BoolQuery} BoolQuery instance
             */
            BoolQuery.create = function create(properties) {
                return new BoolQuery(properties);
            };

            /**
             * Encodes the specified BoolQuery message. Does not implicitly {@link search.proto.BoolQuery.verify|verify} messages.
             * @function encode
             * @memberof search.proto.BoolQuery
             * @static
             * @param {search.proto.IBoolQuery} message BoolQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BoolQuery.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.mustQueries != null && message.mustQueries.length)
                    for (var i = 0; i < message.mustQueries.length; ++i)
                        $root.search.proto.Query.encode(message.mustQueries[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.mustNotQueries != null && message.mustNotQueries.length)
                    for (var i = 0; i < message.mustNotQueries.length; ++i)
                        $root.search.proto.Query.encode(message.mustNotQueries[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.filterQueries != null && message.filterQueries.length)
                    for (var i = 0; i < message.filterQueries.length; ++i)
                        $root.search.proto.Query.encode(message.filterQueries[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.shouldQueries != null && message.shouldQueries.length)
                    for (var i = 0; i < message.shouldQueries.length; ++i)
                        $root.search.proto.Query.encode(message.shouldQueries[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.minimumShouldMatch != null && Object.hasOwnProperty.call(message, "minimumShouldMatch"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.minimumShouldMatch);
                return writer;
            };

            /**
             * Encodes the specified BoolQuery message, length delimited. Does not implicitly {@link search.proto.BoolQuery.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.BoolQuery
             * @static
             * @param {search.proto.IBoolQuery} message BoolQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BoolQuery.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BoolQuery message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.BoolQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.BoolQuery} BoolQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BoolQuery.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.BoolQuery();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.mustQueries && message.mustQueries.length))
                            message.mustQueries = [];
                        message.mustQueries.push($root.search.proto.Query.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        if (!(message.mustNotQueries && message.mustNotQueries.length))
                            message.mustNotQueries = [];
                        message.mustNotQueries.push($root.search.proto.Query.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.filterQueries && message.filterQueries.length))
                            message.filterQueries = [];
                        message.filterQueries.push($root.search.proto.Query.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.shouldQueries && message.shouldQueries.length))
                            message.shouldQueries = [];
                        message.shouldQueries.push($root.search.proto.Query.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        message.minimumShouldMatch = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BoolQuery message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.BoolQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.BoolQuery} BoolQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BoolQuery.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BoolQuery message.
             * @function verify
             * @memberof search.proto.BoolQuery
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BoolQuery.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.mustQueries != null && message.hasOwnProperty("mustQueries")) {
                    if (!Array.isArray(message.mustQueries))
                        return "mustQueries: array expected";
                    for (var i = 0; i < message.mustQueries.length; ++i) {
                        var error = $root.search.proto.Query.verify(message.mustQueries[i]);
                        if (error)
                            return "mustQueries." + error;
                    }
                }
                if (message.mustNotQueries != null && message.hasOwnProperty("mustNotQueries")) {
                    if (!Array.isArray(message.mustNotQueries))
                        return "mustNotQueries: array expected";
                    for (var i = 0; i < message.mustNotQueries.length; ++i) {
                        var error = $root.search.proto.Query.verify(message.mustNotQueries[i]);
                        if (error)
                            return "mustNotQueries." + error;
                    }
                }
                if (message.filterQueries != null && message.hasOwnProperty("filterQueries")) {
                    if (!Array.isArray(message.filterQueries))
                        return "filterQueries: array expected";
                    for (var i = 0; i < message.filterQueries.length; ++i) {
                        var error = $root.search.proto.Query.verify(message.filterQueries[i]);
                        if (error)
                            return "filterQueries." + error;
                    }
                }
                if (message.shouldQueries != null && message.hasOwnProperty("shouldQueries")) {
                    if (!Array.isArray(message.shouldQueries))
                        return "shouldQueries: array expected";
                    for (var i = 0; i < message.shouldQueries.length; ++i) {
                        var error = $root.search.proto.Query.verify(message.shouldQueries[i]);
                        if (error)
                            return "shouldQueries." + error;
                    }
                }
                if (message.minimumShouldMatch != null && message.hasOwnProperty("minimumShouldMatch"))
                    if (!$util.isInteger(message.minimumShouldMatch))
                        return "minimumShouldMatch: integer expected";
                return null;
            };

            /**
             * Creates a BoolQuery message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.BoolQuery
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.BoolQuery} BoolQuery
             */
            BoolQuery.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.BoolQuery)
                    return object;
                var message = new $root.search.proto.BoolQuery();
                if (object.mustQueries) {
                    if (!Array.isArray(object.mustQueries))
                        throw TypeError(".search.proto.BoolQuery.mustQueries: array expected");
                    message.mustQueries = [];
                    for (var i = 0; i < object.mustQueries.length; ++i) {
                        if (typeof object.mustQueries[i] !== "object")
                            throw TypeError(".search.proto.BoolQuery.mustQueries: object expected");
                        message.mustQueries[i] = $root.search.proto.Query.fromObject(object.mustQueries[i]);
                    }
                }
                if (object.mustNotQueries) {
                    if (!Array.isArray(object.mustNotQueries))
                        throw TypeError(".search.proto.BoolQuery.mustNotQueries: array expected");
                    message.mustNotQueries = [];
                    for (var i = 0; i < object.mustNotQueries.length; ++i) {
                        if (typeof object.mustNotQueries[i] !== "object")
                            throw TypeError(".search.proto.BoolQuery.mustNotQueries: object expected");
                        message.mustNotQueries[i] = $root.search.proto.Query.fromObject(object.mustNotQueries[i]);
                    }
                }
                if (object.filterQueries) {
                    if (!Array.isArray(object.filterQueries))
                        throw TypeError(".search.proto.BoolQuery.filterQueries: array expected");
                    message.filterQueries = [];
                    for (var i = 0; i < object.filterQueries.length; ++i) {
                        if (typeof object.filterQueries[i] !== "object")
                            throw TypeError(".search.proto.BoolQuery.filterQueries: object expected");
                        message.filterQueries[i] = $root.search.proto.Query.fromObject(object.filterQueries[i]);
                    }
                }
                if (object.shouldQueries) {
                    if (!Array.isArray(object.shouldQueries))
                        throw TypeError(".search.proto.BoolQuery.shouldQueries: array expected");
                    message.shouldQueries = [];
                    for (var i = 0; i < object.shouldQueries.length; ++i) {
                        if (typeof object.shouldQueries[i] !== "object")
                            throw TypeError(".search.proto.BoolQuery.shouldQueries: object expected");
                        message.shouldQueries[i] = $root.search.proto.Query.fromObject(object.shouldQueries[i]);
                    }
                }
                if (object.minimumShouldMatch != null)
                    message.minimumShouldMatch = object.minimumShouldMatch | 0;
                return message;
            };

            /**
             * Creates a plain object from a BoolQuery message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.BoolQuery
             * @static
             * @param {search.proto.BoolQuery} message BoolQuery
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BoolQuery.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.mustQueries = [];
                    object.mustNotQueries = [];
                    object.filterQueries = [];
                    object.shouldQueries = [];
                }
                if (options.defaults)
                    object.minimumShouldMatch = 0;
                if (message.mustQueries && message.mustQueries.length) {
                    object.mustQueries = [];
                    for (var j = 0; j < message.mustQueries.length; ++j)
                        object.mustQueries[j] = $root.search.proto.Query.toObject(message.mustQueries[j], options);
                }
                if (message.mustNotQueries && message.mustNotQueries.length) {
                    object.mustNotQueries = [];
                    for (var j = 0; j < message.mustNotQueries.length; ++j)
                        object.mustNotQueries[j] = $root.search.proto.Query.toObject(message.mustNotQueries[j], options);
                }
                if (message.filterQueries && message.filterQueries.length) {
                    object.filterQueries = [];
                    for (var j = 0; j < message.filterQueries.length; ++j)
                        object.filterQueries[j] = $root.search.proto.Query.toObject(message.filterQueries[j], options);
                }
                if (message.shouldQueries && message.shouldQueries.length) {
                    object.shouldQueries = [];
                    for (var j = 0; j < message.shouldQueries.length; ++j)
                        object.shouldQueries[j] = $root.search.proto.Query.toObject(message.shouldQueries[j], options);
                }
                if (message.minimumShouldMatch != null && message.hasOwnProperty("minimumShouldMatch"))
                    object.minimumShouldMatch = message.minimumShouldMatch;
                return object;
            };

            /**
             * Converts this BoolQuery to JSON.
             * @function toJSON
             * @memberof search.proto.BoolQuery
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BoolQuery.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BoolQuery;
        })();

        proto.ConstScoreQuery = (function() {

            /**
             * Properties of a ConstScoreQuery.
             * @memberof search.proto
             * @interface IConstScoreQuery
             * @property {search.proto.IQuery|null} [filter] ConstScoreQuery filter
             */

            /**
             * Constructs a new ConstScoreQuery.
             * @memberof search.proto
             * @classdesc Represents a ConstScoreQuery.
             * @implements IConstScoreQuery
             * @constructor
             * @param {search.proto.IConstScoreQuery=} [properties] Properties to set
             */
            function ConstScoreQuery(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ConstScoreQuery filter.
             * @member {search.proto.IQuery|null|undefined} filter
             * @memberof search.proto.ConstScoreQuery
             * @instance
             */
            ConstScoreQuery.prototype.filter = null;

            /**
             * Creates a new ConstScoreQuery instance using the specified properties.
             * @function create
             * @memberof search.proto.ConstScoreQuery
             * @static
             * @param {search.proto.IConstScoreQuery=} [properties] Properties to set
             * @returns {search.proto.ConstScoreQuery} ConstScoreQuery instance
             */
            ConstScoreQuery.create = function create(properties) {
                return new ConstScoreQuery(properties);
            };

            /**
             * Encodes the specified ConstScoreQuery message. Does not implicitly {@link search.proto.ConstScoreQuery.verify|verify} messages.
             * @function encode
             * @memberof search.proto.ConstScoreQuery
             * @static
             * @param {search.proto.IConstScoreQuery} message ConstScoreQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConstScoreQuery.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.filter != null && Object.hasOwnProperty.call(message, "filter"))
                    $root.search.proto.Query.encode(message.filter, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ConstScoreQuery message, length delimited. Does not implicitly {@link search.proto.ConstScoreQuery.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.ConstScoreQuery
             * @static
             * @param {search.proto.IConstScoreQuery} message ConstScoreQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConstScoreQuery.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ConstScoreQuery message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.ConstScoreQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.ConstScoreQuery} ConstScoreQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConstScoreQuery.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.ConstScoreQuery();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.filter = $root.search.proto.Query.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ConstScoreQuery message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.ConstScoreQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.ConstScoreQuery} ConstScoreQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConstScoreQuery.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ConstScoreQuery message.
             * @function verify
             * @memberof search.proto.ConstScoreQuery
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConstScoreQuery.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.filter != null && message.hasOwnProperty("filter")) {
                    var error = $root.search.proto.Query.verify(message.filter);
                    if (error)
                        return "filter." + error;
                }
                return null;
            };

            /**
             * Creates a ConstScoreQuery message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.ConstScoreQuery
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.ConstScoreQuery} ConstScoreQuery
             */
            ConstScoreQuery.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.ConstScoreQuery)
                    return object;
                var message = new $root.search.proto.ConstScoreQuery();
                if (object.filter != null) {
                    if (typeof object.filter !== "object")
                        throw TypeError(".search.proto.ConstScoreQuery.filter: object expected");
                    message.filter = $root.search.proto.Query.fromObject(object.filter);
                }
                return message;
            };

            /**
             * Creates a plain object from a ConstScoreQuery message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.ConstScoreQuery
             * @static
             * @param {search.proto.ConstScoreQuery} message ConstScoreQuery
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConstScoreQuery.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.filter = null;
                if (message.filter != null && message.hasOwnProperty("filter"))
                    object.filter = $root.search.proto.Query.toObject(message.filter, options);
                return object;
            };

            /**
             * Converts this ConstScoreQuery to JSON.
             * @function toJSON
             * @memberof search.proto.ConstScoreQuery
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConstScoreQuery.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ConstScoreQuery;
        })();

        proto.FieldValueFactor = (function() {

            /**
             * Properties of a FieldValueFactor.
             * @memberof search.proto
             * @interface IFieldValueFactor
             * @property {string|null} [fieldName] FieldValueFactor fieldName
             */

            /**
             * Constructs a new FieldValueFactor.
             * @memberof search.proto
             * @classdesc Represents a FieldValueFactor.
             * @implements IFieldValueFactor
             * @constructor
             * @param {search.proto.IFieldValueFactor=} [properties] Properties to set
             */
            function FieldValueFactor(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FieldValueFactor fieldName.
             * @member {string} fieldName
             * @memberof search.proto.FieldValueFactor
             * @instance
             */
            FieldValueFactor.prototype.fieldName = "";

            /**
             * Creates a new FieldValueFactor instance using the specified properties.
             * @function create
             * @memberof search.proto.FieldValueFactor
             * @static
             * @param {search.proto.IFieldValueFactor=} [properties] Properties to set
             * @returns {search.proto.FieldValueFactor} FieldValueFactor instance
             */
            FieldValueFactor.create = function create(properties) {
                return new FieldValueFactor(properties);
            };

            /**
             * Encodes the specified FieldValueFactor message. Does not implicitly {@link search.proto.FieldValueFactor.verify|verify} messages.
             * @function encode
             * @memberof search.proto.FieldValueFactor
             * @static
             * @param {search.proto.IFieldValueFactor} message FieldValueFactor message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldValueFactor.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fieldName != null && Object.hasOwnProperty.call(message, "fieldName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fieldName);
                return writer;
            };

            /**
             * Encodes the specified FieldValueFactor message, length delimited. Does not implicitly {@link search.proto.FieldValueFactor.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.FieldValueFactor
             * @static
             * @param {search.proto.IFieldValueFactor} message FieldValueFactor message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldValueFactor.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FieldValueFactor message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.FieldValueFactor
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.FieldValueFactor} FieldValueFactor
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldValueFactor.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.FieldValueFactor();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fieldName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FieldValueFactor message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.FieldValueFactor
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.FieldValueFactor} FieldValueFactor
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldValueFactor.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FieldValueFactor message.
             * @function verify
             * @memberof search.proto.FieldValueFactor
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FieldValueFactor.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    if (!$util.isString(message.fieldName))
                        return "fieldName: string expected";
                return null;
            };

            /**
             * Creates a FieldValueFactor message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.FieldValueFactor
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.FieldValueFactor} FieldValueFactor
             */
            FieldValueFactor.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.FieldValueFactor)
                    return object;
                var message = new $root.search.proto.FieldValueFactor();
                if (object.fieldName != null)
                    message.fieldName = String(object.fieldName);
                return message;
            };

            /**
             * Creates a plain object from a FieldValueFactor message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.FieldValueFactor
             * @static
             * @param {search.proto.FieldValueFactor} message FieldValueFactor
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FieldValueFactor.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.fieldName = "";
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    object.fieldName = message.fieldName;
                return object;
            };

            /**
             * Converts this FieldValueFactor to JSON.
             * @function toJSON
             * @memberof search.proto.FieldValueFactor
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FieldValueFactor.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FieldValueFactor;
        })();

        proto.FunctionScoreQuery = (function() {

            /**
             * Properties of a FunctionScoreQuery.
             * @memberof search.proto
             * @interface IFunctionScoreQuery
             * @property {search.proto.IQuery|null} [query] FunctionScoreQuery query
             * @property {search.proto.IFieldValueFactor|null} [fieldValueFactor] FunctionScoreQuery fieldValueFactor
             */

            /**
             * Constructs a new FunctionScoreQuery.
             * @memberof search.proto
             * @classdesc Represents a FunctionScoreQuery.
             * @implements IFunctionScoreQuery
             * @constructor
             * @param {search.proto.IFunctionScoreQuery=} [properties] Properties to set
             */
            function FunctionScoreQuery(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FunctionScoreQuery query.
             * @member {search.proto.IQuery|null|undefined} query
             * @memberof search.proto.FunctionScoreQuery
             * @instance
             */
            FunctionScoreQuery.prototype.query = null;

            /**
             * FunctionScoreQuery fieldValueFactor.
             * @member {search.proto.IFieldValueFactor|null|undefined} fieldValueFactor
             * @memberof search.proto.FunctionScoreQuery
             * @instance
             */
            FunctionScoreQuery.prototype.fieldValueFactor = null;

            /**
             * Creates a new FunctionScoreQuery instance using the specified properties.
             * @function create
             * @memberof search.proto.FunctionScoreQuery
             * @static
             * @param {search.proto.IFunctionScoreQuery=} [properties] Properties to set
             * @returns {search.proto.FunctionScoreQuery} FunctionScoreQuery instance
             */
            FunctionScoreQuery.create = function create(properties) {
                return new FunctionScoreQuery(properties);
            };

            /**
             * Encodes the specified FunctionScoreQuery message. Does not implicitly {@link search.proto.FunctionScoreQuery.verify|verify} messages.
             * @function encode
             * @memberof search.proto.FunctionScoreQuery
             * @static
             * @param {search.proto.IFunctionScoreQuery} message FunctionScoreQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FunctionScoreQuery.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.query != null && Object.hasOwnProperty.call(message, "query"))
                    $root.search.proto.Query.encode(message.query, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.fieldValueFactor != null && Object.hasOwnProperty.call(message, "fieldValueFactor"))
                    $root.search.proto.FieldValueFactor.encode(message.fieldValueFactor, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified FunctionScoreQuery message, length delimited. Does not implicitly {@link search.proto.FunctionScoreQuery.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.FunctionScoreQuery
             * @static
             * @param {search.proto.IFunctionScoreQuery} message FunctionScoreQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FunctionScoreQuery.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FunctionScoreQuery message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.FunctionScoreQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.FunctionScoreQuery} FunctionScoreQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FunctionScoreQuery.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.FunctionScoreQuery();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.query = $root.search.proto.Query.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.fieldValueFactor = $root.search.proto.FieldValueFactor.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FunctionScoreQuery message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.FunctionScoreQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.FunctionScoreQuery} FunctionScoreQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FunctionScoreQuery.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FunctionScoreQuery message.
             * @function verify
             * @memberof search.proto.FunctionScoreQuery
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FunctionScoreQuery.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.query != null && message.hasOwnProperty("query")) {
                    var error = $root.search.proto.Query.verify(message.query);
                    if (error)
                        return "query." + error;
                }
                if (message.fieldValueFactor != null && message.hasOwnProperty("fieldValueFactor")) {
                    var error = $root.search.proto.FieldValueFactor.verify(message.fieldValueFactor);
                    if (error)
                        return "fieldValueFactor." + error;
                }
                return null;
            };

            /**
             * Creates a FunctionScoreQuery message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.FunctionScoreQuery
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.FunctionScoreQuery} FunctionScoreQuery
             */
            FunctionScoreQuery.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.FunctionScoreQuery)
                    return object;
                var message = new $root.search.proto.FunctionScoreQuery();
                if (object.query != null) {
                    if (typeof object.query !== "object")
                        throw TypeError(".search.proto.FunctionScoreQuery.query: object expected");
                    message.query = $root.search.proto.Query.fromObject(object.query);
                }
                if (object.fieldValueFactor != null) {
                    if (typeof object.fieldValueFactor !== "object")
                        throw TypeError(".search.proto.FunctionScoreQuery.fieldValueFactor: object expected");
                    message.fieldValueFactor = $root.search.proto.FieldValueFactor.fromObject(object.fieldValueFactor);
                }
                return message;
            };

            /**
             * Creates a plain object from a FunctionScoreQuery message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.FunctionScoreQuery
             * @static
             * @param {search.proto.FunctionScoreQuery} message FunctionScoreQuery
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FunctionScoreQuery.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.query = null;
                    object.fieldValueFactor = null;
                }
                if (message.query != null && message.hasOwnProperty("query"))
                    object.query = $root.search.proto.Query.toObject(message.query, options);
                if (message.fieldValueFactor != null && message.hasOwnProperty("fieldValueFactor"))
                    object.fieldValueFactor = $root.search.proto.FieldValueFactor.toObject(message.fieldValueFactor, options);
                return object;
            };

            /**
             * Converts this FunctionScoreQuery to JSON.
             * @function toJSON
             * @memberof search.proto.FunctionScoreQuery
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FunctionScoreQuery.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FunctionScoreQuery;
        })();

        proto.FunctionsScoreQuery = (function() {

            /**
             * Properties of a FunctionsScoreQuery.
             * @memberof search.proto
             * @interface IFunctionsScoreQuery
             * @property {search.proto.IQuery|null} [query] FunctionsScoreQuery query
             * @property {Array.<search.proto.IFunction>|null} [functions] FunctionsScoreQuery functions
             * @property {search.proto.FunctionScoreMode|null} [scoreMode] FunctionsScoreQuery scoreMode
             * @property {search.proto.FunctionCombineMode|null} [combineMode] FunctionsScoreQuery combineMode
             * @property {number|null} [minScore] FunctionsScoreQuery minScore
             * @property {number|null} [maxScore] FunctionsScoreQuery maxScore
             */

            /**
             * Constructs a new FunctionsScoreQuery.
             * @memberof search.proto
             * @classdesc Represents a FunctionsScoreQuery.
             * @implements IFunctionsScoreQuery
             * @constructor
             * @param {search.proto.IFunctionsScoreQuery=} [properties] Properties to set
             */
            function FunctionsScoreQuery(properties) {
                this.functions = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FunctionsScoreQuery query.
             * @member {search.proto.IQuery|null|undefined} query
             * @memberof search.proto.FunctionsScoreQuery
             * @instance
             */
            FunctionsScoreQuery.prototype.query = null;

            /**
             * FunctionsScoreQuery functions.
             * @member {Array.<search.proto.IFunction>} functions
             * @memberof search.proto.FunctionsScoreQuery
             * @instance
             */
            FunctionsScoreQuery.prototype.functions = $util.emptyArray;

            /**
             * FunctionsScoreQuery scoreMode.
             * @member {search.proto.FunctionScoreMode} scoreMode
             * @memberof search.proto.FunctionsScoreQuery
             * @instance
             */
            FunctionsScoreQuery.prototype.scoreMode = 1;

            /**
             * FunctionsScoreQuery combineMode.
             * @member {search.proto.FunctionCombineMode} combineMode
             * @memberof search.proto.FunctionsScoreQuery
             * @instance
             */
            FunctionsScoreQuery.prototype.combineMode = 1;

            /**
             * FunctionsScoreQuery minScore.
             * @member {number} minScore
             * @memberof search.proto.FunctionsScoreQuery
             * @instance
             */
            FunctionsScoreQuery.prototype.minScore = 0;

            /**
             * FunctionsScoreQuery maxScore.
             * @member {number} maxScore
             * @memberof search.proto.FunctionsScoreQuery
             * @instance
             */
            FunctionsScoreQuery.prototype.maxScore = 0;

            /**
             * Creates a new FunctionsScoreQuery instance using the specified properties.
             * @function create
             * @memberof search.proto.FunctionsScoreQuery
             * @static
             * @param {search.proto.IFunctionsScoreQuery=} [properties] Properties to set
             * @returns {search.proto.FunctionsScoreQuery} FunctionsScoreQuery instance
             */
            FunctionsScoreQuery.create = function create(properties) {
                return new FunctionsScoreQuery(properties);
            };

            /**
             * Encodes the specified FunctionsScoreQuery message. Does not implicitly {@link search.proto.FunctionsScoreQuery.verify|verify} messages.
             * @function encode
             * @memberof search.proto.FunctionsScoreQuery
             * @static
             * @param {search.proto.IFunctionsScoreQuery} message FunctionsScoreQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FunctionsScoreQuery.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.query != null && Object.hasOwnProperty.call(message, "query"))
                    $root.search.proto.Query.encode(message.query, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.functions != null && message.functions.length)
                    for (var i = 0; i < message.functions.length; ++i)
                        $root.search.proto.Function.encode(message.functions[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.scoreMode != null && Object.hasOwnProperty.call(message, "scoreMode"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.scoreMode);
                if (message.combineMode != null && Object.hasOwnProperty.call(message, "combineMode"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.combineMode);
                if (message.minScore != null && Object.hasOwnProperty.call(message, "minScore"))
                    writer.uint32(/* id 5, wireType 5 =*/45).float(message.minScore);
                if (message.maxScore != null && Object.hasOwnProperty.call(message, "maxScore"))
                    writer.uint32(/* id 6, wireType 5 =*/53).float(message.maxScore);
                return writer;
            };

            /**
             * Encodes the specified FunctionsScoreQuery message, length delimited. Does not implicitly {@link search.proto.FunctionsScoreQuery.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.FunctionsScoreQuery
             * @static
             * @param {search.proto.IFunctionsScoreQuery} message FunctionsScoreQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FunctionsScoreQuery.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FunctionsScoreQuery message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.FunctionsScoreQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.FunctionsScoreQuery} FunctionsScoreQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FunctionsScoreQuery.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.FunctionsScoreQuery();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.query = $root.search.proto.Query.decode(reader, reader.uint32());
                        break;
                    case 2:
                        if (!(message.functions && message.functions.length))
                            message.functions = [];
                        message.functions.push($root.search.proto.Function.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.scoreMode = reader.int32();
                        break;
                    case 4:
                        message.combineMode = reader.int32();
                        break;
                    case 5:
                        message.minScore = reader.float();
                        break;
                    case 6:
                        message.maxScore = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FunctionsScoreQuery message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.FunctionsScoreQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.FunctionsScoreQuery} FunctionsScoreQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FunctionsScoreQuery.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FunctionsScoreQuery message.
             * @function verify
             * @memberof search.proto.FunctionsScoreQuery
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FunctionsScoreQuery.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.query != null && message.hasOwnProperty("query")) {
                    var error = $root.search.proto.Query.verify(message.query);
                    if (error)
                        return "query." + error;
                }
                if (message.functions != null && message.hasOwnProperty("functions")) {
                    if (!Array.isArray(message.functions))
                        return "functions: array expected";
                    for (var i = 0; i < message.functions.length; ++i) {
                        var error = $root.search.proto.Function.verify(message.functions[i]);
                        if (error)
                            return "functions." + error;
                    }
                }
                if (message.scoreMode != null && message.hasOwnProperty("scoreMode"))
                    switch (message.scoreMode) {
                    default:
                        return "scoreMode: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                        break;
                    }
                if (message.combineMode != null && message.hasOwnProperty("combineMode"))
                    switch (message.combineMode) {
                    default:
                        return "combineMode: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                        break;
                    }
                if (message.minScore != null && message.hasOwnProperty("minScore"))
                    if (typeof message.minScore !== "number")
                        return "minScore: number expected";
                if (message.maxScore != null && message.hasOwnProperty("maxScore"))
                    if (typeof message.maxScore !== "number")
                        return "maxScore: number expected";
                return null;
            };

            /**
             * Creates a FunctionsScoreQuery message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.FunctionsScoreQuery
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.FunctionsScoreQuery} FunctionsScoreQuery
             */
            FunctionsScoreQuery.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.FunctionsScoreQuery)
                    return object;
                var message = new $root.search.proto.FunctionsScoreQuery();
                if (object.query != null) {
                    if (typeof object.query !== "object")
                        throw TypeError(".search.proto.FunctionsScoreQuery.query: object expected");
                    message.query = $root.search.proto.Query.fromObject(object.query);
                }
                if (object.functions) {
                    if (!Array.isArray(object.functions))
                        throw TypeError(".search.proto.FunctionsScoreQuery.functions: array expected");
                    message.functions = [];
                    for (var i = 0; i < object.functions.length; ++i) {
                        if (typeof object.functions[i] !== "object")
                            throw TypeError(".search.proto.FunctionsScoreQuery.functions: object expected");
                        message.functions[i] = $root.search.proto.Function.fromObject(object.functions[i]);
                    }
                }
                switch (object.scoreMode) {
                case "FSM_AVG":
                case 1:
                    message.scoreMode = 1;
                    break;
                case "FSM_MAX":
                case 2:
                    message.scoreMode = 2;
                    break;
                case "FSM_SUM":
                case 3:
                    message.scoreMode = 3;
                    break;
                case "FSM_MIN":
                case 4:
                    message.scoreMode = 4;
                    break;
                case "FSM_MULTIPLY":
                case 5:
                    message.scoreMode = 5;
                    break;
                case "FSM_FIRST":
                case 6:
                    message.scoreMode = 6;
                    break;
                }
                switch (object.combineMode) {
                case "FCM_MULTIPLY":
                case 1:
                    message.combineMode = 1;
                    break;
                case "FCM_AVG":
                case 2:
                    message.combineMode = 2;
                    break;
                case "FCM_MAX":
                case 3:
                    message.combineMode = 3;
                    break;
                case "FCM_SUM":
                case 4:
                    message.combineMode = 4;
                    break;
                case "FCM_MIN":
                case 5:
                    message.combineMode = 5;
                    break;
                case "FCM_REPLACE":
                case 6:
                    message.combineMode = 6;
                    break;
                }
                if (object.minScore != null)
                    message.minScore = Number(object.minScore);
                if (object.maxScore != null)
                    message.maxScore = Number(object.maxScore);
                return message;
            };

            /**
             * Creates a plain object from a FunctionsScoreQuery message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.FunctionsScoreQuery
             * @static
             * @param {search.proto.FunctionsScoreQuery} message FunctionsScoreQuery
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FunctionsScoreQuery.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.functions = [];
                if (options.defaults) {
                    object.query = null;
                    object.scoreMode = options.enums === String ? "FSM_AVG" : 1;
                    object.combineMode = options.enums === String ? "FCM_MULTIPLY" : 1;
                    object.minScore = 0;
                    object.maxScore = 0;
                }
                if (message.query != null && message.hasOwnProperty("query"))
                    object.query = $root.search.proto.Query.toObject(message.query, options);
                if (message.functions && message.functions.length) {
                    object.functions = [];
                    for (var j = 0; j < message.functions.length; ++j)
                        object.functions[j] = $root.search.proto.Function.toObject(message.functions[j], options);
                }
                if (message.scoreMode != null && message.hasOwnProperty("scoreMode"))
                    object.scoreMode = options.enums === String ? $root.search.proto.FunctionScoreMode[message.scoreMode] : message.scoreMode;
                if (message.combineMode != null && message.hasOwnProperty("combineMode"))
                    object.combineMode = options.enums === String ? $root.search.proto.FunctionCombineMode[message.combineMode] : message.combineMode;
                if (message.minScore != null && message.hasOwnProperty("minScore"))
                    object.minScore = options.json && !isFinite(message.minScore) ? String(message.minScore) : message.minScore;
                if (message.maxScore != null && message.hasOwnProperty("maxScore"))
                    object.maxScore = options.json && !isFinite(message.maxScore) ? String(message.maxScore) : message.maxScore;
                return object;
            };

            /**
             * Converts this FunctionsScoreQuery to JSON.
             * @function toJSON
             * @memberof search.proto.FunctionsScoreQuery
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FunctionsScoreQuery.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FunctionsScoreQuery;
        })();

        proto.Function = (function() {

            /**
             * Properties of a Function.
             * @memberof search.proto
             * @interface IFunction
             * @property {search.proto.IFieldValueFactorFunction|null} [fieldValueFactor] Function fieldValueFactor
             * @property {search.proto.IRandomScoreFunction|null} [random] Function random
             * @property {search.proto.IDecayFunction|null} [decay] Function decay
             * @property {number|null} [weight] Function weight
             * @property {search.proto.IQuery|null} [filter] Function filter
             */

            /**
             * Constructs a new Function.
             * @memberof search.proto
             * @classdesc Represents a Function.
             * @implements IFunction
             * @constructor
             * @param {search.proto.IFunction=} [properties] Properties to set
             */
            function Function(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Function fieldValueFactor.
             * @member {search.proto.IFieldValueFactorFunction|null|undefined} fieldValueFactor
             * @memberof search.proto.Function
             * @instance
             */
            Function.prototype.fieldValueFactor = null;

            /**
             * Function random.
             * @member {search.proto.IRandomScoreFunction|null|undefined} random
             * @memberof search.proto.Function
             * @instance
             */
            Function.prototype.random = null;

            /**
             * Function decay.
             * @member {search.proto.IDecayFunction|null|undefined} decay
             * @memberof search.proto.Function
             * @instance
             */
            Function.prototype.decay = null;

            /**
             * Function weight.
             * @member {number} weight
             * @memberof search.proto.Function
             * @instance
             */
            Function.prototype.weight = 0;

            /**
             * Function filter.
             * @member {search.proto.IQuery|null|undefined} filter
             * @memberof search.proto.Function
             * @instance
             */
            Function.prototype.filter = null;

            /**
             * Creates a new Function instance using the specified properties.
             * @function create
             * @memberof search.proto.Function
             * @static
             * @param {search.proto.IFunction=} [properties] Properties to set
             * @returns {search.proto.Function} Function instance
             */
            Function.create = function create(properties) {
                return new Function(properties);
            };

            /**
             * Encodes the specified Function message. Does not implicitly {@link search.proto.Function.verify|verify} messages.
             * @function encode
             * @memberof search.proto.Function
             * @static
             * @param {search.proto.IFunction} message Function message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Function.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fieldValueFactor != null && Object.hasOwnProperty.call(message, "fieldValueFactor"))
                    $root.search.proto.FieldValueFactorFunction.encode(message.fieldValueFactor, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.random != null && Object.hasOwnProperty.call(message, "random"))
                    $root.search.proto.RandomScoreFunction.encode(message.random, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.decay != null && Object.hasOwnProperty.call(message, "decay"))
                    $root.search.proto.DecayFunction.encode(message.decay, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.weight != null && Object.hasOwnProperty.call(message, "weight"))
                    writer.uint32(/* id 4, wireType 5 =*/37).float(message.weight);
                if (message.filter != null && Object.hasOwnProperty.call(message, "filter"))
                    $root.search.proto.Query.encode(message.filter, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Function message, length delimited. Does not implicitly {@link search.proto.Function.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.Function
             * @static
             * @param {search.proto.IFunction} message Function message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Function.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Function message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.Function
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.Function} Function
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Function.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.Function();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fieldValueFactor = $root.search.proto.FieldValueFactorFunction.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.random = $root.search.proto.RandomScoreFunction.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.decay = $root.search.proto.DecayFunction.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.weight = reader.float();
                        break;
                    case 5:
                        message.filter = $root.search.proto.Query.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Function message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.Function
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.Function} Function
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Function.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Function message.
             * @function verify
             * @memberof search.proto.Function
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Function.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fieldValueFactor != null && message.hasOwnProperty("fieldValueFactor")) {
                    var error = $root.search.proto.FieldValueFactorFunction.verify(message.fieldValueFactor);
                    if (error)
                        return "fieldValueFactor." + error;
                }
                if (message.random != null && message.hasOwnProperty("random")) {
                    var error = $root.search.proto.RandomScoreFunction.verify(message.random);
                    if (error)
                        return "random." + error;
                }
                if (message.decay != null && message.hasOwnProperty("decay")) {
                    var error = $root.search.proto.DecayFunction.verify(message.decay);
                    if (error)
                        return "decay." + error;
                }
                if (message.weight != null && message.hasOwnProperty("weight"))
                    if (typeof message.weight !== "number")
                        return "weight: number expected";
                if (message.filter != null && message.hasOwnProperty("filter")) {
                    var error = $root.search.proto.Query.verify(message.filter);
                    if (error)
                        return "filter." + error;
                }
                return null;
            };

            /**
             * Creates a Function message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.Function
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.Function} Function
             */
            Function.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.Function)
                    return object;
                var message = new $root.search.proto.Function();
                if (object.fieldValueFactor != null) {
                    if (typeof object.fieldValueFactor !== "object")
                        throw TypeError(".search.proto.Function.fieldValueFactor: object expected");
                    message.fieldValueFactor = $root.search.proto.FieldValueFactorFunction.fromObject(object.fieldValueFactor);
                }
                if (object.random != null) {
                    if (typeof object.random !== "object")
                        throw TypeError(".search.proto.Function.random: object expected");
                    message.random = $root.search.proto.RandomScoreFunction.fromObject(object.random);
                }
                if (object.decay != null) {
                    if (typeof object.decay !== "object")
                        throw TypeError(".search.proto.Function.decay: object expected");
                    message.decay = $root.search.proto.DecayFunction.fromObject(object.decay);
                }
                if (object.weight != null)
                    message.weight = Number(object.weight);
                if (object.filter != null) {
                    if (typeof object.filter !== "object")
                        throw TypeError(".search.proto.Function.filter: object expected");
                    message.filter = $root.search.proto.Query.fromObject(object.filter);
                }
                return message;
            };

            /**
             * Creates a plain object from a Function message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.Function
             * @static
             * @param {search.proto.Function} message Function
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Function.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.fieldValueFactor = null;
                    object.random = null;
                    object.decay = null;
                    object.weight = 0;
                    object.filter = null;
                }
                if (message.fieldValueFactor != null && message.hasOwnProperty("fieldValueFactor"))
                    object.fieldValueFactor = $root.search.proto.FieldValueFactorFunction.toObject(message.fieldValueFactor, options);
                if (message.random != null && message.hasOwnProperty("random"))
                    object.random = $root.search.proto.RandomScoreFunction.toObject(message.random, options);
                if (message.decay != null && message.hasOwnProperty("decay"))
                    object.decay = $root.search.proto.DecayFunction.toObject(message.decay, options);
                if (message.weight != null && message.hasOwnProperty("weight"))
                    object.weight = options.json && !isFinite(message.weight) ? String(message.weight) : message.weight;
                if (message.filter != null && message.hasOwnProperty("filter"))
                    object.filter = $root.search.proto.Query.toObject(message.filter, options);
                return object;
            };

            /**
             * Converts this Function to JSON.
             * @function toJSON
             * @memberof search.proto.Function
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Function.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Function;
        })();

        proto.FieldValueFactorFunction = (function() {

            /**
             * Properties of a FieldValueFactorFunction.
             * @memberof search.proto
             * @interface IFieldValueFactorFunction
             * @property {string|null} [fieldName] FieldValueFactorFunction fieldName
             * @property {number|null} [factor] FieldValueFactorFunction factor
             * @property {search.proto.FunctionModifier|null} [modifier] FieldValueFactorFunction modifier
             * @property {number|null} [missing] FieldValueFactorFunction missing
             */

            /**
             * Constructs a new FieldValueFactorFunction.
             * @memberof search.proto
             * @classdesc Represents a FieldValueFactorFunction.
             * @implements IFieldValueFactorFunction
             * @constructor
             * @param {search.proto.IFieldValueFactorFunction=} [properties] Properties to set
             */
            function FieldValueFactorFunction(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FieldValueFactorFunction fieldName.
             * @member {string} fieldName
             * @memberof search.proto.FieldValueFactorFunction
             * @instance
             */
            FieldValueFactorFunction.prototype.fieldName = "";

            /**
             * FieldValueFactorFunction factor.
             * @member {number} factor
             * @memberof search.proto.FieldValueFactorFunction
             * @instance
             */
            FieldValueFactorFunction.prototype.factor = 0;

            /**
             * FieldValueFactorFunction modifier.
             * @member {search.proto.FunctionModifier} modifier
             * @memberof search.proto.FieldValueFactorFunction
             * @instance
             */
            FieldValueFactorFunction.prototype.modifier = 1;

            /**
             * FieldValueFactorFunction missing.
             * @member {number} missing
             * @memberof search.proto.FieldValueFactorFunction
             * @instance
             */
            FieldValueFactorFunction.prototype.missing = 0;

            /**
             * Creates a new FieldValueFactorFunction instance using the specified properties.
             * @function create
             * @memberof search.proto.FieldValueFactorFunction
             * @static
             * @param {search.proto.IFieldValueFactorFunction=} [properties] Properties to set
             * @returns {search.proto.FieldValueFactorFunction} FieldValueFactorFunction instance
             */
            FieldValueFactorFunction.create = function create(properties) {
                return new FieldValueFactorFunction(properties);
            };

            /**
             * Encodes the specified FieldValueFactorFunction message. Does not implicitly {@link search.proto.FieldValueFactorFunction.verify|verify} messages.
             * @function encode
             * @memberof search.proto.FieldValueFactorFunction
             * @static
             * @param {search.proto.IFieldValueFactorFunction} message FieldValueFactorFunction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldValueFactorFunction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fieldName != null && Object.hasOwnProperty.call(message, "fieldName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fieldName);
                if (message.factor != null && Object.hasOwnProperty.call(message, "factor"))
                    writer.uint32(/* id 2, wireType 5 =*/21).float(message.factor);
                if (message.modifier != null && Object.hasOwnProperty.call(message, "modifier"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.modifier);
                if (message.missing != null && Object.hasOwnProperty.call(message, "missing"))
                    writer.uint32(/* id 4, wireType 1 =*/33).double(message.missing);
                return writer;
            };

            /**
             * Encodes the specified FieldValueFactorFunction message, length delimited. Does not implicitly {@link search.proto.FieldValueFactorFunction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.FieldValueFactorFunction
             * @static
             * @param {search.proto.IFieldValueFactorFunction} message FieldValueFactorFunction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldValueFactorFunction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FieldValueFactorFunction message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.FieldValueFactorFunction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.FieldValueFactorFunction} FieldValueFactorFunction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldValueFactorFunction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.FieldValueFactorFunction();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fieldName = reader.string();
                        break;
                    case 2:
                        message.factor = reader.float();
                        break;
                    case 3:
                        message.modifier = reader.int32();
                        break;
                    case 4:
                        message.missing = reader.double();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FieldValueFactorFunction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.FieldValueFactorFunction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.FieldValueFactorFunction} FieldValueFactorFunction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldValueFactorFunction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FieldValueFactorFunction message.
             * @function verify
             * @memberof search.proto.FieldValueFactorFunction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FieldValueFactorFunction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    if (!$util.isString(message.fieldName))
                        return "fieldName: string expected";
                if (message.factor != null && message.hasOwnProperty("factor"))
                    if (typeof message.factor !== "number")
                        return "factor: number expected";
                if (message.modifier != null && message.hasOwnProperty("modifier"))
                    switch (message.modifier) {
                    default:
                        return "modifier: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                        break;
                    }
                if (message.missing != null && message.hasOwnProperty("missing"))
                    if (typeof message.missing !== "number")
                        return "missing: number expected";
                return null;
            };

            /**
             * Creates a FieldValueFactorFunction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.FieldValueFactorFunction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.FieldValueFactorFunction} FieldValueFactorFunction
             */
            FieldValueFactorFunction.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.FieldValueFactorFunction)
                    return object;
                var message = new $root.search.proto.FieldValueFactorFunction();
                if (object.fieldName != null)
                    message.fieldName = String(object.fieldName);
                if (object.factor != null)
                    message.factor = Number(object.factor);
                switch (object.modifier) {
                case "FM_NONE":
                case 1:
                    message.modifier = 1;
                    break;
                case "FM_LOG":
                case 2:
                    message.modifier = 2;
                    break;
                case "FM_LOG1P":
                case 3:
                    message.modifier = 3;
                    break;
                case "FM_LOG2P":
                case 4:
                    message.modifier = 4;
                    break;
                case "FM_LN":
                case 5:
                    message.modifier = 5;
                    break;
                case "FM_LN1P":
                case 6:
                    message.modifier = 6;
                    break;
                case "FM_LN2P":
                case 7:
                    message.modifier = 7;
                    break;
                case "FM_SQUARE":
                case 8:
                    message.modifier = 8;
                    break;
                case "FM_SQRT":
                case 9:
                    message.modifier = 9;
                    break;
                case "FM_RECIPROCAL":
                case 10:
                    message.modifier = 10;
                    break;
                }
                if (object.missing != null)
                    message.missing = Number(object.missing);
                return message;
            };

            /**
             * Creates a plain object from a FieldValueFactorFunction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.FieldValueFactorFunction
             * @static
             * @param {search.proto.FieldValueFactorFunction} message FieldValueFactorFunction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FieldValueFactorFunction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.fieldName = "";
                    object.factor = 0;
                    object.modifier = options.enums === String ? "FM_NONE" : 1;
                    object.missing = 0;
                }
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    object.fieldName = message.fieldName;
                if (message.factor != null && message.hasOwnProperty("factor"))
                    object.factor = options.json && !isFinite(message.factor) ? String(message.factor) : message.factor;
                if (message.modifier != null && message.hasOwnProperty("modifier"))
                    object.modifier = options.enums === String ? $root.search.proto.FunctionModifier[message.modifier] : message.modifier;
                if (message.missing != null && message.hasOwnProperty("missing"))
                    object.missing = options.json && !isFinite(message.missing) ? String(message.missing) : message.missing;
                return object;
            };

            /**
             * Converts this FieldValueFactorFunction to JSON.
             * @function toJSON
             * @memberof search.proto.FieldValueFactorFunction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FieldValueFactorFunction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FieldValueFactorFunction;
        })();

        /**
         * FunctionModifier enum.
         * @name search.proto.FunctionModifier
         * @enum {number}
         * @property {number} FM_NONE=1 FM_NONE value
         * @property {number} FM_LOG=2 FM_LOG value
         * @property {number} FM_LOG1P=3 FM_LOG1P value
         * @property {number} FM_LOG2P=4 FM_LOG2P value
         * @property {number} FM_LN=5 FM_LN value
         * @property {number} FM_LN1P=6 FM_LN1P value
         * @property {number} FM_LN2P=7 FM_LN2P value
         * @property {number} FM_SQUARE=8 FM_SQUARE value
         * @property {number} FM_SQRT=9 FM_SQRT value
         * @property {number} FM_RECIPROCAL=10 FM_RECIPROCAL value
         */
        proto.FunctionModifier = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "FM_NONE"] = 1;
            values[valuesById[2] = "FM_LOG"] = 2;
            values[valuesById[3] = "FM_LOG1P"] = 3;
            values[valuesById[4] = "FM_LOG2P"] = 4;
            values[valuesById[5] = "FM_LN"] = 5;
            values[valuesById[6] = "FM_LN1P"] = 6;
            values[valuesById[7] = "FM_LN2P"] = 7;
            values[valuesById[8] = "FM_SQUARE"] = 8;
            values[valuesById[9] = "FM_SQRT"] = 9;
            values[valuesById[10] = "FM_RECIPROCAL"] = 10;
            return values;
        })();

        proto.DecayFunction = (function() {

            /**
             * Properties of a DecayFunction.
             * @memberof search.proto
             * @interface IDecayFunction
             * @property {string|null} [fieldName] DecayFunction fieldName
             * @property {search.proto.DecayMathFunction|null} [mathFunction] DecayFunction mathFunction
             * @property {search.proto.DecayFuncParamType|null} [paramType] DecayFunction paramType
             * @property {Uint8Array|null} [param] DecayFunction param
             * @property {number|null} [decay] DecayFunction decay
             * @property {search.proto.MultiValueMode|null} [multiValueMode] DecayFunction multiValueMode
             */

            /**
             * Constructs a new DecayFunction.
             * @memberof search.proto
             * @classdesc Represents a DecayFunction.
             * @implements IDecayFunction
             * @constructor
             * @param {search.proto.IDecayFunction=} [properties] Properties to set
             */
            function DecayFunction(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DecayFunction fieldName.
             * @member {string} fieldName
             * @memberof search.proto.DecayFunction
             * @instance
             */
            DecayFunction.prototype.fieldName = "";

            /**
             * DecayFunction mathFunction.
             * @member {search.proto.DecayMathFunction} mathFunction
             * @memberof search.proto.DecayFunction
             * @instance
             */
            DecayFunction.prototype.mathFunction = 1;

            /**
             * DecayFunction paramType.
             * @member {search.proto.DecayFuncParamType} paramType
             * @memberof search.proto.DecayFunction
             * @instance
             */
            DecayFunction.prototype.paramType = 1;

            /**
             * DecayFunction param.
             * @member {Uint8Array} param
             * @memberof search.proto.DecayFunction
             * @instance
             */
            DecayFunction.prototype.param = $util.newBuffer([]);

            /**
             * DecayFunction decay.
             * @member {number} decay
             * @memberof search.proto.DecayFunction
             * @instance
             */
            DecayFunction.prototype.decay = 0;

            /**
             * DecayFunction multiValueMode.
             * @member {search.proto.MultiValueMode} multiValueMode
             * @memberof search.proto.DecayFunction
             * @instance
             */
            DecayFunction.prototype.multiValueMode = 1;

            /**
             * Creates a new DecayFunction instance using the specified properties.
             * @function create
             * @memberof search.proto.DecayFunction
             * @static
             * @param {search.proto.IDecayFunction=} [properties] Properties to set
             * @returns {search.proto.DecayFunction} DecayFunction instance
             */
            DecayFunction.create = function create(properties) {
                return new DecayFunction(properties);
            };

            /**
             * Encodes the specified DecayFunction message. Does not implicitly {@link search.proto.DecayFunction.verify|verify} messages.
             * @function encode
             * @memberof search.proto.DecayFunction
             * @static
             * @param {search.proto.IDecayFunction} message DecayFunction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DecayFunction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fieldName != null && Object.hasOwnProperty.call(message, "fieldName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fieldName);
                if (message.mathFunction != null && Object.hasOwnProperty.call(message, "mathFunction"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.mathFunction);
                if (message.paramType != null && Object.hasOwnProperty.call(message, "paramType"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.paramType);
                if (message.param != null && Object.hasOwnProperty.call(message, "param"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.param);
                if (message.decay != null && Object.hasOwnProperty.call(message, "decay"))
                    writer.uint32(/* id 5, wireType 1 =*/41).double(message.decay);
                if (message.multiValueMode != null && Object.hasOwnProperty.call(message, "multiValueMode"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.multiValueMode);
                return writer;
            };

            /**
             * Encodes the specified DecayFunction message, length delimited. Does not implicitly {@link search.proto.DecayFunction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.DecayFunction
             * @static
             * @param {search.proto.IDecayFunction} message DecayFunction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DecayFunction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DecayFunction message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.DecayFunction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.DecayFunction} DecayFunction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DecayFunction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.DecayFunction();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fieldName = reader.string();
                        break;
                    case 2:
                        message.mathFunction = reader.int32();
                        break;
                    case 3:
                        message.paramType = reader.int32();
                        break;
                    case 4:
                        message.param = reader.bytes();
                        break;
                    case 5:
                        message.decay = reader.double();
                        break;
                    case 6:
                        message.multiValueMode = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DecayFunction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.DecayFunction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.DecayFunction} DecayFunction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DecayFunction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DecayFunction message.
             * @function verify
             * @memberof search.proto.DecayFunction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DecayFunction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    if (!$util.isString(message.fieldName))
                        return "fieldName: string expected";
                if (message.mathFunction != null && message.hasOwnProperty("mathFunction"))
                    switch (message.mathFunction) {
                    default:
                        return "mathFunction: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.paramType != null && message.hasOwnProperty("paramType"))
                    switch (message.paramType) {
                    default:
                        return "paramType: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.param != null && message.hasOwnProperty("param"))
                    if (!(message.param && typeof message.param.length === "number" || $util.isString(message.param)))
                        return "param: buffer expected";
                if (message.decay != null && message.hasOwnProperty("decay"))
                    if (typeof message.decay !== "number")
                        return "decay: number expected";
                if (message.multiValueMode != null && message.hasOwnProperty("multiValueMode"))
                    switch (message.multiValueMode) {
                    default:
                        return "multiValueMode: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                return null;
            };

            /**
             * Creates a DecayFunction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.DecayFunction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.DecayFunction} DecayFunction
             */
            DecayFunction.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.DecayFunction)
                    return object;
                var message = new $root.search.proto.DecayFunction();
                if (object.fieldName != null)
                    message.fieldName = String(object.fieldName);
                switch (object.mathFunction) {
                case "GAUSS":
                case 1:
                    message.mathFunction = 1;
                    break;
                case "EXP":
                case 2:
                    message.mathFunction = 2;
                    break;
                case "LINEAR":
                case 3:
                    message.mathFunction = 3;
                    break;
                }
                switch (object.paramType) {
                case "DF_DATE_PARAM":
                case 1:
                    message.paramType = 1;
                    break;
                case "DF_NUMERIC_PARAM":
                case 2:
                    message.paramType = 2;
                    break;
                case "DF_GEO_PARAM":
                case 3:
                    message.paramType = 3;
                    break;
                }
                if (object.param != null)
                    if (typeof object.param === "string")
                        $util.base64.decode(object.param, message.param = $util.newBuffer($util.base64.length(object.param)), 0);
                    else if (object.param.length)
                        message.param = object.param;
                if (object.decay != null)
                    message.decay = Number(object.decay);
                switch (object.multiValueMode) {
                case "MVM_MAX":
                case 1:
                    message.multiValueMode = 1;
                    break;
                case "MVM_MIN":
                case 2:
                    message.multiValueMode = 2;
                    break;
                case "MVM_SUM":
                case 3:
                    message.multiValueMode = 3;
                    break;
                case "MVM_AVG":
                case 4:
                    message.multiValueMode = 4;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a DecayFunction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.DecayFunction
             * @static
             * @param {search.proto.DecayFunction} message DecayFunction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DecayFunction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.fieldName = "";
                    object.mathFunction = options.enums === String ? "GAUSS" : 1;
                    object.paramType = options.enums === String ? "DF_DATE_PARAM" : 1;
                    if (options.bytes === String)
                        object.param = "";
                    else {
                        object.param = [];
                        if (options.bytes !== Array)
                            object.param = $util.newBuffer(object.param);
                    }
                    object.decay = 0;
                    object.multiValueMode = options.enums === String ? "MVM_MAX" : 1;
                }
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    object.fieldName = message.fieldName;
                if (message.mathFunction != null && message.hasOwnProperty("mathFunction"))
                    object.mathFunction = options.enums === String ? $root.search.proto.DecayMathFunction[message.mathFunction] : message.mathFunction;
                if (message.paramType != null && message.hasOwnProperty("paramType"))
                    object.paramType = options.enums === String ? $root.search.proto.DecayFuncParamType[message.paramType] : message.paramType;
                if (message.param != null && message.hasOwnProperty("param"))
                    object.param = options.bytes === String ? $util.base64.encode(message.param, 0, message.param.length) : options.bytes === Array ? Array.prototype.slice.call(message.param) : message.param;
                if (message.decay != null && message.hasOwnProperty("decay"))
                    object.decay = options.json && !isFinite(message.decay) ? String(message.decay) : message.decay;
                if (message.multiValueMode != null && message.hasOwnProperty("multiValueMode"))
                    object.multiValueMode = options.enums === String ? $root.search.proto.MultiValueMode[message.multiValueMode] : message.multiValueMode;
                return object;
            };

            /**
             * Converts this DecayFunction to JSON.
             * @function toJSON
             * @memberof search.proto.DecayFunction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DecayFunction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DecayFunction;
        })();

        /**
         * DecayFuncParamType enum.
         * @name search.proto.DecayFuncParamType
         * @enum {number}
         * @property {number} DF_DATE_PARAM=1 DF_DATE_PARAM value
         * @property {number} DF_NUMERIC_PARAM=2 DF_NUMERIC_PARAM value
         * @property {number} DF_GEO_PARAM=3 DF_GEO_PARAM value
         */
        proto.DecayFuncParamType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "DF_DATE_PARAM"] = 1;
            values[valuesById[2] = "DF_NUMERIC_PARAM"] = 2;
            values[valuesById[3] = "DF_GEO_PARAM"] = 3;
            return values;
        })();

        proto.DecayFuncDateParam = (function() {

            /**
             * Properties of a DecayFuncDateParam.
             * @memberof search.proto
             * @interface IDecayFuncDateParam
             * @property {number|Long|null} [originLong] DecayFuncDateParam originLong
             * @property {string|null} [originString] DecayFuncDateParam originString
             * @property {search.proto.IDateTimeValue|null} [scale] DecayFuncDateParam scale
             * @property {search.proto.IDateTimeValue|null} [offset] DecayFuncDateParam offset
             */

            /**
             * Constructs a new DecayFuncDateParam.
             * @memberof search.proto
             * @classdesc Represents a DecayFuncDateParam.
             * @implements IDecayFuncDateParam
             * @constructor
             * @param {search.proto.IDecayFuncDateParam=} [properties] Properties to set
             */
            function DecayFuncDateParam(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DecayFuncDateParam originLong.
             * @member {number|Long} originLong
             * @memberof search.proto.DecayFuncDateParam
             * @instance
             */
            DecayFuncDateParam.prototype.originLong = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * DecayFuncDateParam originString.
             * @member {string} originString
             * @memberof search.proto.DecayFuncDateParam
             * @instance
             */
            DecayFuncDateParam.prototype.originString = "";

            /**
             * DecayFuncDateParam scale.
             * @member {search.proto.IDateTimeValue|null|undefined} scale
             * @memberof search.proto.DecayFuncDateParam
             * @instance
             */
            DecayFuncDateParam.prototype.scale = null;

            /**
             * DecayFuncDateParam offset.
             * @member {search.proto.IDateTimeValue|null|undefined} offset
             * @memberof search.proto.DecayFuncDateParam
             * @instance
             */
            DecayFuncDateParam.prototype.offset = null;

            /**
             * Creates a new DecayFuncDateParam instance using the specified properties.
             * @function create
             * @memberof search.proto.DecayFuncDateParam
             * @static
             * @param {search.proto.IDecayFuncDateParam=} [properties] Properties to set
             * @returns {search.proto.DecayFuncDateParam} DecayFuncDateParam instance
             */
            DecayFuncDateParam.create = function create(properties) {
                return new DecayFuncDateParam(properties);
            };

            /**
             * Encodes the specified DecayFuncDateParam message. Does not implicitly {@link search.proto.DecayFuncDateParam.verify|verify} messages.
             * @function encode
             * @memberof search.proto.DecayFuncDateParam
             * @static
             * @param {search.proto.IDecayFuncDateParam} message DecayFuncDateParam message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DecayFuncDateParam.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.originLong != null && Object.hasOwnProperty.call(message, "originLong"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.originLong);
                if (message.originString != null && Object.hasOwnProperty.call(message, "originString"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.originString);
                if (message.scale != null && Object.hasOwnProperty.call(message, "scale"))
                    $root.search.proto.DateTimeValue.encode(message.scale, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                    $root.search.proto.DateTimeValue.encode(message.offset, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DecayFuncDateParam message, length delimited. Does not implicitly {@link search.proto.DecayFuncDateParam.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.DecayFuncDateParam
             * @static
             * @param {search.proto.IDecayFuncDateParam} message DecayFuncDateParam message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DecayFuncDateParam.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DecayFuncDateParam message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.DecayFuncDateParam
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.DecayFuncDateParam} DecayFuncDateParam
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DecayFuncDateParam.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.DecayFuncDateParam();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.originLong = reader.int64();
                        break;
                    case 2:
                        message.originString = reader.string();
                        break;
                    case 3:
                        message.scale = $root.search.proto.DateTimeValue.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.offset = $root.search.proto.DateTimeValue.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DecayFuncDateParam message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.DecayFuncDateParam
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.DecayFuncDateParam} DecayFuncDateParam
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DecayFuncDateParam.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DecayFuncDateParam message.
             * @function verify
             * @memberof search.proto.DecayFuncDateParam
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DecayFuncDateParam.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.originLong != null && message.hasOwnProperty("originLong"))
                    if (!$util.isInteger(message.originLong) && !(message.originLong && $util.isInteger(message.originLong.low) && $util.isInteger(message.originLong.high)))
                        return "originLong: integer|Long expected";
                if (message.originString != null && message.hasOwnProperty("originString"))
                    if (!$util.isString(message.originString))
                        return "originString: string expected";
                if (message.scale != null && message.hasOwnProperty("scale")) {
                    var error = $root.search.proto.DateTimeValue.verify(message.scale);
                    if (error)
                        return "scale." + error;
                }
                if (message.offset != null && message.hasOwnProperty("offset")) {
                    var error = $root.search.proto.DateTimeValue.verify(message.offset);
                    if (error)
                        return "offset." + error;
                }
                return null;
            };

            /**
             * Creates a DecayFuncDateParam message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.DecayFuncDateParam
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.DecayFuncDateParam} DecayFuncDateParam
             */
            DecayFuncDateParam.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.DecayFuncDateParam)
                    return object;
                var message = new $root.search.proto.DecayFuncDateParam();
                if (object.originLong != null)
                    if ($util.Long)
                        (message.originLong = $util.Long.fromValue(object.originLong)).unsigned = false;
                    else if (typeof object.originLong === "string")
                        message.originLong = parseInt(object.originLong, 10);
                    else if (typeof object.originLong === "number")
                        message.originLong = object.originLong;
                    else if (typeof object.originLong === "object")
                        message.originLong = new $util.LongBits(object.originLong.low >>> 0, object.originLong.high >>> 0).toNumber();
                if (object.originString != null)
                    message.originString = String(object.originString);
                if (object.scale != null) {
                    if (typeof object.scale !== "object")
                        throw TypeError(".search.proto.DecayFuncDateParam.scale: object expected");
                    message.scale = $root.search.proto.DateTimeValue.fromObject(object.scale);
                }
                if (object.offset != null) {
                    if (typeof object.offset !== "object")
                        throw TypeError(".search.proto.DecayFuncDateParam.offset: object expected");
                    message.offset = $root.search.proto.DateTimeValue.fromObject(object.offset);
                }
                return message;
            };

            /**
             * Creates a plain object from a DecayFuncDateParam message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.DecayFuncDateParam
             * @static
             * @param {search.proto.DecayFuncDateParam} message DecayFuncDateParam
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DecayFuncDateParam.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.originLong = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.originLong = options.longs === String ? "0" : 0;
                    object.originString = "";
                    object.scale = null;
                    object.offset = null;
                }
                if (message.originLong != null && message.hasOwnProperty("originLong"))
                    if (typeof message.originLong === "number")
                        object.originLong = options.longs === String ? String(message.originLong) : message.originLong;
                    else
                        object.originLong = options.longs === String ? $util.Long.prototype.toString.call(message.originLong) : options.longs === Number ? new $util.LongBits(message.originLong.low >>> 0, message.originLong.high >>> 0).toNumber() : message.originLong;
                if (message.originString != null && message.hasOwnProperty("originString"))
                    object.originString = message.originString;
                if (message.scale != null && message.hasOwnProperty("scale"))
                    object.scale = $root.search.proto.DateTimeValue.toObject(message.scale, options);
                if (message.offset != null && message.hasOwnProperty("offset"))
                    object.offset = $root.search.proto.DateTimeValue.toObject(message.offset, options);
                return object;
            };

            /**
             * Converts this DecayFuncDateParam to JSON.
             * @function toJSON
             * @memberof search.proto.DecayFuncDateParam
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DecayFuncDateParam.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DecayFuncDateParam;
        })();

        proto.DecayFuncNumericParam = (function() {

            /**
             * Properties of a DecayFuncNumericParam.
             * @memberof search.proto
             * @interface IDecayFuncNumericParam
             * @property {number|null} [origin] DecayFuncNumericParam origin
             * @property {number|null} [scale] DecayFuncNumericParam scale
             * @property {number|null} [offset] DecayFuncNumericParam offset
             */

            /**
             * Constructs a new DecayFuncNumericParam.
             * @memberof search.proto
             * @classdesc Represents a DecayFuncNumericParam.
             * @implements IDecayFuncNumericParam
             * @constructor
             * @param {search.proto.IDecayFuncNumericParam=} [properties] Properties to set
             */
            function DecayFuncNumericParam(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DecayFuncNumericParam origin.
             * @member {number} origin
             * @memberof search.proto.DecayFuncNumericParam
             * @instance
             */
            DecayFuncNumericParam.prototype.origin = 0;

            /**
             * DecayFuncNumericParam scale.
             * @member {number} scale
             * @memberof search.proto.DecayFuncNumericParam
             * @instance
             */
            DecayFuncNumericParam.prototype.scale = 0;

            /**
             * DecayFuncNumericParam offset.
             * @member {number} offset
             * @memberof search.proto.DecayFuncNumericParam
             * @instance
             */
            DecayFuncNumericParam.prototype.offset = 0;

            /**
             * Creates a new DecayFuncNumericParam instance using the specified properties.
             * @function create
             * @memberof search.proto.DecayFuncNumericParam
             * @static
             * @param {search.proto.IDecayFuncNumericParam=} [properties] Properties to set
             * @returns {search.proto.DecayFuncNumericParam} DecayFuncNumericParam instance
             */
            DecayFuncNumericParam.create = function create(properties) {
                return new DecayFuncNumericParam(properties);
            };

            /**
             * Encodes the specified DecayFuncNumericParam message. Does not implicitly {@link search.proto.DecayFuncNumericParam.verify|verify} messages.
             * @function encode
             * @memberof search.proto.DecayFuncNumericParam
             * @static
             * @param {search.proto.IDecayFuncNumericParam} message DecayFuncNumericParam message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DecayFuncNumericParam.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.origin != null && Object.hasOwnProperty.call(message, "origin"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.origin);
                if (message.scale != null && Object.hasOwnProperty.call(message, "scale"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.scale);
                if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.offset);
                return writer;
            };

            /**
             * Encodes the specified DecayFuncNumericParam message, length delimited. Does not implicitly {@link search.proto.DecayFuncNumericParam.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.DecayFuncNumericParam
             * @static
             * @param {search.proto.IDecayFuncNumericParam} message DecayFuncNumericParam message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DecayFuncNumericParam.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DecayFuncNumericParam message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.DecayFuncNumericParam
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.DecayFuncNumericParam} DecayFuncNumericParam
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DecayFuncNumericParam.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.DecayFuncNumericParam();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.origin = reader.double();
                        break;
                    case 2:
                        message.scale = reader.double();
                        break;
                    case 3:
                        message.offset = reader.double();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DecayFuncNumericParam message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.DecayFuncNumericParam
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.DecayFuncNumericParam} DecayFuncNumericParam
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DecayFuncNumericParam.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DecayFuncNumericParam message.
             * @function verify
             * @memberof search.proto.DecayFuncNumericParam
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DecayFuncNumericParam.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.origin != null && message.hasOwnProperty("origin"))
                    if (typeof message.origin !== "number")
                        return "origin: number expected";
                if (message.scale != null && message.hasOwnProperty("scale"))
                    if (typeof message.scale !== "number")
                        return "scale: number expected";
                if (message.offset != null && message.hasOwnProperty("offset"))
                    if (typeof message.offset !== "number")
                        return "offset: number expected";
                return null;
            };

            /**
             * Creates a DecayFuncNumericParam message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.DecayFuncNumericParam
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.DecayFuncNumericParam} DecayFuncNumericParam
             */
            DecayFuncNumericParam.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.DecayFuncNumericParam)
                    return object;
                var message = new $root.search.proto.DecayFuncNumericParam();
                if (object.origin != null)
                    message.origin = Number(object.origin);
                if (object.scale != null)
                    message.scale = Number(object.scale);
                if (object.offset != null)
                    message.offset = Number(object.offset);
                return message;
            };

            /**
             * Creates a plain object from a DecayFuncNumericParam message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.DecayFuncNumericParam
             * @static
             * @param {search.proto.DecayFuncNumericParam} message DecayFuncNumericParam
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DecayFuncNumericParam.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.origin = 0;
                    object.scale = 0;
                    object.offset = 0;
                }
                if (message.origin != null && message.hasOwnProperty("origin"))
                    object.origin = options.json && !isFinite(message.origin) ? String(message.origin) : message.origin;
                if (message.scale != null && message.hasOwnProperty("scale"))
                    object.scale = options.json && !isFinite(message.scale) ? String(message.scale) : message.scale;
                if (message.offset != null && message.hasOwnProperty("offset"))
                    object.offset = options.json && !isFinite(message.offset) ? String(message.offset) : message.offset;
                return object;
            };

            /**
             * Converts this DecayFuncNumericParam to JSON.
             * @function toJSON
             * @memberof search.proto.DecayFuncNumericParam
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DecayFuncNumericParam.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DecayFuncNumericParam;
        })();

        proto.DecayFuncGeoParam = (function() {

            /**
             * Properties of a DecayFuncGeoParam.
             * @memberof search.proto
             * @interface IDecayFuncGeoParam
             * @property {string|null} [origin] DecayFuncGeoParam origin
             * @property {number|null} [scale] DecayFuncGeoParam scale
             * @property {number|null} [offset] DecayFuncGeoParam offset
             */

            /**
             * Constructs a new DecayFuncGeoParam.
             * @memberof search.proto
             * @classdesc Represents a DecayFuncGeoParam.
             * @implements IDecayFuncGeoParam
             * @constructor
             * @param {search.proto.IDecayFuncGeoParam=} [properties] Properties to set
             */
            function DecayFuncGeoParam(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DecayFuncGeoParam origin.
             * @member {string} origin
             * @memberof search.proto.DecayFuncGeoParam
             * @instance
             */
            DecayFuncGeoParam.prototype.origin = "";

            /**
             * DecayFuncGeoParam scale.
             * @member {number} scale
             * @memberof search.proto.DecayFuncGeoParam
             * @instance
             */
            DecayFuncGeoParam.prototype.scale = 0;

            /**
             * DecayFuncGeoParam offset.
             * @member {number} offset
             * @memberof search.proto.DecayFuncGeoParam
             * @instance
             */
            DecayFuncGeoParam.prototype.offset = 0;

            /**
             * Creates a new DecayFuncGeoParam instance using the specified properties.
             * @function create
             * @memberof search.proto.DecayFuncGeoParam
             * @static
             * @param {search.proto.IDecayFuncGeoParam=} [properties] Properties to set
             * @returns {search.proto.DecayFuncGeoParam} DecayFuncGeoParam instance
             */
            DecayFuncGeoParam.create = function create(properties) {
                return new DecayFuncGeoParam(properties);
            };

            /**
             * Encodes the specified DecayFuncGeoParam message. Does not implicitly {@link search.proto.DecayFuncGeoParam.verify|verify} messages.
             * @function encode
             * @memberof search.proto.DecayFuncGeoParam
             * @static
             * @param {search.proto.IDecayFuncGeoParam} message DecayFuncGeoParam message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DecayFuncGeoParam.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.origin != null && Object.hasOwnProperty.call(message, "origin"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.origin);
                if (message.scale != null && Object.hasOwnProperty.call(message, "scale"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.scale);
                if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.offset);
                return writer;
            };

            /**
             * Encodes the specified DecayFuncGeoParam message, length delimited. Does not implicitly {@link search.proto.DecayFuncGeoParam.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.DecayFuncGeoParam
             * @static
             * @param {search.proto.IDecayFuncGeoParam} message DecayFuncGeoParam message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DecayFuncGeoParam.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DecayFuncGeoParam message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.DecayFuncGeoParam
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.DecayFuncGeoParam} DecayFuncGeoParam
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DecayFuncGeoParam.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.DecayFuncGeoParam();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.origin = reader.string();
                        break;
                    case 2:
                        message.scale = reader.double();
                        break;
                    case 3:
                        message.offset = reader.double();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DecayFuncGeoParam message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.DecayFuncGeoParam
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.DecayFuncGeoParam} DecayFuncGeoParam
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DecayFuncGeoParam.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DecayFuncGeoParam message.
             * @function verify
             * @memberof search.proto.DecayFuncGeoParam
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DecayFuncGeoParam.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.origin != null && message.hasOwnProperty("origin"))
                    if (!$util.isString(message.origin))
                        return "origin: string expected";
                if (message.scale != null && message.hasOwnProperty("scale"))
                    if (typeof message.scale !== "number")
                        return "scale: number expected";
                if (message.offset != null && message.hasOwnProperty("offset"))
                    if (typeof message.offset !== "number")
                        return "offset: number expected";
                return null;
            };

            /**
             * Creates a DecayFuncGeoParam message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.DecayFuncGeoParam
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.DecayFuncGeoParam} DecayFuncGeoParam
             */
            DecayFuncGeoParam.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.DecayFuncGeoParam)
                    return object;
                var message = new $root.search.proto.DecayFuncGeoParam();
                if (object.origin != null)
                    message.origin = String(object.origin);
                if (object.scale != null)
                    message.scale = Number(object.scale);
                if (object.offset != null)
                    message.offset = Number(object.offset);
                return message;
            };

            /**
             * Creates a plain object from a DecayFuncGeoParam message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.DecayFuncGeoParam
             * @static
             * @param {search.proto.DecayFuncGeoParam} message DecayFuncGeoParam
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DecayFuncGeoParam.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.origin = "";
                    object.scale = 0;
                    object.offset = 0;
                }
                if (message.origin != null && message.hasOwnProperty("origin"))
                    object.origin = message.origin;
                if (message.scale != null && message.hasOwnProperty("scale"))
                    object.scale = options.json && !isFinite(message.scale) ? String(message.scale) : message.scale;
                if (message.offset != null && message.hasOwnProperty("offset"))
                    object.offset = options.json && !isFinite(message.offset) ? String(message.offset) : message.offset;
                return object;
            };

            /**
             * Converts this DecayFuncGeoParam to JSON.
             * @function toJSON
             * @memberof search.proto.DecayFuncGeoParam
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DecayFuncGeoParam.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DecayFuncGeoParam;
        })();

        /**
         * DecayMathFunction enum.
         * @name search.proto.DecayMathFunction
         * @enum {number}
         * @property {number} GAUSS=1 GAUSS value
         * @property {number} EXP=2 EXP value
         * @property {number} LINEAR=3 LINEAR value
         */
        proto.DecayMathFunction = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "GAUSS"] = 1;
            values[valuesById[2] = "EXP"] = 2;
            values[valuesById[3] = "LINEAR"] = 3;
            return values;
        })();

        /**
         * MultiValueMode enum.
         * @name search.proto.MultiValueMode
         * @enum {number}
         * @property {number} MVM_MAX=1 MVM_MAX value
         * @property {number} MVM_MIN=2 MVM_MIN value
         * @property {number} MVM_SUM=3 MVM_SUM value
         * @property {number} MVM_AVG=4 MVM_AVG value
         */
        proto.MultiValueMode = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "MVM_MAX"] = 1;
            values[valuesById[2] = "MVM_MIN"] = 2;
            values[valuesById[3] = "MVM_SUM"] = 3;
            values[valuesById[4] = "MVM_AVG"] = 4;
            return values;
        })();

        proto.RandomScoreFunction = (function() {

            /**
             * Properties of a RandomScoreFunction.
             * @memberof search.proto
             * @interface IRandomScoreFunction
             */

            /**
             * Constructs a new RandomScoreFunction.
             * @memberof search.proto
             * @classdesc Represents a RandomScoreFunction.
             * @implements IRandomScoreFunction
             * @constructor
             * @param {search.proto.IRandomScoreFunction=} [properties] Properties to set
             */
            function RandomScoreFunction(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new RandomScoreFunction instance using the specified properties.
             * @function create
             * @memberof search.proto.RandomScoreFunction
             * @static
             * @param {search.proto.IRandomScoreFunction=} [properties] Properties to set
             * @returns {search.proto.RandomScoreFunction} RandomScoreFunction instance
             */
            RandomScoreFunction.create = function create(properties) {
                return new RandomScoreFunction(properties);
            };

            /**
             * Encodes the specified RandomScoreFunction message. Does not implicitly {@link search.proto.RandomScoreFunction.verify|verify} messages.
             * @function encode
             * @memberof search.proto.RandomScoreFunction
             * @static
             * @param {search.proto.IRandomScoreFunction} message RandomScoreFunction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RandomScoreFunction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified RandomScoreFunction message, length delimited. Does not implicitly {@link search.proto.RandomScoreFunction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.RandomScoreFunction
             * @static
             * @param {search.proto.IRandomScoreFunction} message RandomScoreFunction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RandomScoreFunction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RandomScoreFunction message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.RandomScoreFunction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.RandomScoreFunction} RandomScoreFunction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RandomScoreFunction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.RandomScoreFunction();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RandomScoreFunction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.RandomScoreFunction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.RandomScoreFunction} RandomScoreFunction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RandomScoreFunction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RandomScoreFunction message.
             * @function verify
             * @memberof search.proto.RandomScoreFunction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RandomScoreFunction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a RandomScoreFunction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.RandomScoreFunction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.RandomScoreFunction} RandomScoreFunction
             */
            RandomScoreFunction.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.RandomScoreFunction)
                    return object;
                return new $root.search.proto.RandomScoreFunction();
            };

            /**
             * Creates a plain object from a RandomScoreFunction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.RandomScoreFunction
             * @static
             * @param {search.proto.RandomScoreFunction} message RandomScoreFunction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RandomScoreFunction.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this RandomScoreFunction to JSON.
             * @function toJSON
             * @memberof search.proto.RandomScoreFunction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RandomScoreFunction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RandomScoreFunction;
        })();

        /**
         * FunctionScoreMode enum.
         * @name search.proto.FunctionScoreMode
         * @enum {number}
         * @property {number} FSM_AVG=1 FSM_AVG value
         * @property {number} FSM_MAX=2 FSM_MAX value
         * @property {number} FSM_SUM=3 FSM_SUM value
         * @property {number} FSM_MIN=4 FSM_MIN value
         * @property {number} FSM_MULTIPLY=5 FSM_MULTIPLY value
         * @property {number} FSM_FIRST=6 FSM_FIRST value
         */
        proto.FunctionScoreMode = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "FSM_AVG"] = 1;
            values[valuesById[2] = "FSM_MAX"] = 2;
            values[valuesById[3] = "FSM_SUM"] = 3;
            values[valuesById[4] = "FSM_MIN"] = 4;
            values[valuesById[5] = "FSM_MULTIPLY"] = 5;
            values[valuesById[6] = "FSM_FIRST"] = 6;
            return values;
        })();

        /**
         * FunctionCombineMode enum.
         * @name search.proto.FunctionCombineMode
         * @enum {number}
         * @property {number} FCM_MULTIPLY=1 FCM_MULTIPLY value
         * @property {number} FCM_AVG=2 FCM_AVG value
         * @property {number} FCM_MAX=3 FCM_MAX value
         * @property {number} FCM_SUM=4 FCM_SUM value
         * @property {number} FCM_MIN=5 FCM_MIN value
         * @property {number} FCM_REPLACE=6 FCM_REPLACE value
         */
        proto.FunctionCombineMode = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "FCM_MULTIPLY"] = 1;
            values[valuesById[2] = "FCM_AVG"] = 2;
            values[valuesById[3] = "FCM_MAX"] = 3;
            values[valuesById[4] = "FCM_SUM"] = 4;
            values[valuesById[5] = "FCM_MIN"] = 5;
            values[valuesById[6] = "FCM_REPLACE"] = 6;
            return values;
        })();

        /**
         * ScoreMode enum.
         * @name search.proto.ScoreMode
         * @enum {number}
         * @property {number} SCORE_MODE_NONE=1 SCORE_MODE_NONE value
         * @property {number} SCORE_MODE_AVG=2 SCORE_MODE_AVG value
         * @property {number} SCORE_MODE_MAX=3 SCORE_MODE_MAX value
         * @property {number} SCORE_MODE_TOTAL=4 SCORE_MODE_TOTAL value
         * @property {number} SCORE_MODE_MIN=5 SCORE_MODE_MIN value
         */
        proto.ScoreMode = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "SCORE_MODE_NONE"] = 1;
            values[valuesById[2] = "SCORE_MODE_AVG"] = 2;
            values[valuesById[3] = "SCORE_MODE_MAX"] = 3;
            values[valuesById[4] = "SCORE_MODE_TOTAL"] = 4;
            values[valuesById[5] = "SCORE_MODE_MIN"] = 5;
            return values;
        })();

        proto.NestedQuery = (function() {

            /**
             * Properties of a NestedQuery.
             * @memberof search.proto
             * @interface INestedQuery
             * @property {string|null} [path] NestedQuery path
             * @property {search.proto.IQuery|null} [query] NestedQuery query
             * @property {search.proto.ScoreMode|null} [scoreMode] NestedQuery scoreMode
             * @property {number|null} [weight] NestedQuery weight
             * @property {search.proto.IInnerHits|null} [innerHits] NestedQuery innerHits
             */

            /**
             * Constructs a new NestedQuery.
             * @memberof search.proto
             * @classdesc Represents a NestedQuery.
             * @implements INestedQuery
             * @constructor
             * @param {search.proto.INestedQuery=} [properties] Properties to set
             */
            function NestedQuery(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NestedQuery path.
             * @member {string} path
             * @memberof search.proto.NestedQuery
             * @instance
             */
            NestedQuery.prototype.path = "";

            /**
             * NestedQuery query.
             * @member {search.proto.IQuery|null|undefined} query
             * @memberof search.proto.NestedQuery
             * @instance
             */
            NestedQuery.prototype.query = null;

            /**
             * NestedQuery scoreMode.
             * @member {search.proto.ScoreMode} scoreMode
             * @memberof search.proto.NestedQuery
             * @instance
             */
            NestedQuery.prototype.scoreMode = 1;

            /**
             * NestedQuery weight.
             * @member {number} weight
             * @memberof search.proto.NestedQuery
             * @instance
             */
            NestedQuery.prototype.weight = 0;

            /**
             * NestedQuery innerHits.
             * @member {search.proto.IInnerHits|null|undefined} innerHits
             * @memberof search.proto.NestedQuery
             * @instance
             */
            NestedQuery.prototype.innerHits = null;

            /**
             * Creates a new NestedQuery instance using the specified properties.
             * @function create
             * @memberof search.proto.NestedQuery
             * @static
             * @param {search.proto.INestedQuery=} [properties] Properties to set
             * @returns {search.proto.NestedQuery} NestedQuery instance
             */
            NestedQuery.create = function create(properties) {
                return new NestedQuery(properties);
            };

            /**
             * Encodes the specified NestedQuery message. Does not implicitly {@link search.proto.NestedQuery.verify|verify} messages.
             * @function encode
             * @memberof search.proto.NestedQuery
             * @static
             * @param {search.proto.INestedQuery} message NestedQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NestedQuery.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.path != null && Object.hasOwnProperty.call(message, "path"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.path);
                if (message.query != null && Object.hasOwnProperty.call(message, "query"))
                    $root.search.proto.Query.encode(message.query, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.scoreMode != null && Object.hasOwnProperty.call(message, "scoreMode"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.scoreMode);
                if (message.weight != null && Object.hasOwnProperty.call(message, "weight"))
                    writer.uint32(/* id 4, wireType 5 =*/37).float(message.weight);
                if (message.innerHits != null && Object.hasOwnProperty.call(message, "innerHits"))
                    $root.search.proto.InnerHits.encode(message.innerHits, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified NestedQuery message, length delimited. Does not implicitly {@link search.proto.NestedQuery.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.NestedQuery
             * @static
             * @param {search.proto.INestedQuery} message NestedQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NestedQuery.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NestedQuery message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.NestedQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.NestedQuery} NestedQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NestedQuery.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.NestedQuery();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.path = reader.string();
                        break;
                    case 2:
                        message.query = $root.search.proto.Query.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.scoreMode = reader.int32();
                        break;
                    case 4:
                        message.weight = reader.float();
                        break;
                    case 5:
                        message.innerHits = $root.search.proto.InnerHits.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NestedQuery message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.NestedQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.NestedQuery} NestedQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NestedQuery.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NestedQuery message.
             * @function verify
             * @memberof search.proto.NestedQuery
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NestedQuery.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                if (message.query != null && message.hasOwnProperty("query")) {
                    var error = $root.search.proto.Query.verify(message.query);
                    if (error)
                        return "query." + error;
                }
                if (message.scoreMode != null && message.hasOwnProperty("scoreMode"))
                    switch (message.scoreMode) {
                    default:
                        return "scoreMode: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        break;
                    }
                if (message.weight != null && message.hasOwnProperty("weight"))
                    if (typeof message.weight !== "number")
                        return "weight: number expected";
                if (message.innerHits != null && message.hasOwnProperty("innerHits")) {
                    var error = $root.search.proto.InnerHits.verify(message.innerHits);
                    if (error)
                        return "innerHits." + error;
                }
                return null;
            };

            /**
             * Creates a NestedQuery message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.NestedQuery
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.NestedQuery} NestedQuery
             */
            NestedQuery.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.NestedQuery)
                    return object;
                var message = new $root.search.proto.NestedQuery();
                if (object.path != null)
                    message.path = String(object.path);
                if (object.query != null) {
                    if (typeof object.query !== "object")
                        throw TypeError(".search.proto.NestedQuery.query: object expected");
                    message.query = $root.search.proto.Query.fromObject(object.query);
                }
                switch (object.scoreMode) {
                case "SCORE_MODE_NONE":
                case 1:
                    message.scoreMode = 1;
                    break;
                case "SCORE_MODE_AVG":
                case 2:
                    message.scoreMode = 2;
                    break;
                case "SCORE_MODE_MAX":
                case 3:
                    message.scoreMode = 3;
                    break;
                case "SCORE_MODE_TOTAL":
                case 4:
                    message.scoreMode = 4;
                    break;
                case "SCORE_MODE_MIN":
                case 5:
                    message.scoreMode = 5;
                    break;
                }
                if (object.weight != null)
                    message.weight = Number(object.weight);
                if (object.innerHits != null) {
                    if (typeof object.innerHits !== "object")
                        throw TypeError(".search.proto.NestedQuery.innerHits: object expected");
                    message.innerHits = $root.search.proto.InnerHits.fromObject(object.innerHits);
                }
                return message;
            };

            /**
             * Creates a plain object from a NestedQuery message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.NestedQuery
             * @static
             * @param {search.proto.NestedQuery} message NestedQuery
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NestedQuery.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.path = "";
                    object.query = null;
                    object.scoreMode = options.enums === String ? "SCORE_MODE_NONE" : 1;
                    object.weight = 0;
                    object.innerHits = null;
                }
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                if (message.query != null && message.hasOwnProperty("query"))
                    object.query = $root.search.proto.Query.toObject(message.query, options);
                if (message.scoreMode != null && message.hasOwnProperty("scoreMode"))
                    object.scoreMode = options.enums === String ? $root.search.proto.ScoreMode[message.scoreMode] : message.scoreMode;
                if (message.weight != null && message.hasOwnProperty("weight"))
                    object.weight = options.json && !isFinite(message.weight) ? String(message.weight) : message.weight;
                if (message.innerHits != null && message.hasOwnProperty("innerHits"))
                    object.innerHits = $root.search.proto.InnerHits.toObject(message.innerHits, options);
                return object;
            };

            /**
             * Converts this NestedQuery to JSON.
             * @function toJSON
             * @memberof search.proto.NestedQuery
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NestedQuery.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NestedQuery;
        })();

        proto.InnerHits = (function() {

            /**
             * Properties of an InnerHits.
             * @memberof search.proto
             * @interface IInnerHits
             * @property {search.proto.ISort|null} [sort] InnerHits sort
             * @property {number|null} [offset] InnerHits offset
             * @property {number|null} [limit] InnerHits limit
             * @property {search.proto.IHighlight|null} [highlight] InnerHits highlight
             */

            /**
             * Constructs a new InnerHits.
             * @memberof search.proto
             * @classdesc Represents an InnerHits.
             * @implements IInnerHits
             * @constructor
             * @param {search.proto.IInnerHits=} [properties] Properties to set
             */
            function InnerHits(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * InnerHits sort.
             * @member {search.proto.ISort|null|undefined} sort
             * @memberof search.proto.InnerHits
             * @instance
             */
            InnerHits.prototype.sort = null;

            /**
             * InnerHits offset.
             * @member {number} offset
             * @memberof search.proto.InnerHits
             * @instance
             */
            InnerHits.prototype.offset = 0;

            /**
             * InnerHits limit.
             * @member {number} limit
             * @memberof search.proto.InnerHits
             * @instance
             */
            InnerHits.prototype.limit = 0;

            /**
             * InnerHits highlight.
             * @member {search.proto.IHighlight|null|undefined} highlight
             * @memberof search.proto.InnerHits
             * @instance
             */
            InnerHits.prototype.highlight = null;

            /**
             * Creates a new InnerHits instance using the specified properties.
             * @function create
             * @memberof search.proto.InnerHits
             * @static
             * @param {search.proto.IInnerHits=} [properties] Properties to set
             * @returns {search.proto.InnerHits} InnerHits instance
             */
            InnerHits.create = function create(properties) {
                return new InnerHits(properties);
            };

            /**
             * Encodes the specified InnerHits message. Does not implicitly {@link search.proto.InnerHits.verify|verify} messages.
             * @function encode
             * @memberof search.proto.InnerHits
             * @static
             * @param {search.proto.IInnerHits} message InnerHits message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InnerHits.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sort != null && Object.hasOwnProperty.call(message, "sort"))
                    $root.search.proto.Sort.encode(message.sort, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.offset);
                if (message.limit != null && Object.hasOwnProperty.call(message, "limit"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.limit);
                if (message.highlight != null && Object.hasOwnProperty.call(message, "highlight"))
                    $root.search.proto.Highlight.encode(message.highlight, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified InnerHits message, length delimited. Does not implicitly {@link search.proto.InnerHits.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.InnerHits
             * @static
             * @param {search.proto.IInnerHits} message InnerHits message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InnerHits.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an InnerHits message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.InnerHits
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.InnerHits} InnerHits
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InnerHits.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.InnerHits();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sort = $root.search.proto.Sort.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.offset = reader.int32();
                        break;
                    case 3:
                        message.limit = reader.int32();
                        break;
                    case 4:
                        message.highlight = $root.search.proto.Highlight.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an InnerHits message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.InnerHits
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.InnerHits} InnerHits
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InnerHits.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an InnerHits message.
             * @function verify
             * @memberof search.proto.InnerHits
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            InnerHits.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sort != null && message.hasOwnProperty("sort")) {
                    var error = $root.search.proto.Sort.verify(message.sort);
                    if (error)
                        return "sort." + error;
                }
                if (message.offset != null && message.hasOwnProperty("offset"))
                    if (!$util.isInteger(message.offset))
                        return "offset: integer expected";
                if (message.limit != null && message.hasOwnProperty("limit"))
                    if (!$util.isInteger(message.limit))
                        return "limit: integer expected";
                if (message.highlight != null && message.hasOwnProperty("highlight")) {
                    var error = $root.search.proto.Highlight.verify(message.highlight);
                    if (error)
                        return "highlight." + error;
                }
                return null;
            };

            /**
             * Creates an InnerHits message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.InnerHits
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.InnerHits} InnerHits
             */
            InnerHits.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.InnerHits)
                    return object;
                var message = new $root.search.proto.InnerHits();
                if (object.sort != null) {
                    if (typeof object.sort !== "object")
                        throw TypeError(".search.proto.InnerHits.sort: object expected");
                    message.sort = $root.search.proto.Sort.fromObject(object.sort);
                }
                if (object.offset != null)
                    message.offset = object.offset | 0;
                if (object.limit != null)
                    message.limit = object.limit | 0;
                if (object.highlight != null) {
                    if (typeof object.highlight !== "object")
                        throw TypeError(".search.proto.InnerHits.highlight: object expected");
                    message.highlight = $root.search.proto.Highlight.fromObject(object.highlight);
                }
                return message;
            };

            /**
             * Creates a plain object from an InnerHits message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.InnerHits
             * @static
             * @param {search.proto.InnerHits} message InnerHits
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            InnerHits.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.sort = null;
                    object.offset = 0;
                    object.limit = 0;
                    object.highlight = null;
                }
                if (message.sort != null && message.hasOwnProperty("sort"))
                    object.sort = $root.search.proto.Sort.toObject(message.sort, options);
                if (message.offset != null && message.hasOwnProperty("offset"))
                    object.offset = message.offset;
                if (message.limit != null && message.hasOwnProperty("limit"))
                    object.limit = message.limit;
                if (message.highlight != null && message.hasOwnProperty("highlight"))
                    object.highlight = $root.search.proto.Highlight.toObject(message.highlight, options);
                return object;
            };

            /**
             * Converts this InnerHits to JSON.
             * @function toJSON
             * @memberof search.proto.InnerHits
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            InnerHits.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return InnerHits;
        })();

        proto.GeoBoundingBoxQuery = (function() {

            /**
             * Properties of a GeoBoundingBoxQuery.
             * @memberof search.proto
             * @interface IGeoBoundingBoxQuery
             * @property {string|null} [fieldName] GeoBoundingBoxQuery fieldName
             * @property {string|null} [topLeft] GeoBoundingBoxQuery topLeft
             * @property {string|null} [bottomRight] GeoBoundingBoxQuery bottomRight
             */

            /**
             * Constructs a new GeoBoundingBoxQuery.
             * @memberof search.proto
             * @classdesc Represents a GeoBoundingBoxQuery.
             * @implements IGeoBoundingBoxQuery
             * @constructor
             * @param {search.proto.IGeoBoundingBoxQuery=} [properties] Properties to set
             */
            function GeoBoundingBoxQuery(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GeoBoundingBoxQuery fieldName.
             * @member {string} fieldName
             * @memberof search.proto.GeoBoundingBoxQuery
             * @instance
             */
            GeoBoundingBoxQuery.prototype.fieldName = "";

            /**
             * GeoBoundingBoxQuery topLeft.
             * @member {string} topLeft
             * @memberof search.proto.GeoBoundingBoxQuery
             * @instance
             */
            GeoBoundingBoxQuery.prototype.topLeft = "";

            /**
             * GeoBoundingBoxQuery bottomRight.
             * @member {string} bottomRight
             * @memberof search.proto.GeoBoundingBoxQuery
             * @instance
             */
            GeoBoundingBoxQuery.prototype.bottomRight = "";

            /**
             * Creates a new GeoBoundingBoxQuery instance using the specified properties.
             * @function create
             * @memberof search.proto.GeoBoundingBoxQuery
             * @static
             * @param {search.proto.IGeoBoundingBoxQuery=} [properties] Properties to set
             * @returns {search.proto.GeoBoundingBoxQuery} GeoBoundingBoxQuery instance
             */
            GeoBoundingBoxQuery.create = function create(properties) {
                return new GeoBoundingBoxQuery(properties);
            };

            /**
             * Encodes the specified GeoBoundingBoxQuery message. Does not implicitly {@link search.proto.GeoBoundingBoxQuery.verify|verify} messages.
             * @function encode
             * @memberof search.proto.GeoBoundingBoxQuery
             * @static
             * @param {search.proto.IGeoBoundingBoxQuery} message GeoBoundingBoxQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GeoBoundingBoxQuery.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fieldName != null && Object.hasOwnProperty.call(message, "fieldName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fieldName);
                if (message.topLeft != null && Object.hasOwnProperty.call(message, "topLeft"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.topLeft);
                if (message.bottomRight != null && Object.hasOwnProperty.call(message, "bottomRight"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.bottomRight);
                return writer;
            };

            /**
             * Encodes the specified GeoBoundingBoxQuery message, length delimited. Does not implicitly {@link search.proto.GeoBoundingBoxQuery.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.GeoBoundingBoxQuery
             * @static
             * @param {search.proto.IGeoBoundingBoxQuery} message GeoBoundingBoxQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GeoBoundingBoxQuery.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GeoBoundingBoxQuery message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.GeoBoundingBoxQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.GeoBoundingBoxQuery} GeoBoundingBoxQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GeoBoundingBoxQuery.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.GeoBoundingBoxQuery();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fieldName = reader.string();
                        break;
                    case 2:
                        message.topLeft = reader.string();
                        break;
                    case 3:
                        message.bottomRight = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GeoBoundingBoxQuery message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.GeoBoundingBoxQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.GeoBoundingBoxQuery} GeoBoundingBoxQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GeoBoundingBoxQuery.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GeoBoundingBoxQuery message.
             * @function verify
             * @memberof search.proto.GeoBoundingBoxQuery
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GeoBoundingBoxQuery.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    if (!$util.isString(message.fieldName))
                        return "fieldName: string expected";
                if (message.topLeft != null && message.hasOwnProperty("topLeft"))
                    if (!$util.isString(message.topLeft))
                        return "topLeft: string expected";
                if (message.bottomRight != null && message.hasOwnProperty("bottomRight"))
                    if (!$util.isString(message.bottomRight))
                        return "bottomRight: string expected";
                return null;
            };

            /**
             * Creates a GeoBoundingBoxQuery message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.GeoBoundingBoxQuery
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.GeoBoundingBoxQuery} GeoBoundingBoxQuery
             */
            GeoBoundingBoxQuery.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.GeoBoundingBoxQuery)
                    return object;
                var message = new $root.search.proto.GeoBoundingBoxQuery();
                if (object.fieldName != null)
                    message.fieldName = String(object.fieldName);
                if (object.topLeft != null)
                    message.topLeft = String(object.topLeft);
                if (object.bottomRight != null)
                    message.bottomRight = String(object.bottomRight);
                return message;
            };

            /**
             * Creates a plain object from a GeoBoundingBoxQuery message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.GeoBoundingBoxQuery
             * @static
             * @param {search.proto.GeoBoundingBoxQuery} message GeoBoundingBoxQuery
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GeoBoundingBoxQuery.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.fieldName = "";
                    object.topLeft = "";
                    object.bottomRight = "";
                }
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    object.fieldName = message.fieldName;
                if (message.topLeft != null && message.hasOwnProperty("topLeft"))
                    object.topLeft = message.topLeft;
                if (message.bottomRight != null && message.hasOwnProperty("bottomRight"))
                    object.bottomRight = message.bottomRight;
                return object;
            };

            /**
             * Converts this GeoBoundingBoxQuery to JSON.
             * @function toJSON
             * @memberof search.proto.GeoBoundingBoxQuery
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GeoBoundingBoxQuery.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GeoBoundingBoxQuery;
        })();

        proto.GeoDistanceQuery = (function() {

            /**
             * Properties of a GeoDistanceQuery.
             * @memberof search.proto
             * @interface IGeoDistanceQuery
             * @property {string|null} [fieldName] GeoDistanceQuery fieldName
             * @property {string|null} [centerPoint] GeoDistanceQuery centerPoint
             * @property {number|null} [distance] GeoDistanceQuery distance
             */

            /**
             * Constructs a new GeoDistanceQuery.
             * @memberof search.proto
             * @classdesc Represents a GeoDistanceQuery.
             * @implements IGeoDistanceQuery
             * @constructor
             * @param {search.proto.IGeoDistanceQuery=} [properties] Properties to set
             */
            function GeoDistanceQuery(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GeoDistanceQuery fieldName.
             * @member {string} fieldName
             * @memberof search.proto.GeoDistanceQuery
             * @instance
             */
            GeoDistanceQuery.prototype.fieldName = "";

            /**
             * GeoDistanceQuery centerPoint.
             * @member {string} centerPoint
             * @memberof search.proto.GeoDistanceQuery
             * @instance
             */
            GeoDistanceQuery.prototype.centerPoint = "";

            /**
             * GeoDistanceQuery distance.
             * @member {number} distance
             * @memberof search.proto.GeoDistanceQuery
             * @instance
             */
            GeoDistanceQuery.prototype.distance = 0;

            /**
             * Creates a new GeoDistanceQuery instance using the specified properties.
             * @function create
             * @memberof search.proto.GeoDistanceQuery
             * @static
             * @param {search.proto.IGeoDistanceQuery=} [properties] Properties to set
             * @returns {search.proto.GeoDistanceQuery} GeoDistanceQuery instance
             */
            GeoDistanceQuery.create = function create(properties) {
                return new GeoDistanceQuery(properties);
            };

            /**
             * Encodes the specified GeoDistanceQuery message. Does not implicitly {@link search.proto.GeoDistanceQuery.verify|verify} messages.
             * @function encode
             * @memberof search.proto.GeoDistanceQuery
             * @static
             * @param {search.proto.IGeoDistanceQuery} message GeoDistanceQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GeoDistanceQuery.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fieldName != null && Object.hasOwnProperty.call(message, "fieldName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fieldName);
                if (message.centerPoint != null && Object.hasOwnProperty.call(message, "centerPoint"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.centerPoint);
                if (message.distance != null && Object.hasOwnProperty.call(message, "distance"))
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.distance);
                return writer;
            };

            /**
             * Encodes the specified GeoDistanceQuery message, length delimited. Does not implicitly {@link search.proto.GeoDistanceQuery.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.GeoDistanceQuery
             * @static
             * @param {search.proto.IGeoDistanceQuery} message GeoDistanceQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GeoDistanceQuery.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GeoDistanceQuery message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.GeoDistanceQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.GeoDistanceQuery} GeoDistanceQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GeoDistanceQuery.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.GeoDistanceQuery();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fieldName = reader.string();
                        break;
                    case 2:
                        message.centerPoint = reader.string();
                        break;
                    case 3:
                        message.distance = reader.double();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GeoDistanceQuery message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.GeoDistanceQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.GeoDistanceQuery} GeoDistanceQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GeoDistanceQuery.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GeoDistanceQuery message.
             * @function verify
             * @memberof search.proto.GeoDistanceQuery
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GeoDistanceQuery.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    if (!$util.isString(message.fieldName))
                        return "fieldName: string expected";
                if (message.centerPoint != null && message.hasOwnProperty("centerPoint"))
                    if (!$util.isString(message.centerPoint))
                        return "centerPoint: string expected";
                if (message.distance != null && message.hasOwnProperty("distance"))
                    if (typeof message.distance !== "number")
                        return "distance: number expected";
                return null;
            };

            /**
             * Creates a GeoDistanceQuery message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.GeoDistanceQuery
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.GeoDistanceQuery} GeoDistanceQuery
             */
            GeoDistanceQuery.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.GeoDistanceQuery)
                    return object;
                var message = new $root.search.proto.GeoDistanceQuery();
                if (object.fieldName != null)
                    message.fieldName = String(object.fieldName);
                if (object.centerPoint != null)
                    message.centerPoint = String(object.centerPoint);
                if (object.distance != null)
                    message.distance = Number(object.distance);
                return message;
            };

            /**
             * Creates a plain object from a GeoDistanceQuery message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.GeoDistanceQuery
             * @static
             * @param {search.proto.GeoDistanceQuery} message GeoDistanceQuery
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GeoDistanceQuery.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.fieldName = "";
                    object.centerPoint = "";
                    object.distance = 0;
                }
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    object.fieldName = message.fieldName;
                if (message.centerPoint != null && message.hasOwnProperty("centerPoint"))
                    object.centerPoint = message.centerPoint;
                if (message.distance != null && message.hasOwnProperty("distance"))
                    object.distance = options.json && !isFinite(message.distance) ? String(message.distance) : message.distance;
                return object;
            };

            /**
             * Converts this GeoDistanceQuery to JSON.
             * @function toJSON
             * @memberof search.proto.GeoDistanceQuery
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GeoDistanceQuery.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GeoDistanceQuery;
        })();

        proto.GeoPolygonQuery = (function() {

            /**
             * Properties of a GeoPolygonQuery.
             * @memberof search.proto
             * @interface IGeoPolygonQuery
             * @property {string|null} [fieldName] GeoPolygonQuery fieldName
             * @property {Array.<string>|null} [points] GeoPolygonQuery points
             */

            /**
             * Constructs a new GeoPolygonQuery.
             * @memberof search.proto
             * @classdesc Represents a GeoPolygonQuery.
             * @implements IGeoPolygonQuery
             * @constructor
             * @param {search.proto.IGeoPolygonQuery=} [properties] Properties to set
             */
            function GeoPolygonQuery(properties) {
                this.points = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GeoPolygonQuery fieldName.
             * @member {string} fieldName
             * @memberof search.proto.GeoPolygonQuery
             * @instance
             */
            GeoPolygonQuery.prototype.fieldName = "";

            /**
             * GeoPolygonQuery points.
             * @member {Array.<string>} points
             * @memberof search.proto.GeoPolygonQuery
             * @instance
             */
            GeoPolygonQuery.prototype.points = $util.emptyArray;

            /**
             * Creates a new GeoPolygonQuery instance using the specified properties.
             * @function create
             * @memberof search.proto.GeoPolygonQuery
             * @static
             * @param {search.proto.IGeoPolygonQuery=} [properties] Properties to set
             * @returns {search.proto.GeoPolygonQuery} GeoPolygonQuery instance
             */
            GeoPolygonQuery.create = function create(properties) {
                return new GeoPolygonQuery(properties);
            };

            /**
             * Encodes the specified GeoPolygonQuery message. Does not implicitly {@link search.proto.GeoPolygonQuery.verify|verify} messages.
             * @function encode
             * @memberof search.proto.GeoPolygonQuery
             * @static
             * @param {search.proto.IGeoPolygonQuery} message GeoPolygonQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GeoPolygonQuery.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fieldName != null && Object.hasOwnProperty.call(message, "fieldName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fieldName);
                if (message.points != null && message.points.length)
                    for (var i = 0; i < message.points.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.points[i]);
                return writer;
            };

            /**
             * Encodes the specified GeoPolygonQuery message, length delimited. Does not implicitly {@link search.proto.GeoPolygonQuery.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.GeoPolygonQuery
             * @static
             * @param {search.proto.IGeoPolygonQuery} message GeoPolygonQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GeoPolygonQuery.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GeoPolygonQuery message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.GeoPolygonQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.GeoPolygonQuery} GeoPolygonQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GeoPolygonQuery.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.GeoPolygonQuery();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fieldName = reader.string();
                        break;
                    case 2:
                        if (!(message.points && message.points.length))
                            message.points = [];
                        message.points.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GeoPolygonQuery message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.GeoPolygonQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.GeoPolygonQuery} GeoPolygonQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GeoPolygonQuery.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GeoPolygonQuery message.
             * @function verify
             * @memberof search.proto.GeoPolygonQuery
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GeoPolygonQuery.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    if (!$util.isString(message.fieldName))
                        return "fieldName: string expected";
                if (message.points != null && message.hasOwnProperty("points")) {
                    if (!Array.isArray(message.points))
                        return "points: array expected";
                    for (var i = 0; i < message.points.length; ++i)
                        if (!$util.isString(message.points[i]))
                            return "points: string[] expected";
                }
                return null;
            };

            /**
             * Creates a GeoPolygonQuery message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.GeoPolygonQuery
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.GeoPolygonQuery} GeoPolygonQuery
             */
            GeoPolygonQuery.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.GeoPolygonQuery)
                    return object;
                var message = new $root.search.proto.GeoPolygonQuery();
                if (object.fieldName != null)
                    message.fieldName = String(object.fieldName);
                if (object.points) {
                    if (!Array.isArray(object.points))
                        throw TypeError(".search.proto.GeoPolygonQuery.points: array expected");
                    message.points = [];
                    for (var i = 0; i < object.points.length; ++i)
                        message.points[i] = String(object.points[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a GeoPolygonQuery message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.GeoPolygonQuery
             * @static
             * @param {search.proto.GeoPolygonQuery} message GeoPolygonQuery
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GeoPolygonQuery.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.points = [];
                if (options.defaults)
                    object.fieldName = "";
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    object.fieldName = message.fieldName;
                if (message.points && message.points.length) {
                    object.points = [];
                    for (var j = 0; j < message.points.length; ++j)
                        object.points[j] = message.points[j];
                }
                return object;
            };

            /**
             * Converts this GeoPolygonQuery to JSON.
             * @function toJSON
             * @memberof search.proto.GeoPolygonQuery
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GeoPolygonQuery.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GeoPolygonQuery;
        })();

        proto.ExistsQuery = (function() {

            /**
             * Properties of an ExistsQuery.
             * @memberof search.proto
             * @interface IExistsQuery
             * @property {string|null} [fieldName] ExistsQuery fieldName
             */

            /**
             * Constructs a new ExistsQuery.
             * @memberof search.proto
             * @classdesc Represents an ExistsQuery.
             * @implements IExistsQuery
             * @constructor
             * @param {search.proto.IExistsQuery=} [properties] Properties to set
             */
            function ExistsQuery(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExistsQuery fieldName.
             * @member {string} fieldName
             * @memberof search.proto.ExistsQuery
             * @instance
             */
            ExistsQuery.prototype.fieldName = "";

            /**
             * Creates a new ExistsQuery instance using the specified properties.
             * @function create
             * @memberof search.proto.ExistsQuery
             * @static
             * @param {search.proto.IExistsQuery=} [properties] Properties to set
             * @returns {search.proto.ExistsQuery} ExistsQuery instance
             */
            ExistsQuery.create = function create(properties) {
                return new ExistsQuery(properties);
            };

            /**
             * Encodes the specified ExistsQuery message. Does not implicitly {@link search.proto.ExistsQuery.verify|verify} messages.
             * @function encode
             * @memberof search.proto.ExistsQuery
             * @static
             * @param {search.proto.IExistsQuery} message ExistsQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExistsQuery.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fieldName != null && Object.hasOwnProperty.call(message, "fieldName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fieldName);
                return writer;
            };

            /**
             * Encodes the specified ExistsQuery message, length delimited. Does not implicitly {@link search.proto.ExistsQuery.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.ExistsQuery
             * @static
             * @param {search.proto.IExistsQuery} message ExistsQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExistsQuery.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExistsQuery message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.ExistsQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.ExistsQuery} ExistsQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExistsQuery.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.ExistsQuery();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fieldName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExistsQuery message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.ExistsQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.ExistsQuery} ExistsQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExistsQuery.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExistsQuery message.
             * @function verify
             * @memberof search.proto.ExistsQuery
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExistsQuery.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    if (!$util.isString(message.fieldName))
                        return "fieldName: string expected";
                return null;
            };

            /**
             * Creates an ExistsQuery message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.ExistsQuery
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.ExistsQuery} ExistsQuery
             */
            ExistsQuery.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.ExistsQuery)
                    return object;
                var message = new $root.search.proto.ExistsQuery();
                if (object.fieldName != null)
                    message.fieldName = String(object.fieldName);
                return message;
            };

            /**
             * Creates a plain object from an ExistsQuery message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.ExistsQuery
             * @static
             * @param {search.proto.ExistsQuery} message ExistsQuery
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExistsQuery.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.fieldName = "";
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    object.fieldName = message.fieldName;
                return object;
            };

            /**
             * Converts this ExistsQuery to JSON.
             * @function toJSON
             * @memberof search.proto.ExistsQuery
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExistsQuery.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExistsQuery;
        })();

        proto.KnnVectorQuery = (function() {

            /**
             * Properties of a KnnVectorQuery.
             * @memberof search.proto
             * @interface IKnnVectorQuery
             * @property {string|null} [fieldName] KnnVectorQuery fieldName
             * @property {number|null} [topK] KnnVectorQuery topK
             * @property {Array.<number>|null} [float32QueryVector] KnnVectorQuery float32QueryVector
             * @property {search.proto.IQuery|null} [filter] KnnVectorQuery filter
             * @property {number|null} [weight] KnnVectorQuery weight
             */

            /**
             * Constructs a new KnnVectorQuery.
             * @memberof search.proto
             * @classdesc Represents a KnnVectorQuery.
             * @implements IKnnVectorQuery
             * @constructor
             * @param {search.proto.IKnnVectorQuery=} [properties] Properties to set
             */
            function KnnVectorQuery(properties) {
                this.float32QueryVector = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KnnVectorQuery fieldName.
             * @member {string} fieldName
             * @memberof search.proto.KnnVectorQuery
             * @instance
             */
            KnnVectorQuery.prototype.fieldName = "";

            /**
             * KnnVectorQuery topK.
             * @member {number} topK
             * @memberof search.proto.KnnVectorQuery
             * @instance
             */
            KnnVectorQuery.prototype.topK = 0;

            /**
             * KnnVectorQuery float32QueryVector.
             * @member {Array.<number>} float32QueryVector
             * @memberof search.proto.KnnVectorQuery
             * @instance
             */
            KnnVectorQuery.prototype.float32QueryVector = $util.emptyArray;

            /**
             * KnnVectorQuery filter.
             * @member {search.proto.IQuery|null|undefined} filter
             * @memberof search.proto.KnnVectorQuery
             * @instance
             */
            KnnVectorQuery.prototype.filter = null;

            /**
             * KnnVectorQuery weight.
             * @member {number} weight
             * @memberof search.proto.KnnVectorQuery
             * @instance
             */
            KnnVectorQuery.prototype.weight = 0;

            /**
             * Creates a new KnnVectorQuery instance using the specified properties.
             * @function create
             * @memberof search.proto.KnnVectorQuery
             * @static
             * @param {search.proto.IKnnVectorQuery=} [properties] Properties to set
             * @returns {search.proto.KnnVectorQuery} KnnVectorQuery instance
             */
            KnnVectorQuery.create = function create(properties) {
                return new KnnVectorQuery(properties);
            };

            /**
             * Encodes the specified KnnVectorQuery message. Does not implicitly {@link search.proto.KnnVectorQuery.verify|verify} messages.
             * @function encode
             * @memberof search.proto.KnnVectorQuery
             * @static
             * @param {search.proto.IKnnVectorQuery} message KnnVectorQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KnnVectorQuery.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fieldName != null && Object.hasOwnProperty.call(message, "fieldName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fieldName);
                if (message.topK != null && Object.hasOwnProperty.call(message, "topK"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.topK);
                if (message.float32QueryVector != null && message.float32QueryVector.length)
                    for (var i = 0; i < message.float32QueryVector.length; ++i)
                        writer.uint32(/* id 4, wireType 5 =*/37).float(message.float32QueryVector[i]);
                if (message.filter != null && Object.hasOwnProperty.call(message, "filter"))
                    $root.search.proto.Query.encode(message.filter, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.weight != null && Object.hasOwnProperty.call(message, "weight"))
                    writer.uint32(/* id 6, wireType 5 =*/53).float(message.weight);
                return writer;
            };

            /**
             * Encodes the specified KnnVectorQuery message, length delimited. Does not implicitly {@link search.proto.KnnVectorQuery.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.KnnVectorQuery
             * @static
             * @param {search.proto.IKnnVectorQuery} message KnnVectorQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KnnVectorQuery.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KnnVectorQuery message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.KnnVectorQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.KnnVectorQuery} KnnVectorQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KnnVectorQuery.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.KnnVectorQuery();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fieldName = reader.string();
                        break;
                    case 2:
                        message.topK = reader.int32();
                        break;
                    case 4:
                        if (!(message.float32QueryVector && message.float32QueryVector.length))
                            message.float32QueryVector = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.float32QueryVector.push(reader.float());
                        } else
                            message.float32QueryVector.push(reader.float());
                        break;
                    case 5:
                        message.filter = $root.search.proto.Query.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.weight = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KnnVectorQuery message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.KnnVectorQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.KnnVectorQuery} KnnVectorQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KnnVectorQuery.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KnnVectorQuery message.
             * @function verify
             * @memberof search.proto.KnnVectorQuery
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KnnVectorQuery.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    if (!$util.isString(message.fieldName))
                        return "fieldName: string expected";
                if (message.topK != null && message.hasOwnProperty("topK"))
                    if (!$util.isInteger(message.topK))
                        return "topK: integer expected";
                if (message.float32QueryVector != null && message.hasOwnProperty("float32QueryVector")) {
                    if (!Array.isArray(message.float32QueryVector))
                        return "float32QueryVector: array expected";
                    for (var i = 0; i < message.float32QueryVector.length; ++i)
                        if (typeof message.float32QueryVector[i] !== "number")
                            return "float32QueryVector: number[] expected";
                }
                if (message.filter != null && message.hasOwnProperty("filter")) {
                    var error = $root.search.proto.Query.verify(message.filter);
                    if (error)
                        return "filter." + error;
                }
                if (message.weight != null && message.hasOwnProperty("weight"))
                    if (typeof message.weight !== "number")
                        return "weight: number expected";
                return null;
            };

            /**
             * Creates a KnnVectorQuery message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.KnnVectorQuery
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.KnnVectorQuery} KnnVectorQuery
             */
            KnnVectorQuery.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.KnnVectorQuery)
                    return object;
                var message = new $root.search.proto.KnnVectorQuery();
                if (object.fieldName != null)
                    message.fieldName = String(object.fieldName);
                if (object.topK != null)
                    message.topK = object.topK | 0;
                if (object.float32QueryVector) {
                    if (!Array.isArray(object.float32QueryVector))
                        throw TypeError(".search.proto.KnnVectorQuery.float32QueryVector: array expected");
                    message.float32QueryVector = [];
                    for (var i = 0; i < object.float32QueryVector.length; ++i)
                        message.float32QueryVector[i] = Number(object.float32QueryVector[i]);
                }
                if (object.filter != null) {
                    if (typeof object.filter !== "object")
                        throw TypeError(".search.proto.KnnVectorQuery.filter: object expected");
                    message.filter = $root.search.proto.Query.fromObject(object.filter);
                }
                if (object.weight != null)
                    message.weight = Number(object.weight);
                return message;
            };

            /**
             * Creates a plain object from a KnnVectorQuery message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.KnnVectorQuery
             * @static
             * @param {search.proto.KnnVectorQuery} message KnnVectorQuery
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KnnVectorQuery.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.float32QueryVector = [];
                if (options.defaults) {
                    object.fieldName = "";
                    object.topK = 0;
                    object.filter = null;
                    object.weight = 0;
                }
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    object.fieldName = message.fieldName;
                if (message.topK != null && message.hasOwnProperty("topK"))
                    object.topK = message.topK;
                if (message.float32QueryVector && message.float32QueryVector.length) {
                    object.float32QueryVector = [];
                    for (var j = 0; j < message.float32QueryVector.length; ++j)
                        object.float32QueryVector[j] = options.json && !isFinite(message.float32QueryVector[j]) ? String(message.float32QueryVector[j]) : message.float32QueryVector[j];
                }
                if (message.filter != null && message.hasOwnProperty("filter"))
                    object.filter = $root.search.proto.Query.toObject(message.filter, options);
                if (message.weight != null && message.hasOwnProperty("weight"))
                    object.weight = options.json && !isFinite(message.weight) ? String(message.weight) : message.weight;
                return object;
            };

            /**
             * Converts this KnnVectorQuery to JSON.
             * @function toJSON
             * @memberof search.proto.KnnVectorQuery
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KnnVectorQuery.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KnnVectorQuery;
        })();

        proto.Query = (function() {

            /**
             * Properties of a Query.
             * @memberof search.proto
             * @interface IQuery
             * @property {search.proto.QueryType|null} [type] Query type
             * @property {Uint8Array|null} [query] Query query
             */

            /**
             * Constructs a new Query.
             * @memberof search.proto
             * @classdesc Represents a Query.
             * @implements IQuery
             * @constructor
             * @param {search.proto.IQuery=} [properties] Properties to set
             */
            function Query(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Query type.
             * @member {search.proto.QueryType} type
             * @memberof search.proto.Query
             * @instance
             */
            Query.prototype.type = 1;

            /**
             * Query query.
             * @member {Uint8Array} query
             * @memberof search.proto.Query
             * @instance
             */
            Query.prototype.query = $util.newBuffer([]);

            /**
             * Creates a new Query instance using the specified properties.
             * @function create
             * @memberof search.proto.Query
             * @static
             * @param {search.proto.IQuery=} [properties] Properties to set
             * @returns {search.proto.Query} Query instance
             */
            Query.create = function create(properties) {
                return new Query(properties);
            };

            /**
             * Encodes the specified Query message. Does not implicitly {@link search.proto.Query.verify|verify} messages.
             * @function encode
             * @memberof search.proto.Query
             * @static
             * @param {search.proto.IQuery} message Query message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Query.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.query != null && Object.hasOwnProperty.call(message, "query"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.query);
                return writer;
            };

            /**
             * Encodes the specified Query message, length delimited. Does not implicitly {@link search.proto.Query.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.Query
             * @static
             * @param {search.proto.IQuery} message Query message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Query.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Query message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.Query
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.Query} Query
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Query.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.Query();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.query = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Query message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.Query
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.Query} Query
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Query.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Query message.
             * @function verify
             * @memberof search.proto.Query
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Query.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                        break;
                    }
                if (message.query != null && message.hasOwnProperty("query"))
                    if (!(message.query && typeof message.query.length === "number" || $util.isString(message.query)))
                        return "query: buffer expected";
                return null;
            };

            /**
             * Creates a Query message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.Query
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.Query} Query
             */
            Query.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.Query)
                    return object;
                var message = new $root.search.proto.Query();
                switch (object.type) {
                case "MATCH_QUERY":
                case 1:
                    message.type = 1;
                    break;
                case "MATCH_PHRASE_QUERY":
                case 2:
                    message.type = 2;
                    break;
                case "TERM_QUERY":
                case 3:
                    message.type = 3;
                    break;
                case "RANGE_QUERY":
                case 4:
                    message.type = 4;
                    break;
                case "PREFIX_QUERY":
                case 5:
                    message.type = 5;
                    break;
                case "BOOL_QUERY":
                case 6:
                    message.type = 6;
                    break;
                case "CONST_SCORE_QUERY":
                case 7:
                    message.type = 7;
                    break;
                case "FUNCTION_SCORE_QUERY":
                case 8:
                    message.type = 8;
                    break;
                case "NESTED_QUERY":
                case 9:
                    message.type = 9;
                    break;
                case "WILDCARD_QUERY":
                case 10:
                    message.type = 10;
                    break;
                case "MATCH_ALL_QUERY":
                case 11:
                    message.type = 11;
                    break;
                case "GEO_BOUNDING_BOX_QUERY":
                case 12:
                    message.type = 12;
                    break;
                case "GEO_DISTANCE_QUERY":
                case 13:
                    message.type = 13;
                    break;
                case "GEO_POLYGON_QUERY":
                case 14:
                    message.type = 14;
                    break;
                case "TERMS_QUERY":
                case 15:
                    message.type = 15;
                    break;
                case "EXISTS_QUERY":
                case 16:
                    message.type = 16;
                    break;
                case "KNN_VECTOR_QUERY":
                case 17:
                    message.type = 17;
                    break;
                case "FUNCTIONS_SCORE_QUERY":
                case 18:
                    message.type = 18;
                    break;
                }
                if (object.query != null)
                    if (typeof object.query === "string")
                        $util.base64.decode(object.query, message.query = $util.newBuffer($util.base64.length(object.query)), 0);
                    else if (object.query.length)
                        message.query = object.query;
                return message;
            };

            /**
             * Creates a plain object from a Query message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.Query
             * @static
             * @param {search.proto.Query} message Query
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Query.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type = options.enums === String ? "MATCH_QUERY" : 1;
                    if (options.bytes === String)
                        object.query = "";
                    else {
                        object.query = [];
                        if (options.bytes !== Array)
                            object.query = $util.newBuffer(object.query);
                    }
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.search.proto.QueryType[message.type] : message.type;
                if (message.query != null && message.hasOwnProperty("query"))
                    object.query = options.bytes === String ? $util.base64.encode(message.query, 0, message.query.length) : options.bytes === Array ? Array.prototype.slice.call(message.query) : message.query;
                return object;
            };

            /**
             * Converts this Query to JSON.
             * @function toJSON
             * @memberof search.proto.Query
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Query.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Query;
        })();

        proto.Collapse = (function() {

            /**
             * Properties of a Collapse.
             * @memberof search.proto
             * @interface ICollapse
             * @property {string|null} [fieldName] Collapse fieldName
             */

            /**
             * Constructs a new Collapse.
             * @memberof search.proto
             * @classdesc Represents a Collapse.
             * @implements ICollapse
             * @constructor
             * @param {search.proto.ICollapse=} [properties] Properties to set
             */
            function Collapse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Collapse fieldName.
             * @member {string} fieldName
             * @memberof search.proto.Collapse
             * @instance
             */
            Collapse.prototype.fieldName = "";

            /**
             * Creates a new Collapse instance using the specified properties.
             * @function create
             * @memberof search.proto.Collapse
             * @static
             * @param {search.proto.ICollapse=} [properties] Properties to set
             * @returns {search.proto.Collapse} Collapse instance
             */
            Collapse.create = function create(properties) {
                return new Collapse(properties);
            };

            /**
             * Encodes the specified Collapse message. Does not implicitly {@link search.proto.Collapse.verify|verify} messages.
             * @function encode
             * @memberof search.proto.Collapse
             * @static
             * @param {search.proto.ICollapse} message Collapse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Collapse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fieldName != null && Object.hasOwnProperty.call(message, "fieldName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fieldName);
                return writer;
            };

            /**
             * Encodes the specified Collapse message, length delimited. Does not implicitly {@link search.proto.Collapse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.Collapse
             * @static
             * @param {search.proto.ICollapse} message Collapse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Collapse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Collapse message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.Collapse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.Collapse} Collapse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Collapse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.Collapse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fieldName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Collapse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.Collapse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.Collapse} Collapse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Collapse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Collapse message.
             * @function verify
             * @memberof search.proto.Collapse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Collapse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    if (!$util.isString(message.fieldName))
                        return "fieldName: string expected";
                return null;
            };

            /**
             * Creates a Collapse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.Collapse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.Collapse} Collapse
             */
            Collapse.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.Collapse)
                    return object;
                var message = new $root.search.proto.Collapse();
                if (object.fieldName != null)
                    message.fieldName = String(object.fieldName);
                return message;
            };

            /**
             * Creates a plain object from a Collapse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.Collapse
             * @static
             * @param {search.proto.Collapse} message Collapse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Collapse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.fieldName = "";
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    object.fieldName = message.fieldName;
                return object;
            };

            /**
             * Converts this Collapse to JSON.
             * @function toJSON
             * @memberof search.proto.Collapse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Collapse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Collapse;
        })();

        proto.NestedFilter = (function() {

            /**
             * Properties of a NestedFilter.
             * @memberof search.proto
             * @interface INestedFilter
             * @property {string|null} [path] NestedFilter path
             * @property {search.proto.IQuery|null} [filter] NestedFilter filter
             */

            /**
             * Constructs a new NestedFilter.
             * @memberof search.proto
             * @classdesc Represents a NestedFilter.
             * @implements INestedFilter
             * @constructor
             * @param {search.proto.INestedFilter=} [properties] Properties to set
             */
            function NestedFilter(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NestedFilter path.
             * @member {string} path
             * @memberof search.proto.NestedFilter
             * @instance
             */
            NestedFilter.prototype.path = "";

            /**
             * NestedFilter filter.
             * @member {search.proto.IQuery|null|undefined} filter
             * @memberof search.proto.NestedFilter
             * @instance
             */
            NestedFilter.prototype.filter = null;

            /**
             * Creates a new NestedFilter instance using the specified properties.
             * @function create
             * @memberof search.proto.NestedFilter
             * @static
             * @param {search.proto.INestedFilter=} [properties] Properties to set
             * @returns {search.proto.NestedFilter} NestedFilter instance
             */
            NestedFilter.create = function create(properties) {
                return new NestedFilter(properties);
            };

            /**
             * Encodes the specified NestedFilter message. Does not implicitly {@link search.proto.NestedFilter.verify|verify} messages.
             * @function encode
             * @memberof search.proto.NestedFilter
             * @static
             * @param {search.proto.INestedFilter} message NestedFilter message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NestedFilter.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.path != null && Object.hasOwnProperty.call(message, "path"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.path);
                if (message.filter != null && Object.hasOwnProperty.call(message, "filter"))
                    $root.search.proto.Query.encode(message.filter, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified NestedFilter message, length delimited. Does not implicitly {@link search.proto.NestedFilter.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.NestedFilter
             * @static
             * @param {search.proto.INestedFilter} message NestedFilter message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NestedFilter.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NestedFilter message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.NestedFilter
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.NestedFilter} NestedFilter
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NestedFilter.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.NestedFilter();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.path = reader.string();
                        break;
                    case 2:
                        message.filter = $root.search.proto.Query.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NestedFilter message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.NestedFilter
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.NestedFilter} NestedFilter
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NestedFilter.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NestedFilter message.
             * @function verify
             * @memberof search.proto.NestedFilter
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NestedFilter.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                if (message.filter != null && message.hasOwnProperty("filter")) {
                    var error = $root.search.proto.Query.verify(message.filter);
                    if (error)
                        return "filter." + error;
                }
                return null;
            };

            /**
             * Creates a NestedFilter message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.NestedFilter
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.NestedFilter} NestedFilter
             */
            NestedFilter.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.NestedFilter)
                    return object;
                var message = new $root.search.proto.NestedFilter();
                if (object.path != null)
                    message.path = String(object.path);
                if (object.filter != null) {
                    if (typeof object.filter !== "object")
                        throw TypeError(".search.proto.NestedFilter.filter: object expected");
                    message.filter = $root.search.proto.Query.fromObject(object.filter);
                }
                return message;
            };

            /**
             * Creates a plain object from a NestedFilter message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.NestedFilter
             * @static
             * @param {search.proto.NestedFilter} message NestedFilter
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NestedFilter.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.path = "";
                    object.filter = null;
                }
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                if (message.filter != null && message.hasOwnProperty("filter"))
                    object.filter = $root.search.proto.Query.toObject(message.filter, options);
                return object;
            };

            /**
             * Converts this NestedFilter to JSON.
             * @function toJSON
             * @memberof search.proto.NestedFilter
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NestedFilter.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NestedFilter;
        })();

        /**
         * SortOrder enum.
         * @name search.proto.SortOrder
         * @enum {number}
         * @property {number} SORT_ORDER_ASC=0 SORT_ORDER_ASC value
         * @property {number} SORT_ORDER_DESC=1 SORT_ORDER_DESC value
         */
        proto.SortOrder = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SORT_ORDER_ASC"] = 0;
            values[valuesById[1] = "SORT_ORDER_DESC"] = 1;
            return values;
        })();

        /**
         * SortMode enum.
         * @name search.proto.SortMode
         * @enum {number}
         * @property {number} SORT_MODE_MIN=0 SORT_MODE_MIN value
         * @property {number} SORT_MODE_MAX=1 SORT_MODE_MAX value
         * @property {number} SORT_MODE_AVG=2 SORT_MODE_AVG value
         */
        proto.SortMode = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SORT_MODE_MIN"] = 0;
            values[valuesById[1] = "SORT_MODE_MAX"] = 1;
            values[valuesById[2] = "SORT_MODE_AVG"] = 2;
            return values;
        })();

        proto.ScoreSort = (function() {

            /**
             * Properties of a ScoreSort.
             * @memberof search.proto
             * @interface IScoreSort
             * @property {search.proto.SortOrder|null} [order] ScoreSort order
             */

            /**
             * Constructs a new ScoreSort.
             * @memberof search.proto
             * @classdesc Represents a ScoreSort.
             * @implements IScoreSort
             * @constructor
             * @param {search.proto.IScoreSort=} [properties] Properties to set
             */
            function ScoreSort(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ScoreSort order.
             * @member {search.proto.SortOrder} order
             * @memberof search.proto.ScoreSort
             * @instance
             */
            ScoreSort.prototype.order = 0;

            /**
             * Creates a new ScoreSort instance using the specified properties.
             * @function create
             * @memberof search.proto.ScoreSort
             * @static
             * @param {search.proto.IScoreSort=} [properties] Properties to set
             * @returns {search.proto.ScoreSort} ScoreSort instance
             */
            ScoreSort.create = function create(properties) {
                return new ScoreSort(properties);
            };

            /**
             * Encodes the specified ScoreSort message. Does not implicitly {@link search.proto.ScoreSort.verify|verify} messages.
             * @function encode
             * @memberof search.proto.ScoreSort
             * @static
             * @param {search.proto.IScoreSort} message ScoreSort message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ScoreSort.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.order != null && Object.hasOwnProperty.call(message, "order"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.order);
                return writer;
            };

            /**
             * Encodes the specified ScoreSort message, length delimited. Does not implicitly {@link search.proto.ScoreSort.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.ScoreSort
             * @static
             * @param {search.proto.IScoreSort} message ScoreSort message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ScoreSort.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ScoreSort message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.ScoreSort
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.ScoreSort} ScoreSort
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ScoreSort.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.ScoreSort();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.order = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ScoreSort message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.ScoreSort
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.ScoreSort} ScoreSort
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ScoreSort.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ScoreSort message.
             * @function verify
             * @memberof search.proto.ScoreSort
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ScoreSort.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.order != null && message.hasOwnProperty("order"))
                    switch (message.order) {
                    default:
                        return "order: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };

            /**
             * Creates a ScoreSort message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.ScoreSort
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.ScoreSort} ScoreSort
             */
            ScoreSort.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.ScoreSort)
                    return object;
                var message = new $root.search.proto.ScoreSort();
                switch (object.order) {
                case "SORT_ORDER_ASC":
                case 0:
                    message.order = 0;
                    break;
                case "SORT_ORDER_DESC":
                case 1:
                    message.order = 1;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a ScoreSort message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.ScoreSort
             * @static
             * @param {search.proto.ScoreSort} message ScoreSort
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ScoreSort.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.order = options.enums === String ? "SORT_ORDER_ASC" : 0;
                if (message.order != null && message.hasOwnProperty("order"))
                    object.order = options.enums === String ? $root.search.proto.SortOrder[message.order] : message.order;
                return object;
            };

            /**
             * Converts this ScoreSort to JSON.
             * @function toJSON
             * @memberof search.proto.ScoreSort
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ScoreSort.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ScoreSort;
        })();

        proto.FieldSort = (function() {

            /**
             * Properties of a FieldSort.
             * @memberof search.proto
             * @interface IFieldSort
             * @property {string|null} [fieldName] FieldSort fieldName
             * @property {search.proto.SortOrder|null} [order] FieldSort order
             * @property {search.proto.SortMode|null} [mode] FieldSort mode
             * @property {search.proto.INestedFilter|null} [nestedFilter] FieldSort nestedFilter
             * @property {Uint8Array|null} [missingValue] FieldSort missingValue
             * @property {string|null} [missingField] FieldSort missingField
             */

            /**
             * Constructs a new FieldSort.
             * @memberof search.proto
             * @classdesc Represents a FieldSort.
             * @implements IFieldSort
             * @constructor
             * @param {search.proto.IFieldSort=} [properties] Properties to set
             */
            function FieldSort(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FieldSort fieldName.
             * @member {string} fieldName
             * @memberof search.proto.FieldSort
             * @instance
             */
            FieldSort.prototype.fieldName = "";

            /**
             * FieldSort order.
             * @member {search.proto.SortOrder} order
             * @memberof search.proto.FieldSort
             * @instance
             */
            FieldSort.prototype.order = 0;

            /**
             * FieldSort mode.
             * @member {search.proto.SortMode} mode
             * @memberof search.proto.FieldSort
             * @instance
             */
            FieldSort.prototype.mode = 0;

            /**
             * FieldSort nestedFilter.
             * @member {search.proto.INestedFilter|null|undefined} nestedFilter
             * @memberof search.proto.FieldSort
             * @instance
             */
            FieldSort.prototype.nestedFilter = null;

            /**
             * FieldSort missingValue.
             * @member {Uint8Array} missingValue
             * @memberof search.proto.FieldSort
             * @instance
             */
            FieldSort.prototype.missingValue = $util.newBuffer([]);

            /**
             * FieldSort missingField.
             * @member {string} missingField
             * @memberof search.proto.FieldSort
             * @instance
             */
            FieldSort.prototype.missingField = "";

            /**
             * Creates a new FieldSort instance using the specified properties.
             * @function create
             * @memberof search.proto.FieldSort
             * @static
             * @param {search.proto.IFieldSort=} [properties] Properties to set
             * @returns {search.proto.FieldSort} FieldSort instance
             */
            FieldSort.create = function create(properties) {
                return new FieldSort(properties);
            };

            /**
             * Encodes the specified FieldSort message. Does not implicitly {@link search.proto.FieldSort.verify|verify} messages.
             * @function encode
             * @memberof search.proto.FieldSort
             * @static
             * @param {search.proto.IFieldSort} message FieldSort message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldSort.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fieldName != null && Object.hasOwnProperty.call(message, "fieldName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fieldName);
                if (message.order != null && Object.hasOwnProperty.call(message, "order"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.order);
                if (message.mode != null && Object.hasOwnProperty.call(message, "mode"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.mode);
                if (message.nestedFilter != null && Object.hasOwnProperty.call(message, "nestedFilter"))
                    $root.search.proto.NestedFilter.encode(message.nestedFilter, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.missingValue != null && Object.hasOwnProperty.call(message, "missingValue"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.missingValue);
                if (message.missingField != null && Object.hasOwnProperty.call(message, "missingField"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.missingField);
                return writer;
            };

            /**
             * Encodes the specified FieldSort message, length delimited. Does not implicitly {@link search.proto.FieldSort.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.FieldSort
             * @static
             * @param {search.proto.IFieldSort} message FieldSort message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldSort.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FieldSort message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.FieldSort
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.FieldSort} FieldSort
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldSort.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.FieldSort();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fieldName = reader.string();
                        break;
                    case 2:
                        message.order = reader.int32();
                        break;
                    case 3:
                        message.mode = reader.int32();
                        break;
                    case 4:
                        message.nestedFilter = $root.search.proto.NestedFilter.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.missingValue = reader.bytes();
                        break;
                    case 6:
                        message.missingField = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FieldSort message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.FieldSort
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.FieldSort} FieldSort
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldSort.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FieldSort message.
             * @function verify
             * @memberof search.proto.FieldSort
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FieldSort.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    if (!$util.isString(message.fieldName))
                        return "fieldName: string expected";
                if (message.order != null && message.hasOwnProperty("order"))
                    switch (message.order) {
                    default:
                        return "order: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.mode != null && message.hasOwnProperty("mode"))
                    switch (message.mode) {
                    default:
                        return "mode: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.nestedFilter != null && message.hasOwnProperty("nestedFilter")) {
                    var error = $root.search.proto.NestedFilter.verify(message.nestedFilter);
                    if (error)
                        return "nestedFilter." + error;
                }
                if (message.missingValue != null && message.hasOwnProperty("missingValue"))
                    if (!(message.missingValue && typeof message.missingValue.length === "number" || $util.isString(message.missingValue)))
                        return "missingValue: buffer expected";
                if (message.missingField != null && message.hasOwnProperty("missingField"))
                    if (!$util.isString(message.missingField))
                        return "missingField: string expected";
                return null;
            };

            /**
             * Creates a FieldSort message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.FieldSort
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.FieldSort} FieldSort
             */
            FieldSort.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.FieldSort)
                    return object;
                var message = new $root.search.proto.FieldSort();
                if (object.fieldName != null)
                    message.fieldName = String(object.fieldName);
                switch (object.order) {
                case "SORT_ORDER_ASC":
                case 0:
                    message.order = 0;
                    break;
                case "SORT_ORDER_DESC":
                case 1:
                    message.order = 1;
                    break;
                }
                switch (object.mode) {
                case "SORT_MODE_MIN":
                case 0:
                    message.mode = 0;
                    break;
                case "SORT_MODE_MAX":
                case 1:
                    message.mode = 1;
                    break;
                case "SORT_MODE_AVG":
                case 2:
                    message.mode = 2;
                    break;
                }
                if (object.nestedFilter != null) {
                    if (typeof object.nestedFilter !== "object")
                        throw TypeError(".search.proto.FieldSort.nestedFilter: object expected");
                    message.nestedFilter = $root.search.proto.NestedFilter.fromObject(object.nestedFilter);
                }
                if (object.missingValue != null)
                    if (typeof object.missingValue === "string")
                        $util.base64.decode(object.missingValue, message.missingValue = $util.newBuffer($util.base64.length(object.missingValue)), 0);
                    else if (object.missingValue.length)
                        message.missingValue = object.missingValue;
                if (object.missingField != null)
                    message.missingField = String(object.missingField);
                return message;
            };

            /**
             * Creates a plain object from a FieldSort message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.FieldSort
             * @static
             * @param {search.proto.FieldSort} message FieldSort
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FieldSort.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.fieldName = "";
                    object.order = options.enums === String ? "SORT_ORDER_ASC" : 0;
                    object.mode = options.enums === String ? "SORT_MODE_MIN" : 0;
                    object.nestedFilter = null;
                    if (options.bytes === String)
                        object.missingValue = "";
                    else {
                        object.missingValue = [];
                        if (options.bytes !== Array)
                            object.missingValue = $util.newBuffer(object.missingValue);
                    }
                    object.missingField = "";
                }
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    object.fieldName = message.fieldName;
                if (message.order != null && message.hasOwnProperty("order"))
                    object.order = options.enums === String ? $root.search.proto.SortOrder[message.order] : message.order;
                if (message.mode != null && message.hasOwnProperty("mode"))
                    object.mode = options.enums === String ? $root.search.proto.SortMode[message.mode] : message.mode;
                if (message.nestedFilter != null && message.hasOwnProperty("nestedFilter"))
                    object.nestedFilter = $root.search.proto.NestedFilter.toObject(message.nestedFilter, options);
                if (message.missingValue != null && message.hasOwnProperty("missingValue"))
                    object.missingValue = options.bytes === String ? $util.base64.encode(message.missingValue, 0, message.missingValue.length) : options.bytes === Array ? Array.prototype.slice.call(message.missingValue) : message.missingValue;
                if (message.missingField != null && message.hasOwnProperty("missingField"))
                    object.missingField = message.missingField;
                return object;
            };

            /**
             * Converts this FieldSort to JSON.
             * @function toJSON
             * @memberof search.proto.FieldSort
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FieldSort.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FieldSort;
        })();

        proto.DocSort = (function() {

            /**
             * Properties of a DocSort.
             * @memberof search.proto
             * @interface IDocSort
             * @property {search.proto.SortOrder|null} [order] DocSort order
             */

            /**
             * Constructs a new DocSort.
             * @memberof search.proto
             * @classdesc Represents a DocSort.
             * @implements IDocSort
             * @constructor
             * @param {search.proto.IDocSort=} [properties] Properties to set
             */
            function DocSort(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DocSort order.
             * @member {search.proto.SortOrder} order
             * @memberof search.proto.DocSort
             * @instance
             */
            DocSort.prototype.order = 0;

            /**
             * Creates a new DocSort instance using the specified properties.
             * @function create
             * @memberof search.proto.DocSort
             * @static
             * @param {search.proto.IDocSort=} [properties] Properties to set
             * @returns {search.proto.DocSort} DocSort instance
             */
            DocSort.create = function create(properties) {
                return new DocSort(properties);
            };

            /**
             * Encodes the specified DocSort message. Does not implicitly {@link search.proto.DocSort.verify|verify} messages.
             * @function encode
             * @memberof search.proto.DocSort
             * @static
             * @param {search.proto.IDocSort} message DocSort message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DocSort.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.order != null && Object.hasOwnProperty.call(message, "order"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.order);
                return writer;
            };

            /**
             * Encodes the specified DocSort message, length delimited. Does not implicitly {@link search.proto.DocSort.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.DocSort
             * @static
             * @param {search.proto.IDocSort} message DocSort message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DocSort.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DocSort message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.DocSort
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.DocSort} DocSort
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DocSort.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.DocSort();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.order = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DocSort message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.DocSort
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.DocSort} DocSort
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DocSort.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DocSort message.
             * @function verify
             * @memberof search.proto.DocSort
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DocSort.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.order != null && message.hasOwnProperty("order"))
                    switch (message.order) {
                    default:
                        return "order: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };

            /**
             * Creates a DocSort message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.DocSort
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.DocSort} DocSort
             */
            DocSort.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.DocSort)
                    return object;
                var message = new $root.search.proto.DocSort();
                switch (object.order) {
                case "SORT_ORDER_ASC":
                case 0:
                    message.order = 0;
                    break;
                case "SORT_ORDER_DESC":
                case 1:
                    message.order = 1;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a DocSort message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.DocSort
             * @static
             * @param {search.proto.DocSort} message DocSort
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DocSort.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.order = options.enums === String ? "SORT_ORDER_ASC" : 0;
                if (message.order != null && message.hasOwnProperty("order"))
                    object.order = options.enums === String ? $root.search.proto.SortOrder[message.order] : message.order;
                return object;
            };

            /**
             * Converts this DocSort to JSON.
             * @function toJSON
             * @memberof search.proto.DocSort
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DocSort.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DocSort;
        })();

        /**
         * GeoDistanceType enum.
         * @name search.proto.GeoDistanceType
         * @enum {number}
         * @property {number} GEO_DISTANCE_ARC=0 GEO_DISTANCE_ARC value
         * @property {number} GEO_DISTANCE_PLANE=1 GEO_DISTANCE_PLANE value
         */
        proto.GeoDistanceType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "GEO_DISTANCE_ARC"] = 0;
            values[valuesById[1] = "GEO_DISTANCE_PLANE"] = 1;
            return values;
        })();

        proto.GeoDistanceSort = (function() {

            /**
             * Properties of a GeoDistanceSort.
             * @memberof search.proto
             * @interface IGeoDistanceSort
             * @property {string|null} [fieldName] GeoDistanceSort fieldName
             * @property {Array.<string>|null} [points] GeoDistanceSort points
             * @property {search.proto.SortOrder|null} [order] GeoDistanceSort order
             * @property {search.proto.SortMode|null} [mode] GeoDistanceSort mode
             * @property {search.proto.GeoDistanceType|null} [distanceType] GeoDistanceSort distanceType
             * @property {search.proto.INestedFilter|null} [nestedFilter] GeoDistanceSort nestedFilter
             */

            /**
             * Constructs a new GeoDistanceSort.
             * @memberof search.proto
             * @classdesc Represents a GeoDistanceSort.
             * @implements IGeoDistanceSort
             * @constructor
             * @param {search.proto.IGeoDistanceSort=} [properties] Properties to set
             */
            function GeoDistanceSort(properties) {
                this.points = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GeoDistanceSort fieldName.
             * @member {string} fieldName
             * @memberof search.proto.GeoDistanceSort
             * @instance
             */
            GeoDistanceSort.prototype.fieldName = "";

            /**
             * GeoDistanceSort points.
             * @member {Array.<string>} points
             * @memberof search.proto.GeoDistanceSort
             * @instance
             */
            GeoDistanceSort.prototype.points = $util.emptyArray;

            /**
             * GeoDistanceSort order.
             * @member {search.proto.SortOrder} order
             * @memberof search.proto.GeoDistanceSort
             * @instance
             */
            GeoDistanceSort.prototype.order = 0;

            /**
             * GeoDistanceSort mode.
             * @member {search.proto.SortMode} mode
             * @memberof search.proto.GeoDistanceSort
             * @instance
             */
            GeoDistanceSort.prototype.mode = 0;

            /**
             * GeoDistanceSort distanceType.
             * @member {search.proto.GeoDistanceType} distanceType
             * @memberof search.proto.GeoDistanceSort
             * @instance
             */
            GeoDistanceSort.prototype.distanceType = 0;

            /**
             * GeoDistanceSort nestedFilter.
             * @member {search.proto.INestedFilter|null|undefined} nestedFilter
             * @memberof search.proto.GeoDistanceSort
             * @instance
             */
            GeoDistanceSort.prototype.nestedFilter = null;

            /**
             * Creates a new GeoDistanceSort instance using the specified properties.
             * @function create
             * @memberof search.proto.GeoDistanceSort
             * @static
             * @param {search.proto.IGeoDistanceSort=} [properties] Properties to set
             * @returns {search.proto.GeoDistanceSort} GeoDistanceSort instance
             */
            GeoDistanceSort.create = function create(properties) {
                return new GeoDistanceSort(properties);
            };

            /**
             * Encodes the specified GeoDistanceSort message. Does not implicitly {@link search.proto.GeoDistanceSort.verify|verify} messages.
             * @function encode
             * @memberof search.proto.GeoDistanceSort
             * @static
             * @param {search.proto.IGeoDistanceSort} message GeoDistanceSort message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GeoDistanceSort.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fieldName != null && Object.hasOwnProperty.call(message, "fieldName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fieldName);
                if (message.points != null && message.points.length)
                    for (var i = 0; i < message.points.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.points[i]);
                if (message.order != null && Object.hasOwnProperty.call(message, "order"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.order);
                if (message.mode != null && Object.hasOwnProperty.call(message, "mode"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.mode);
                if (message.distanceType != null && Object.hasOwnProperty.call(message, "distanceType"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.distanceType);
                if (message.nestedFilter != null && Object.hasOwnProperty.call(message, "nestedFilter"))
                    $root.search.proto.NestedFilter.encode(message.nestedFilter, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GeoDistanceSort message, length delimited. Does not implicitly {@link search.proto.GeoDistanceSort.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.GeoDistanceSort
             * @static
             * @param {search.proto.IGeoDistanceSort} message GeoDistanceSort message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GeoDistanceSort.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GeoDistanceSort message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.GeoDistanceSort
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.GeoDistanceSort} GeoDistanceSort
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GeoDistanceSort.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.GeoDistanceSort();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fieldName = reader.string();
                        break;
                    case 2:
                        if (!(message.points && message.points.length))
                            message.points = [];
                        message.points.push(reader.string());
                        break;
                    case 3:
                        message.order = reader.int32();
                        break;
                    case 4:
                        message.mode = reader.int32();
                        break;
                    case 5:
                        message.distanceType = reader.int32();
                        break;
                    case 6:
                        message.nestedFilter = $root.search.proto.NestedFilter.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GeoDistanceSort message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.GeoDistanceSort
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.GeoDistanceSort} GeoDistanceSort
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GeoDistanceSort.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GeoDistanceSort message.
             * @function verify
             * @memberof search.proto.GeoDistanceSort
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GeoDistanceSort.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    if (!$util.isString(message.fieldName))
                        return "fieldName: string expected";
                if (message.points != null && message.hasOwnProperty("points")) {
                    if (!Array.isArray(message.points))
                        return "points: array expected";
                    for (var i = 0; i < message.points.length; ++i)
                        if (!$util.isString(message.points[i]))
                            return "points: string[] expected";
                }
                if (message.order != null && message.hasOwnProperty("order"))
                    switch (message.order) {
                    default:
                        return "order: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.mode != null && message.hasOwnProperty("mode"))
                    switch (message.mode) {
                    default:
                        return "mode: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.distanceType != null && message.hasOwnProperty("distanceType"))
                    switch (message.distanceType) {
                    default:
                        return "distanceType: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.nestedFilter != null && message.hasOwnProperty("nestedFilter")) {
                    var error = $root.search.proto.NestedFilter.verify(message.nestedFilter);
                    if (error)
                        return "nestedFilter." + error;
                }
                return null;
            };

            /**
             * Creates a GeoDistanceSort message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.GeoDistanceSort
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.GeoDistanceSort} GeoDistanceSort
             */
            GeoDistanceSort.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.GeoDistanceSort)
                    return object;
                var message = new $root.search.proto.GeoDistanceSort();
                if (object.fieldName != null)
                    message.fieldName = String(object.fieldName);
                if (object.points) {
                    if (!Array.isArray(object.points))
                        throw TypeError(".search.proto.GeoDistanceSort.points: array expected");
                    message.points = [];
                    for (var i = 0; i < object.points.length; ++i)
                        message.points[i] = String(object.points[i]);
                }
                switch (object.order) {
                case "SORT_ORDER_ASC":
                case 0:
                    message.order = 0;
                    break;
                case "SORT_ORDER_DESC":
                case 1:
                    message.order = 1;
                    break;
                }
                switch (object.mode) {
                case "SORT_MODE_MIN":
                case 0:
                    message.mode = 0;
                    break;
                case "SORT_MODE_MAX":
                case 1:
                    message.mode = 1;
                    break;
                case "SORT_MODE_AVG":
                case 2:
                    message.mode = 2;
                    break;
                }
                switch (object.distanceType) {
                case "GEO_DISTANCE_ARC":
                case 0:
                    message.distanceType = 0;
                    break;
                case "GEO_DISTANCE_PLANE":
                case 1:
                    message.distanceType = 1;
                    break;
                }
                if (object.nestedFilter != null) {
                    if (typeof object.nestedFilter !== "object")
                        throw TypeError(".search.proto.GeoDistanceSort.nestedFilter: object expected");
                    message.nestedFilter = $root.search.proto.NestedFilter.fromObject(object.nestedFilter);
                }
                return message;
            };

            /**
             * Creates a plain object from a GeoDistanceSort message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.GeoDistanceSort
             * @static
             * @param {search.proto.GeoDistanceSort} message GeoDistanceSort
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GeoDistanceSort.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.points = [];
                if (options.defaults) {
                    object.fieldName = "";
                    object.order = options.enums === String ? "SORT_ORDER_ASC" : 0;
                    object.mode = options.enums === String ? "SORT_MODE_MIN" : 0;
                    object.distanceType = options.enums === String ? "GEO_DISTANCE_ARC" : 0;
                    object.nestedFilter = null;
                }
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    object.fieldName = message.fieldName;
                if (message.points && message.points.length) {
                    object.points = [];
                    for (var j = 0; j < message.points.length; ++j)
                        object.points[j] = message.points[j];
                }
                if (message.order != null && message.hasOwnProperty("order"))
                    object.order = options.enums === String ? $root.search.proto.SortOrder[message.order] : message.order;
                if (message.mode != null && message.hasOwnProperty("mode"))
                    object.mode = options.enums === String ? $root.search.proto.SortMode[message.mode] : message.mode;
                if (message.distanceType != null && message.hasOwnProperty("distanceType"))
                    object.distanceType = options.enums === String ? $root.search.proto.GeoDistanceType[message.distanceType] : message.distanceType;
                if (message.nestedFilter != null && message.hasOwnProperty("nestedFilter"))
                    object.nestedFilter = $root.search.proto.NestedFilter.toObject(message.nestedFilter, options);
                return object;
            };

            /**
             * Converts this GeoDistanceSort to JSON.
             * @function toJSON
             * @memberof search.proto.GeoDistanceSort
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GeoDistanceSort.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GeoDistanceSort;
        })();

        proto.PrimaryKeySort = (function() {

            /**
             * Properties of a PrimaryKeySort.
             * @memberof search.proto
             * @interface IPrimaryKeySort
             * @property {search.proto.SortOrder|null} [order] PrimaryKeySort order
             */

            /**
             * Constructs a new PrimaryKeySort.
             * @memberof search.proto
             * @classdesc Represents a PrimaryKeySort.
             * @implements IPrimaryKeySort
             * @constructor
             * @param {search.proto.IPrimaryKeySort=} [properties] Properties to set
             */
            function PrimaryKeySort(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PrimaryKeySort order.
             * @member {search.proto.SortOrder} order
             * @memberof search.proto.PrimaryKeySort
             * @instance
             */
            PrimaryKeySort.prototype.order = 0;

            /**
             * Creates a new PrimaryKeySort instance using the specified properties.
             * @function create
             * @memberof search.proto.PrimaryKeySort
             * @static
             * @param {search.proto.IPrimaryKeySort=} [properties] Properties to set
             * @returns {search.proto.PrimaryKeySort} PrimaryKeySort instance
             */
            PrimaryKeySort.create = function create(properties) {
                return new PrimaryKeySort(properties);
            };

            /**
             * Encodes the specified PrimaryKeySort message. Does not implicitly {@link search.proto.PrimaryKeySort.verify|verify} messages.
             * @function encode
             * @memberof search.proto.PrimaryKeySort
             * @static
             * @param {search.proto.IPrimaryKeySort} message PrimaryKeySort message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PrimaryKeySort.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.order != null && Object.hasOwnProperty.call(message, "order"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.order);
                return writer;
            };

            /**
             * Encodes the specified PrimaryKeySort message, length delimited. Does not implicitly {@link search.proto.PrimaryKeySort.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.PrimaryKeySort
             * @static
             * @param {search.proto.IPrimaryKeySort} message PrimaryKeySort message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PrimaryKeySort.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PrimaryKeySort message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.PrimaryKeySort
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.PrimaryKeySort} PrimaryKeySort
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PrimaryKeySort.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.PrimaryKeySort();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.order = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PrimaryKeySort message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.PrimaryKeySort
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.PrimaryKeySort} PrimaryKeySort
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PrimaryKeySort.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PrimaryKeySort message.
             * @function verify
             * @memberof search.proto.PrimaryKeySort
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PrimaryKeySort.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.order != null && message.hasOwnProperty("order"))
                    switch (message.order) {
                    default:
                        return "order: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };

            /**
             * Creates a PrimaryKeySort message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.PrimaryKeySort
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.PrimaryKeySort} PrimaryKeySort
             */
            PrimaryKeySort.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.PrimaryKeySort)
                    return object;
                var message = new $root.search.proto.PrimaryKeySort();
                switch (object.order) {
                case "SORT_ORDER_ASC":
                case 0:
                    message.order = 0;
                    break;
                case "SORT_ORDER_DESC":
                case 1:
                    message.order = 1;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a PrimaryKeySort message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.PrimaryKeySort
             * @static
             * @param {search.proto.PrimaryKeySort} message PrimaryKeySort
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PrimaryKeySort.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.order = options.enums === String ? "SORT_ORDER_ASC" : 0;
                if (message.order != null && message.hasOwnProperty("order"))
                    object.order = options.enums === String ? $root.search.proto.SortOrder[message.order] : message.order;
                return object;
            };

            /**
             * Converts this PrimaryKeySort to JSON.
             * @function toJSON
             * @memberof search.proto.PrimaryKeySort
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PrimaryKeySort.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PrimaryKeySort;
        })();

        proto.Sorter = (function() {

            /**
             * Properties of a Sorter.
             * @memberof search.proto
             * @interface ISorter
             * @property {search.proto.IFieldSort|null} [fieldSort] Sorter fieldSort
             * @property {search.proto.IGeoDistanceSort|null} [geoDistanceSort] Sorter geoDistanceSort
             * @property {search.proto.IScoreSort|null} [scoreSort] Sorter scoreSort
             * @property {search.proto.IPrimaryKeySort|null} [pkSort] Sorter pkSort
             * @property {search.proto.IDocSort|null} [docSort] Sorter docSort
             */

            /**
             * Constructs a new Sorter.
             * @memberof search.proto
             * @classdesc Represents a Sorter.
             * @implements ISorter
             * @constructor
             * @param {search.proto.ISorter=} [properties] Properties to set
             */
            function Sorter(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Sorter fieldSort.
             * @member {search.proto.IFieldSort|null|undefined} fieldSort
             * @memberof search.proto.Sorter
             * @instance
             */
            Sorter.prototype.fieldSort = null;

            /**
             * Sorter geoDistanceSort.
             * @member {search.proto.IGeoDistanceSort|null|undefined} geoDistanceSort
             * @memberof search.proto.Sorter
             * @instance
             */
            Sorter.prototype.geoDistanceSort = null;

            /**
             * Sorter scoreSort.
             * @member {search.proto.IScoreSort|null|undefined} scoreSort
             * @memberof search.proto.Sorter
             * @instance
             */
            Sorter.prototype.scoreSort = null;

            /**
             * Sorter pkSort.
             * @member {search.proto.IPrimaryKeySort|null|undefined} pkSort
             * @memberof search.proto.Sorter
             * @instance
             */
            Sorter.prototype.pkSort = null;

            /**
             * Sorter docSort.
             * @member {search.proto.IDocSort|null|undefined} docSort
             * @memberof search.proto.Sorter
             * @instance
             */
            Sorter.prototype.docSort = null;

            /**
             * Creates a new Sorter instance using the specified properties.
             * @function create
             * @memberof search.proto.Sorter
             * @static
             * @param {search.proto.ISorter=} [properties] Properties to set
             * @returns {search.proto.Sorter} Sorter instance
             */
            Sorter.create = function create(properties) {
                return new Sorter(properties);
            };

            /**
             * Encodes the specified Sorter message. Does not implicitly {@link search.proto.Sorter.verify|verify} messages.
             * @function encode
             * @memberof search.proto.Sorter
             * @static
             * @param {search.proto.ISorter} message Sorter message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Sorter.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fieldSort != null && Object.hasOwnProperty.call(message, "fieldSort"))
                    $root.search.proto.FieldSort.encode(message.fieldSort, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.geoDistanceSort != null && Object.hasOwnProperty.call(message, "geoDistanceSort"))
                    $root.search.proto.GeoDistanceSort.encode(message.geoDistanceSort, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.scoreSort != null && Object.hasOwnProperty.call(message, "scoreSort"))
                    $root.search.proto.ScoreSort.encode(message.scoreSort, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.pkSort != null && Object.hasOwnProperty.call(message, "pkSort"))
                    $root.search.proto.PrimaryKeySort.encode(message.pkSort, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.docSort != null && Object.hasOwnProperty.call(message, "docSort"))
                    $root.search.proto.DocSort.encode(message.docSort, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Sorter message, length delimited. Does not implicitly {@link search.proto.Sorter.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.Sorter
             * @static
             * @param {search.proto.ISorter} message Sorter message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Sorter.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Sorter message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.Sorter
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.Sorter} Sorter
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Sorter.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.Sorter();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fieldSort = $root.search.proto.FieldSort.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.geoDistanceSort = $root.search.proto.GeoDistanceSort.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.scoreSort = $root.search.proto.ScoreSort.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.pkSort = $root.search.proto.PrimaryKeySort.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.docSort = $root.search.proto.DocSort.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Sorter message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.Sorter
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.Sorter} Sorter
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Sorter.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Sorter message.
             * @function verify
             * @memberof search.proto.Sorter
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Sorter.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fieldSort != null && message.hasOwnProperty("fieldSort")) {
                    var error = $root.search.proto.FieldSort.verify(message.fieldSort);
                    if (error)
                        return "fieldSort." + error;
                }
                if (message.geoDistanceSort != null && message.hasOwnProperty("geoDistanceSort")) {
                    var error = $root.search.proto.GeoDistanceSort.verify(message.geoDistanceSort);
                    if (error)
                        return "geoDistanceSort." + error;
                }
                if (message.scoreSort != null && message.hasOwnProperty("scoreSort")) {
                    var error = $root.search.proto.ScoreSort.verify(message.scoreSort);
                    if (error)
                        return "scoreSort." + error;
                }
                if (message.pkSort != null && message.hasOwnProperty("pkSort")) {
                    var error = $root.search.proto.PrimaryKeySort.verify(message.pkSort);
                    if (error)
                        return "pkSort." + error;
                }
                if (message.docSort != null && message.hasOwnProperty("docSort")) {
                    var error = $root.search.proto.DocSort.verify(message.docSort);
                    if (error)
                        return "docSort." + error;
                }
                return null;
            };

            /**
             * Creates a Sorter message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.Sorter
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.Sorter} Sorter
             */
            Sorter.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.Sorter)
                    return object;
                var message = new $root.search.proto.Sorter();
                if (object.fieldSort != null) {
                    if (typeof object.fieldSort !== "object")
                        throw TypeError(".search.proto.Sorter.fieldSort: object expected");
                    message.fieldSort = $root.search.proto.FieldSort.fromObject(object.fieldSort);
                }
                if (object.geoDistanceSort != null) {
                    if (typeof object.geoDistanceSort !== "object")
                        throw TypeError(".search.proto.Sorter.geoDistanceSort: object expected");
                    message.geoDistanceSort = $root.search.proto.GeoDistanceSort.fromObject(object.geoDistanceSort);
                }
                if (object.scoreSort != null) {
                    if (typeof object.scoreSort !== "object")
                        throw TypeError(".search.proto.Sorter.scoreSort: object expected");
                    message.scoreSort = $root.search.proto.ScoreSort.fromObject(object.scoreSort);
                }
                if (object.pkSort != null) {
                    if (typeof object.pkSort !== "object")
                        throw TypeError(".search.proto.Sorter.pkSort: object expected");
                    message.pkSort = $root.search.proto.PrimaryKeySort.fromObject(object.pkSort);
                }
                if (object.docSort != null) {
                    if (typeof object.docSort !== "object")
                        throw TypeError(".search.proto.Sorter.docSort: object expected");
                    message.docSort = $root.search.proto.DocSort.fromObject(object.docSort);
                }
                return message;
            };

            /**
             * Creates a plain object from a Sorter message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.Sorter
             * @static
             * @param {search.proto.Sorter} message Sorter
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Sorter.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.fieldSort = null;
                    object.geoDistanceSort = null;
                    object.scoreSort = null;
                    object.pkSort = null;
                    object.docSort = null;
                }
                if (message.fieldSort != null && message.hasOwnProperty("fieldSort"))
                    object.fieldSort = $root.search.proto.FieldSort.toObject(message.fieldSort, options);
                if (message.geoDistanceSort != null && message.hasOwnProperty("geoDistanceSort"))
                    object.geoDistanceSort = $root.search.proto.GeoDistanceSort.toObject(message.geoDistanceSort, options);
                if (message.scoreSort != null && message.hasOwnProperty("scoreSort"))
                    object.scoreSort = $root.search.proto.ScoreSort.toObject(message.scoreSort, options);
                if (message.pkSort != null && message.hasOwnProperty("pkSort"))
                    object.pkSort = $root.search.proto.PrimaryKeySort.toObject(message.pkSort, options);
                if (message.docSort != null && message.hasOwnProperty("docSort"))
                    object.docSort = $root.search.proto.DocSort.toObject(message.docSort, options);
                return object;
            };

            /**
             * Converts this Sorter to JSON.
             * @function toJSON
             * @memberof search.proto.Sorter
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Sorter.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Sorter;
        })();

        proto.Sort = (function() {

            /**
             * Properties of a Sort.
             * @memberof search.proto
             * @interface ISort
             * @property {Array.<search.proto.ISorter>|null} [sorter] Sort sorter
             */

            /**
             * Constructs a new Sort.
             * @memberof search.proto
             * @classdesc Represents a Sort.
             * @implements ISort
             * @constructor
             * @param {search.proto.ISort=} [properties] Properties to set
             */
            function Sort(properties) {
                this.sorter = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Sort sorter.
             * @member {Array.<search.proto.ISorter>} sorter
             * @memberof search.proto.Sort
             * @instance
             */
            Sort.prototype.sorter = $util.emptyArray;

            /**
             * Creates a new Sort instance using the specified properties.
             * @function create
             * @memberof search.proto.Sort
             * @static
             * @param {search.proto.ISort=} [properties] Properties to set
             * @returns {search.proto.Sort} Sort instance
             */
            Sort.create = function create(properties) {
                return new Sort(properties);
            };

            /**
             * Encodes the specified Sort message. Does not implicitly {@link search.proto.Sort.verify|verify} messages.
             * @function encode
             * @memberof search.proto.Sort
             * @static
             * @param {search.proto.ISort} message Sort message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Sort.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sorter != null && message.sorter.length)
                    for (var i = 0; i < message.sorter.length; ++i)
                        $root.search.proto.Sorter.encode(message.sorter[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Sort message, length delimited. Does not implicitly {@link search.proto.Sort.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.Sort
             * @static
             * @param {search.proto.ISort} message Sort message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Sort.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Sort message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.Sort
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.Sort} Sort
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Sort.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.Sort();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.sorter && message.sorter.length))
                            message.sorter = [];
                        message.sorter.push($root.search.proto.Sorter.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Sort message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.Sort
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.Sort} Sort
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Sort.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Sort message.
             * @function verify
             * @memberof search.proto.Sort
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Sort.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sorter != null && message.hasOwnProperty("sorter")) {
                    if (!Array.isArray(message.sorter))
                        return "sorter: array expected";
                    for (var i = 0; i < message.sorter.length; ++i) {
                        var error = $root.search.proto.Sorter.verify(message.sorter[i]);
                        if (error)
                            return "sorter." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Sort message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.Sort
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.Sort} Sort
             */
            Sort.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.Sort)
                    return object;
                var message = new $root.search.proto.Sort();
                if (object.sorter) {
                    if (!Array.isArray(object.sorter))
                        throw TypeError(".search.proto.Sort.sorter: array expected");
                    message.sorter = [];
                    for (var i = 0; i < object.sorter.length; ++i) {
                        if (typeof object.sorter[i] !== "object")
                            throw TypeError(".search.proto.Sort.sorter: object expected");
                        message.sorter[i] = $root.search.proto.Sorter.fromObject(object.sorter[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Sort message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.Sort
             * @static
             * @param {search.proto.Sort} message Sort
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Sort.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.sorter = [];
                if (message.sorter && message.sorter.length) {
                    object.sorter = [];
                    for (var j = 0; j < message.sorter.length; ++j)
                        object.sorter[j] = $root.search.proto.Sorter.toObject(message.sorter[j], options);
                }
                return object;
            };

            /**
             * Converts this Sort to JSON.
             * @function toJSON
             * @memberof search.proto.Sort
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Sort.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Sort;
        })();

        proto.SearchQuery = (function() {

            /**
             * Properties of a SearchQuery.
             * @memberof search.proto
             * @interface ISearchQuery
             * @property {number|null} [offset] SearchQuery offset
             * @property {number|null} [limit] SearchQuery limit
             * @property {search.proto.IQuery|null} [query] SearchQuery query
             * @property {search.proto.ICollapse|null} [collapse] SearchQuery collapse
             * @property {search.proto.ISort|null} [sort] SearchQuery sort
             * @property {boolean|null} [getTotalCount] SearchQuery getTotalCount
             * @property {Uint8Array|null} [token] SearchQuery token
             * @property {search.proto.IAggregations|null} [aggs] SearchQuery aggs
             * @property {search.proto.IGroupBys|null} [groupBys] SearchQuery groupBys
             * @property {search.proto.IHighlight|null} [highlight] SearchQuery highlight
             */

            /**
             * Constructs a new SearchQuery.
             * @memberof search.proto
             * @classdesc Represents a SearchQuery.
             * @implements ISearchQuery
             * @constructor
             * @param {search.proto.ISearchQuery=} [properties] Properties to set
             */
            function SearchQuery(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SearchQuery offset.
             * @member {number} offset
             * @memberof search.proto.SearchQuery
             * @instance
             */
            SearchQuery.prototype.offset = 0;

            /**
             * SearchQuery limit.
             * @member {number} limit
             * @memberof search.proto.SearchQuery
             * @instance
             */
            SearchQuery.prototype.limit = 0;

            /**
             * SearchQuery query.
             * @member {search.proto.IQuery|null|undefined} query
             * @memberof search.proto.SearchQuery
             * @instance
             */
            SearchQuery.prototype.query = null;

            /**
             * SearchQuery collapse.
             * @member {search.proto.ICollapse|null|undefined} collapse
             * @memberof search.proto.SearchQuery
             * @instance
             */
            SearchQuery.prototype.collapse = null;

            /**
             * SearchQuery sort.
             * @member {search.proto.ISort|null|undefined} sort
             * @memberof search.proto.SearchQuery
             * @instance
             */
            SearchQuery.prototype.sort = null;

            /**
             * SearchQuery getTotalCount.
             * @member {boolean} getTotalCount
             * @memberof search.proto.SearchQuery
             * @instance
             */
            SearchQuery.prototype.getTotalCount = false;

            /**
             * SearchQuery token.
             * @member {Uint8Array} token
             * @memberof search.proto.SearchQuery
             * @instance
             */
            SearchQuery.prototype.token = $util.newBuffer([]);

            /**
             * SearchQuery aggs.
             * @member {search.proto.IAggregations|null|undefined} aggs
             * @memberof search.proto.SearchQuery
             * @instance
             */
            SearchQuery.prototype.aggs = null;

            /**
             * SearchQuery groupBys.
             * @member {search.proto.IGroupBys|null|undefined} groupBys
             * @memberof search.proto.SearchQuery
             * @instance
             */
            SearchQuery.prototype.groupBys = null;

            /**
             * SearchQuery highlight.
             * @member {search.proto.IHighlight|null|undefined} highlight
             * @memberof search.proto.SearchQuery
             * @instance
             */
            SearchQuery.prototype.highlight = null;

            /**
             * Creates a new SearchQuery instance using the specified properties.
             * @function create
             * @memberof search.proto.SearchQuery
             * @static
             * @param {search.proto.ISearchQuery=} [properties] Properties to set
             * @returns {search.proto.SearchQuery} SearchQuery instance
             */
            SearchQuery.create = function create(properties) {
                return new SearchQuery(properties);
            };

            /**
             * Encodes the specified SearchQuery message. Does not implicitly {@link search.proto.SearchQuery.verify|verify} messages.
             * @function encode
             * @memberof search.proto.SearchQuery
             * @static
             * @param {search.proto.ISearchQuery} message SearchQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SearchQuery.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.offset);
                if (message.limit != null && Object.hasOwnProperty.call(message, "limit"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.limit);
                if (message.query != null && Object.hasOwnProperty.call(message, "query"))
                    $root.search.proto.Query.encode(message.query, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.collapse != null && Object.hasOwnProperty.call(message, "collapse"))
                    $root.search.proto.Collapse.encode(message.collapse, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.sort != null && Object.hasOwnProperty.call(message, "sort"))
                    $root.search.proto.Sort.encode(message.sort, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.getTotalCount != null && Object.hasOwnProperty.call(message, "getTotalCount"))
                    writer.uint32(/* id 8, wireType 0 =*/64).bool(message.getTotalCount);
                if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                    writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.token);
                if (message.aggs != null && Object.hasOwnProperty.call(message, "aggs"))
                    $root.search.proto.Aggregations.encode(message.aggs, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.groupBys != null && Object.hasOwnProperty.call(message, "groupBys"))
                    $root.search.proto.GroupBys.encode(message.groupBys, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.highlight != null && Object.hasOwnProperty.call(message, "highlight"))
                    $root.search.proto.Highlight.encode(message.highlight, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SearchQuery message, length delimited. Does not implicitly {@link search.proto.SearchQuery.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.SearchQuery
             * @static
             * @param {search.proto.ISearchQuery} message SearchQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SearchQuery.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SearchQuery message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.SearchQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.SearchQuery} SearchQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SearchQuery.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.SearchQuery();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.offset = reader.int32();
                        break;
                    case 2:
                        message.limit = reader.int32();
                        break;
                    case 4:
                        message.query = $root.search.proto.Query.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.collapse = $root.search.proto.Collapse.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.sort = $root.search.proto.Sort.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.getTotalCount = reader.bool();
                        break;
                    case 9:
                        message.token = reader.bytes();
                        break;
                    case 10:
                        message.aggs = $root.search.proto.Aggregations.decode(reader, reader.uint32());
                        break;
                    case 11:
                        message.groupBys = $root.search.proto.GroupBys.decode(reader, reader.uint32());
                        break;
                    case 12:
                        message.highlight = $root.search.proto.Highlight.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SearchQuery message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.SearchQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.SearchQuery} SearchQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SearchQuery.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SearchQuery message.
             * @function verify
             * @memberof search.proto.SearchQuery
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SearchQuery.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.offset != null && message.hasOwnProperty("offset"))
                    if (!$util.isInteger(message.offset))
                        return "offset: integer expected";
                if (message.limit != null && message.hasOwnProperty("limit"))
                    if (!$util.isInteger(message.limit))
                        return "limit: integer expected";
                if (message.query != null && message.hasOwnProperty("query")) {
                    var error = $root.search.proto.Query.verify(message.query);
                    if (error)
                        return "query." + error;
                }
                if (message.collapse != null && message.hasOwnProperty("collapse")) {
                    var error = $root.search.proto.Collapse.verify(message.collapse);
                    if (error)
                        return "collapse." + error;
                }
                if (message.sort != null && message.hasOwnProperty("sort")) {
                    var error = $root.search.proto.Sort.verify(message.sort);
                    if (error)
                        return "sort." + error;
                }
                if (message.getTotalCount != null && message.hasOwnProperty("getTotalCount"))
                    if (typeof message.getTotalCount !== "boolean")
                        return "getTotalCount: boolean expected";
                if (message.token != null && message.hasOwnProperty("token"))
                    if (!(message.token && typeof message.token.length === "number" || $util.isString(message.token)))
                        return "token: buffer expected";
                if (message.aggs != null && message.hasOwnProperty("aggs")) {
                    var error = $root.search.proto.Aggregations.verify(message.aggs);
                    if (error)
                        return "aggs." + error;
                }
                if (message.groupBys != null && message.hasOwnProperty("groupBys")) {
                    var error = $root.search.proto.GroupBys.verify(message.groupBys);
                    if (error)
                        return "groupBys." + error;
                }
                if (message.highlight != null && message.hasOwnProperty("highlight")) {
                    var error = $root.search.proto.Highlight.verify(message.highlight);
                    if (error)
                        return "highlight." + error;
                }
                return null;
            };

            /**
             * Creates a SearchQuery message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.SearchQuery
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.SearchQuery} SearchQuery
             */
            SearchQuery.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.SearchQuery)
                    return object;
                var message = new $root.search.proto.SearchQuery();
                if (object.offset != null)
                    message.offset = object.offset | 0;
                if (object.limit != null)
                    message.limit = object.limit | 0;
                if (object.query != null) {
                    if (typeof object.query !== "object")
                        throw TypeError(".search.proto.SearchQuery.query: object expected");
                    message.query = $root.search.proto.Query.fromObject(object.query);
                }
                if (object.collapse != null) {
                    if (typeof object.collapse !== "object")
                        throw TypeError(".search.proto.SearchQuery.collapse: object expected");
                    message.collapse = $root.search.proto.Collapse.fromObject(object.collapse);
                }
                if (object.sort != null) {
                    if (typeof object.sort !== "object")
                        throw TypeError(".search.proto.SearchQuery.sort: object expected");
                    message.sort = $root.search.proto.Sort.fromObject(object.sort);
                }
                if (object.getTotalCount != null)
                    message.getTotalCount = Boolean(object.getTotalCount);
                if (object.token != null)
                    if (typeof object.token === "string")
                        $util.base64.decode(object.token, message.token = $util.newBuffer($util.base64.length(object.token)), 0);
                    else if (object.token.length)
                        message.token = object.token;
                if (object.aggs != null) {
                    if (typeof object.aggs !== "object")
                        throw TypeError(".search.proto.SearchQuery.aggs: object expected");
                    message.aggs = $root.search.proto.Aggregations.fromObject(object.aggs);
                }
                if (object.groupBys != null) {
                    if (typeof object.groupBys !== "object")
                        throw TypeError(".search.proto.SearchQuery.groupBys: object expected");
                    message.groupBys = $root.search.proto.GroupBys.fromObject(object.groupBys);
                }
                if (object.highlight != null) {
                    if (typeof object.highlight !== "object")
                        throw TypeError(".search.proto.SearchQuery.highlight: object expected");
                    message.highlight = $root.search.proto.Highlight.fromObject(object.highlight);
                }
                return message;
            };

            /**
             * Creates a plain object from a SearchQuery message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.SearchQuery
             * @static
             * @param {search.proto.SearchQuery} message SearchQuery
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SearchQuery.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.offset = 0;
                    object.limit = 0;
                    object.query = null;
                    object.collapse = null;
                    object.sort = null;
                    object.getTotalCount = false;
                    if (options.bytes === String)
                        object.token = "";
                    else {
                        object.token = [];
                        if (options.bytes !== Array)
                            object.token = $util.newBuffer(object.token);
                    }
                    object.aggs = null;
                    object.groupBys = null;
                    object.highlight = null;
                }
                if (message.offset != null && message.hasOwnProperty("offset"))
                    object.offset = message.offset;
                if (message.limit != null && message.hasOwnProperty("limit"))
                    object.limit = message.limit;
                if (message.query != null && message.hasOwnProperty("query"))
                    object.query = $root.search.proto.Query.toObject(message.query, options);
                if (message.collapse != null && message.hasOwnProperty("collapse"))
                    object.collapse = $root.search.proto.Collapse.toObject(message.collapse, options);
                if (message.sort != null && message.hasOwnProperty("sort"))
                    object.sort = $root.search.proto.Sort.toObject(message.sort, options);
                if (message.getTotalCount != null && message.hasOwnProperty("getTotalCount"))
                    object.getTotalCount = message.getTotalCount;
                if (message.token != null && message.hasOwnProperty("token"))
                    object.token = options.bytes === String ? $util.base64.encode(message.token, 0, message.token.length) : options.bytes === Array ? Array.prototype.slice.call(message.token) : message.token;
                if (message.aggs != null && message.hasOwnProperty("aggs"))
                    object.aggs = $root.search.proto.Aggregations.toObject(message.aggs, options);
                if (message.groupBys != null && message.hasOwnProperty("groupBys"))
                    object.groupBys = $root.search.proto.GroupBys.toObject(message.groupBys, options);
                if (message.highlight != null && message.hasOwnProperty("highlight"))
                    object.highlight = $root.search.proto.Highlight.toObject(message.highlight, options);
                return object;
            };

            /**
             * Converts this SearchQuery to JSON.
             * @function toJSON
             * @memberof search.proto.SearchQuery
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SearchQuery.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SearchQuery;
        })();

        proto.Highlight = (function() {

            /**
             * Properties of a Highlight.
             * @memberof search.proto
             * @interface IHighlight
             * @property {Array.<search.proto.IHighlightParameter>|null} [highlightParameters] Highlight highlightParameters
             * @property {search.proto.HighlightEncoder|null} [highlightEncoder] Highlight highlightEncoder
             */

            /**
             * Constructs a new Highlight.
             * @memberof search.proto
             * @classdesc Represents a Highlight.
             * @implements IHighlight
             * @constructor
             * @param {search.proto.IHighlight=} [properties] Properties to set
             */
            function Highlight(properties) {
                this.highlightParameters = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Highlight highlightParameters.
             * @member {Array.<search.proto.IHighlightParameter>} highlightParameters
             * @memberof search.proto.Highlight
             * @instance
             */
            Highlight.prototype.highlightParameters = $util.emptyArray;

            /**
             * Highlight highlightEncoder.
             * @member {search.proto.HighlightEncoder} highlightEncoder
             * @memberof search.proto.Highlight
             * @instance
             */
            Highlight.prototype.highlightEncoder = 1;

            /**
             * Creates a new Highlight instance using the specified properties.
             * @function create
             * @memberof search.proto.Highlight
             * @static
             * @param {search.proto.IHighlight=} [properties] Properties to set
             * @returns {search.proto.Highlight} Highlight instance
             */
            Highlight.create = function create(properties) {
                return new Highlight(properties);
            };

            /**
             * Encodes the specified Highlight message. Does not implicitly {@link search.proto.Highlight.verify|verify} messages.
             * @function encode
             * @memberof search.proto.Highlight
             * @static
             * @param {search.proto.IHighlight} message Highlight message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Highlight.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.highlightParameters != null && message.highlightParameters.length)
                    for (var i = 0; i < message.highlightParameters.length; ++i)
                        $root.search.proto.HighlightParameter.encode(message.highlightParameters[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.highlightEncoder != null && Object.hasOwnProperty.call(message, "highlightEncoder"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.highlightEncoder);
                return writer;
            };

            /**
             * Encodes the specified Highlight message, length delimited. Does not implicitly {@link search.proto.Highlight.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.Highlight
             * @static
             * @param {search.proto.IHighlight} message Highlight message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Highlight.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Highlight message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.Highlight
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.Highlight} Highlight
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Highlight.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.Highlight();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.highlightParameters && message.highlightParameters.length))
                            message.highlightParameters = [];
                        message.highlightParameters.push($root.search.proto.HighlightParameter.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.highlightEncoder = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Highlight message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.Highlight
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.Highlight} Highlight
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Highlight.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Highlight message.
             * @function verify
             * @memberof search.proto.Highlight
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Highlight.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.highlightParameters != null && message.hasOwnProperty("highlightParameters")) {
                    if (!Array.isArray(message.highlightParameters))
                        return "highlightParameters: array expected";
                    for (var i = 0; i < message.highlightParameters.length; ++i) {
                        var error = $root.search.proto.HighlightParameter.verify(message.highlightParameters[i]);
                        if (error)
                            return "highlightParameters." + error;
                    }
                }
                if (message.highlightEncoder != null && message.hasOwnProperty("highlightEncoder"))
                    switch (message.highlightEncoder) {
                    default:
                        return "highlightEncoder: enum value expected";
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };

            /**
             * Creates a Highlight message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.Highlight
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.Highlight} Highlight
             */
            Highlight.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.Highlight)
                    return object;
                var message = new $root.search.proto.Highlight();
                if (object.highlightParameters) {
                    if (!Array.isArray(object.highlightParameters))
                        throw TypeError(".search.proto.Highlight.highlightParameters: array expected");
                    message.highlightParameters = [];
                    for (var i = 0; i < object.highlightParameters.length; ++i) {
                        if (typeof object.highlightParameters[i] !== "object")
                            throw TypeError(".search.proto.Highlight.highlightParameters: object expected");
                        message.highlightParameters[i] = $root.search.proto.HighlightParameter.fromObject(object.highlightParameters[i]);
                    }
                }
                switch (object.highlightEncoder) {
                case "PLAIN_MODE":
                case 1:
                    message.highlightEncoder = 1;
                    break;
                case "HTML_MODE":
                case 2:
                    message.highlightEncoder = 2;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a Highlight message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.Highlight
             * @static
             * @param {search.proto.Highlight} message Highlight
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Highlight.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.highlightParameters = [];
                if (options.defaults)
                    object.highlightEncoder = options.enums === String ? "PLAIN_MODE" : 1;
                if (message.highlightParameters && message.highlightParameters.length) {
                    object.highlightParameters = [];
                    for (var j = 0; j < message.highlightParameters.length; ++j)
                        object.highlightParameters[j] = $root.search.proto.HighlightParameter.toObject(message.highlightParameters[j], options);
                }
                if (message.highlightEncoder != null && message.hasOwnProperty("highlightEncoder"))
                    object.highlightEncoder = options.enums === String ? $root.search.proto.HighlightEncoder[message.highlightEncoder] : message.highlightEncoder;
                return object;
            };

            /**
             * Converts this Highlight to JSON.
             * @function toJSON
             * @memberof search.proto.Highlight
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Highlight.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Highlight;
        })();

        proto.HighlightParameter = (function() {

            /**
             * Properties of a HighlightParameter.
             * @memberof search.proto
             * @interface IHighlightParameter
             * @property {string|null} [fieldName] HighlightParameter fieldName
             * @property {number|null} [numberOfFragments] HighlightParameter numberOfFragments
             * @property {number|null} [fragmentSize] HighlightParameter fragmentSize
             * @property {string|null} [preTag] HighlightParameter preTag
             * @property {string|null} [postTag] HighlightParameter postTag
             * @property {search.proto.HighlightFragmentOrder|null} [fragmentsOrder] HighlightParameter fragmentsOrder
             */

            /**
             * Constructs a new HighlightParameter.
             * @memberof search.proto
             * @classdesc Represents a HighlightParameter.
             * @implements IHighlightParameter
             * @constructor
             * @param {search.proto.IHighlightParameter=} [properties] Properties to set
             */
            function HighlightParameter(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * HighlightParameter fieldName.
             * @member {string} fieldName
             * @memberof search.proto.HighlightParameter
             * @instance
             */
            HighlightParameter.prototype.fieldName = "";

            /**
             * HighlightParameter numberOfFragments.
             * @member {number} numberOfFragments
             * @memberof search.proto.HighlightParameter
             * @instance
             */
            HighlightParameter.prototype.numberOfFragments = 0;

            /**
             * HighlightParameter fragmentSize.
             * @member {number} fragmentSize
             * @memberof search.proto.HighlightParameter
             * @instance
             */
            HighlightParameter.prototype.fragmentSize = 0;

            /**
             * HighlightParameter preTag.
             * @member {string} preTag
             * @memberof search.proto.HighlightParameter
             * @instance
             */
            HighlightParameter.prototype.preTag = "";

            /**
             * HighlightParameter postTag.
             * @member {string} postTag
             * @memberof search.proto.HighlightParameter
             * @instance
             */
            HighlightParameter.prototype.postTag = "";

            /**
             * HighlightParameter fragmentsOrder.
             * @member {search.proto.HighlightFragmentOrder} fragmentsOrder
             * @memberof search.proto.HighlightParameter
             * @instance
             */
            HighlightParameter.prototype.fragmentsOrder = 1;

            /**
             * Creates a new HighlightParameter instance using the specified properties.
             * @function create
             * @memberof search.proto.HighlightParameter
             * @static
             * @param {search.proto.IHighlightParameter=} [properties] Properties to set
             * @returns {search.proto.HighlightParameter} HighlightParameter instance
             */
            HighlightParameter.create = function create(properties) {
                return new HighlightParameter(properties);
            };

            /**
             * Encodes the specified HighlightParameter message. Does not implicitly {@link search.proto.HighlightParameter.verify|verify} messages.
             * @function encode
             * @memberof search.proto.HighlightParameter
             * @static
             * @param {search.proto.IHighlightParameter} message HighlightParameter message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HighlightParameter.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fieldName != null && Object.hasOwnProperty.call(message, "fieldName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fieldName);
                if (message.numberOfFragments != null && Object.hasOwnProperty.call(message, "numberOfFragments"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.numberOfFragments);
                if (message.fragmentSize != null && Object.hasOwnProperty.call(message, "fragmentSize"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.fragmentSize);
                if (message.preTag != null && Object.hasOwnProperty.call(message, "preTag"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.preTag);
                if (message.postTag != null && Object.hasOwnProperty.call(message, "postTag"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.postTag);
                if (message.fragmentsOrder != null && Object.hasOwnProperty.call(message, "fragmentsOrder"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.fragmentsOrder);
                return writer;
            };

            /**
             * Encodes the specified HighlightParameter message, length delimited. Does not implicitly {@link search.proto.HighlightParameter.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.HighlightParameter
             * @static
             * @param {search.proto.IHighlightParameter} message HighlightParameter message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HighlightParameter.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a HighlightParameter message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.HighlightParameter
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.HighlightParameter} HighlightParameter
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HighlightParameter.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.HighlightParameter();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fieldName = reader.string();
                        break;
                    case 2:
                        message.numberOfFragments = reader.int32();
                        break;
                    case 3:
                        message.fragmentSize = reader.int32();
                        break;
                    case 4:
                        message.preTag = reader.string();
                        break;
                    case 5:
                        message.postTag = reader.string();
                        break;
                    case 6:
                        message.fragmentsOrder = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a HighlightParameter message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.HighlightParameter
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.HighlightParameter} HighlightParameter
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HighlightParameter.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a HighlightParameter message.
             * @function verify
             * @memberof search.proto.HighlightParameter
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            HighlightParameter.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    if (!$util.isString(message.fieldName))
                        return "fieldName: string expected";
                if (message.numberOfFragments != null && message.hasOwnProperty("numberOfFragments"))
                    if (!$util.isInteger(message.numberOfFragments))
                        return "numberOfFragments: integer expected";
                if (message.fragmentSize != null && message.hasOwnProperty("fragmentSize"))
                    if (!$util.isInteger(message.fragmentSize))
                        return "fragmentSize: integer expected";
                if (message.preTag != null && message.hasOwnProperty("preTag"))
                    if (!$util.isString(message.preTag))
                        return "preTag: string expected";
                if (message.postTag != null && message.hasOwnProperty("postTag"))
                    if (!$util.isString(message.postTag))
                        return "postTag: string expected";
                if (message.fragmentsOrder != null && message.hasOwnProperty("fragmentsOrder"))
                    switch (message.fragmentsOrder) {
                    default:
                        return "fragmentsOrder: enum value expected";
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };

            /**
             * Creates a HighlightParameter message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.HighlightParameter
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.HighlightParameter} HighlightParameter
             */
            HighlightParameter.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.HighlightParameter)
                    return object;
                var message = new $root.search.proto.HighlightParameter();
                if (object.fieldName != null)
                    message.fieldName = String(object.fieldName);
                if (object.numberOfFragments != null)
                    message.numberOfFragments = object.numberOfFragments | 0;
                if (object.fragmentSize != null)
                    message.fragmentSize = object.fragmentSize | 0;
                if (object.preTag != null)
                    message.preTag = String(object.preTag);
                if (object.postTag != null)
                    message.postTag = String(object.postTag);
                switch (object.fragmentsOrder) {
                case "TEXT_SEQUENCE":
                case 1:
                    message.fragmentsOrder = 1;
                    break;
                case "SCORE":
                case 2:
                    message.fragmentsOrder = 2;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a HighlightParameter message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.HighlightParameter
             * @static
             * @param {search.proto.HighlightParameter} message HighlightParameter
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            HighlightParameter.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.fieldName = "";
                    object.numberOfFragments = 0;
                    object.fragmentSize = 0;
                    object.preTag = "";
                    object.postTag = "";
                    object.fragmentsOrder = options.enums === String ? "TEXT_SEQUENCE" : 1;
                }
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    object.fieldName = message.fieldName;
                if (message.numberOfFragments != null && message.hasOwnProperty("numberOfFragments"))
                    object.numberOfFragments = message.numberOfFragments;
                if (message.fragmentSize != null && message.hasOwnProperty("fragmentSize"))
                    object.fragmentSize = message.fragmentSize;
                if (message.preTag != null && message.hasOwnProperty("preTag"))
                    object.preTag = message.preTag;
                if (message.postTag != null && message.hasOwnProperty("postTag"))
                    object.postTag = message.postTag;
                if (message.fragmentsOrder != null && message.hasOwnProperty("fragmentsOrder"))
                    object.fragmentsOrder = options.enums === String ? $root.search.proto.HighlightFragmentOrder[message.fragmentsOrder] : message.fragmentsOrder;
                return object;
            };

            /**
             * Converts this HighlightParameter to JSON.
             * @function toJSON
             * @memberof search.proto.HighlightParameter
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            HighlightParameter.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return HighlightParameter;
        })();

        /**
         * HighlightFragmentOrder enum.
         * @name search.proto.HighlightFragmentOrder
         * @enum {number}
         * @property {number} TEXT_SEQUENCE=1 TEXT_SEQUENCE value
         * @property {number} SCORE=2 SCORE value
         */
        proto.HighlightFragmentOrder = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "TEXT_SEQUENCE"] = 1;
            values[valuesById[2] = "SCORE"] = 2;
            return values;
        })();

        /**
         * HighlightEncoder enum.
         * @name search.proto.HighlightEncoder
         * @enum {number}
         * @property {number} PLAIN_MODE=1 PLAIN_MODE value
         * @property {number} HTML_MODE=2 HTML_MODE value
         */
        proto.HighlightEncoder = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "PLAIN_MODE"] = 1;
            values[valuesById[2] = "HTML_MODE"] = 2;
            return values;
        })();

        /**
         * ColumnReturnType enum.
         * @name search.proto.ColumnReturnType
         * @enum {number}
         * @property {number} RETURN_ALL=1 RETURN_ALL value
         * @property {number} RETURN_SPECIFIED=2 RETURN_SPECIFIED value
         * @property {number} RETURN_NONE=3 RETURN_NONE value
         * @property {number} RETURN_ALL_FROM_INDEX=4 RETURN_ALL_FROM_INDEX value
         */
        proto.ColumnReturnType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "RETURN_ALL"] = 1;
            values[valuesById[2] = "RETURN_SPECIFIED"] = 2;
            values[valuesById[3] = "RETURN_NONE"] = 3;
            values[valuesById[4] = "RETURN_ALL_FROM_INDEX"] = 4;
            return values;
        })();

        proto.ColumnsToGet = (function() {

            /**
             * Properties of a ColumnsToGet.
             * @memberof search.proto
             * @interface IColumnsToGet
             * @property {search.proto.ColumnReturnType|null} [returnType] ColumnsToGet returnType
             * @property {Array.<string>|null} [columnNames] ColumnsToGet columnNames
             */

            /**
             * Constructs a new ColumnsToGet.
             * @memberof search.proto
             * @classdesc Represents a ColumnsToGet.
             * @implements IColumnsToGet
             * @constructor
             * @param {search.proto.IColumnsToGet=} [properties] Properties to set
             */
            function ColumnsToGet(properties) {
                this.columnNames = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ColumnsToGet returnType.
             * @member {search.proto.ColumnReturnType} returnType
             * @memberof search.proto.ColumnsToGet
             * @instance
             */
            ColumnsToGet.prototype.returnType = 1;

            /**
             * ColumnsToGet columnNames.
             * @member {Array.<string>} columnNames
             * @memberof search.proto.ColumnsToGet
             * @instance
             */
            ColumnsToGet.prototype.columnNames = $util.emptyArray;

            /**
             * Creates a new ColumnsToGet instance using the specified properties.
             * @function create
             * @memberof search.proto.ColumnsToGet
             * @static
             * @param {search.proto.IColumnsToGet=} [properties] Properties to set
             * @returns {search.proto.ColumnsToGet} ColumnsToGet instance
             */
            ColumnsToGet.create = function create(properties) {
                return new ColumnsToGet(properties);
            };

            /**
             * Encodes the specified ColumnsToGet message. Does not implicitly {@link search.proto.ColumnsToGet.verify|verify} messages.
             * @function encode
             * @memberof search.proto.ColumnsToGet
             * @static
             * @param {search.proto.IColumnsToGet} message ColumnsToGet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ColumnsToGet.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.returnType != null && Object.hasOwnProperty.call(message, "returnType"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.returnType);
                if (message.columnNames != null && message.columnNames.length)
                    for (var i = 0; i < message.columnNames.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.columnNames[i]);
                return writer;
            };

            /**
             * Encodes the specified ColumnsToGet message, length delimited. Does not implicitly {@link search.proto.ColumnsToGet.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.ColumnsToGet
             * @static
             * @param {search.proto.IColumnsToGet} message ColumnsToGet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ColumnsToGet.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ColumnsToGet message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.ColumnsToGet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.ColumnsToGet} ColumnsToGet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ColumnsToGet.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.ColumnsToGet();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.returnType = reader.int32();
                        break;
                    case 2:
                        if (!(message.columnNames && message.columnNames.length))
                            message.columnNames = [];
                        message.columnNames.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ColumnsToGet message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.ColumnsToGet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.ColumnsToGet} ColumnsToGet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ColumnsToGet.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ColumnsToGet message.
             * @function verify
             * @memberof search.proto.ColumnsToGet
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ColumnsToGet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.returnType != null && message.hasOwnProperty("returnType"))
                    switch (message.returnType) {
                    default:
                        return "returnType: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                if (message.columnNames != null && message.hasOwnProperty("columnNames")) {
                    if (!Array.isArray(message.columnNames))
                        return "columnNames: array expected";
                    for (var i = 0; i < message.columnNames.length; ++i)
                        if (!$util.isString(message.columnNames[i]))
                            return "columnNames: string[] expected";
                }
                return null;
            };

            /**
             * Creates a ColumnsToGet message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.ColumnsToGet
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.ColumnsToGet} ColumnsToGet
             */
            ColumnsToGet.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.ColumnsToGet)
                    return object;
                var message = new $root.search.proto.ColumnsToGet();
                switch (object.returnType) {
                case "RETURN_ALL":
                case 1:
                    message.returnType = 1;
                    break;
                case "RETURN_SPECIFIED":
                case 2:
                    message.returnType = 2;
                    break;
                case "RETURN_NONE":
                case 3:
                    message.returnType = 3;
                    break;
                case "RETURN_ALL_FROM_INDEX":
                case 4:
                    message.returnType = 4;
                    break;
                }
                if (object.columnNames) {
                    if (!Array.isArray(object.columnNames))
                        throw TypeError(".search.proto.ColumnsToGet.columnNames: array expected");
                    message.columnNames = [];
                    for (var i = 0; i < object.columnNames.length; ++i)
                        message.columnNames[i] = String(object.columnNames[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a ColumnsToGet message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.ColumnsToGet
             * @static
             * @param {search.proto.ColumnsToGet} message ColumnsToGet
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ColumnsToGet.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.columnNames = [];
                if (options.defaults)
                    object.returnType = options.enums === String ? "RETURN_ALL" : 1;
                if (message.returnType != null && message.hasOwnProperty("returnType"))
                    object.returnType = options.enums === String ? $root.search.proto.ColumnReturnType[message.returnType] : message.returnType;
                if (message.columnNames && message.columnNames.length) {
                    object.columnNames = [];
                    for (var j = 0; j < message.columnNames.length; ++j)
                        object.columnNames[j] = message.columnNames[j];
                }
                return object;
            };

            /**
             * Converts this ColumnsToGet to JSON.
             * @function toJSON
             * @memberof search.proto.ColumnsToGet
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ColumnsToGet.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ColumnsToGet;
        })();

        proto.SearchRequest = (function() {

            /**
             * Properties of a SearchRequest.
             * @memberof search.proto
             * @interface ISearchRequest
             * @property {string|null} [tableName] SearchRequest tableName
             * @property {string|null} [indexName] SearchRequest indexName
             * @property {search.proto.IColumnsToGet|null} [columnsToGet] SearchRequest columnsToGet
             * @property {Uint8Array|null} [searchQuery] SearchRequest searchQuery
             * @property {Array.<Uint8Array>|null} [routingValues] SearchRequest routingValues
             * @property {number|null} [timeoutMs] SearchRequest timeoutMs
             */

            /**
             * Constructs a new SearchRequest.
             * @memberof search.proto
             * @classdesc Represents a SearchRequest.
             * @implements ISearchRequest
             * @constructor
             * @param {search.proto.ISearchRequest=} [properties] Properties to set
             */
            function SearchRequest(properties) {
                this.routingValues = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SearchRequest tableName.
             * @member {string} tableName
             * @memberof search.proto.SearchRequest
             * @instance
             */
            SearchRequest.prototype.tableName = "";

            /**
             * SearchRequest indexName.
             * @member {string} indexName
             * @memberof search.proto.SearchRequest
             * @instance
             */
            SearchRequest.prototype.indexName = "";

            /**
             * SearchRequest columnsToGet.
             * @member {search.proto.IColumnsToGet|null|undefined} columnsToGet
             * @memberof search.proto.SearchRequest
             * @instance
             */
            SearchRequest.prototype.columnsToGet = null;

            /**
             * SearchRequest searchQuery.
             * @member {Uint8Array} searchQuery
             * @memberof search.proto.SearchRequest
             * @instance
             */
            SearchRequest.prototype.searchQuery = $util.newBuffer([]);

            /**
             * SearchRequest routingValues.
             * @member {Array.<Uint8Array>} routingValues
             * @memberof search.proto.SearchRequest
             * @instance
             */
            SearchRequest.prototype.routingValues = $util.emptyArray;

            /**
             * SearchRequest timeoutMs.
             * @member {number} timeoutMs
             * @memberof search.proto.SearchRequest
             * @instance
             */
            SearchRequest.prototype.timeoutMs = 0;

            /**
             * Creates a new SearchRequest instance using the specified properties.
             * @function create
             * @memberof search.proto.SearchRequest
             * @static
             * @param {search.proto.ISearchRequest=} [properties] Properties to set
             * @returns {search.proto.SearchRequest} SearchRequest instance
             */
            SearchRequest.create = function create(properties) {
                return new SearchRequest(properties);
            };

            /**
             * Encodes the specified SearchRequest message. Does not implicitly {@link search.proto.SearchRequest.verify|verify} messages.
             * @function encode
             * @memberof search.proto.SearchRequest
             * @static
             * @param {search.proto.ISearchRequest} message SearchRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SearchRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tableName != null && Object.hasOwnProperty.call(message, "tableName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.tableName);
                if (message.indexName != null && Object.hasOwnProperty.call(message, "indexName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.indexName);
                if (message.columnsToGet != null && Object.hasOwnProperty.call(message, "columnsToGet"))
                    $root.search.proto.ColumnsToGet.encode(message.columnsToGet, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.searchQuery != null && Object.hasOwnProperty.call(message, "searchQuery"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.searchQuery);
                if (message.routingValues != null && message.routingValues.length)
                    for (var i = 0; i < message.routingValues.length; ++i)
                        writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.routingValues[i]);
                if (message.timeoutMs != null && Object.hasOwnProperty.call(message, "timeoutMs"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.timeoutMs);
                return writer;
            };

            /**
             * Encodes the specified SearchRequest message, length delimited. Does not implicitly {@link search.proto.SearchRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.SearchRequest
             * @static
             * @param {search.proto.ISearchRequest} message SearchRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SearchRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SearchRequest message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.SearchRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.SearchRequest} SearchRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SearchRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.SearchRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tableName = reader.string();
                        break;
                    case 2:
                        message.indexName = reader.string();
                        break;
                    case 3:
                        message.columnsToGet = $root.search.proto.ColumnsToGet.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.searchQuery = reader.bytes();
                        break;
                    case 5:
                        if (!(message.routingValues && message.routingValues.length))
                            message.routingValues = [];
                        message.routingValues.push(reader.bytes());
                        break;
                    case 6:
                        message.timeoutMs = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SearchRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.SearchRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.SearchRequest} SearchRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SearchRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SearchRequest message.
             * @function verify
             * @memberof search.proto.SearchRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SearchRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tableName != null && message.hasOwnProperty("tableName"))
                    if (!$util.isString(message.tableName))
                        return "tableName: string expected";
                if (message.indexName != null && message.hasOwnProperty("indexName"))
                    if (!$util.isString(message.indexName))
                        return "indexName: string expected";
                if (message.columnsToGet != null && message.hasOwnProperty("columnsToGet")) {
                    var error = $root.search.proto.ColumnsToGet.verify(message.columnsToGet);
                    if (error)
                        return "columnsToGet." + error;
                }
                if (message.searchQuery != null && message.hasOwnProperty("searchQuery"))
                    if (!(message.searchQuery && typeof message.searchQuery.length === "number" || $util.isString(message.searchQuery)))
                        return "searchQuery: buffer expected";
                if (message.routingValues != null && message.hasOwnProperty("routingValues")) {
                    if (!Array.isArray(message.routingValues))
                        return "routingValues: array expected";
                    for (var i = 0; i < message.routingValues.length; ++i)
                        if (!(message.routingValues[i] && typeof message.routingValues[i].length === "number" || $util.isString(message.routingValues[i])))
                            return "routingValues: buffer[] expected";
                }
                if (message.timeoutMs != null && message.hasOwnProperty("timeoutMs"))
                    if (!$util.isInteger(message.timeoutMs))
                        return "timeoutMs: integer expected";
                return null;
            };

            /**
             * Creates a SearchRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.SearchRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.SearchRequest} SearchRequest
             */
            SearchRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.SearchRequest)
                    return object;
                var message = new $root.search.proto.SearchRequest();
                if (object.tableName != null)
                    message.tableName = String(object.tableName);
                if (object.indexName != null)
                    message.indexName = String(object.indexName);
                if (object.columnsToGet != null) {
                    if (typeof object.columnsToGet !== "object")
                        throw TypeError(".search.proto.SearchRequest.columnsToGet: object expected");
                    message.columnsToGet = $root.search.proto.ColumnsToGet.fromObject(object.columnsToGet);
                }
                if (object.searchQuery != null)
                    if (typeof object.searchQuery === "string")
                        $util.base64.decode(object.searchQuery, message.searchQuery = $util.newBuffer($util.base64.length(object.searchQuery)), 0);
                    else if (object.searchQuery.length)
                        message.searchQuery = object.searchQuery;
                if (object.routingValues) {
                    if (!Array.isArray(object.routingValues))
                        throw TypeError(".search.proto.SearchRequest.routingValues: array expected");
                    message.routingValues = [];
                    for (var i = 0; i < object.routingValues.length; ++i)
                        if (typeof object.routingValues[i] === "string")
                            $util.base64.decode(object.routingValues[i], message.routingValues[i] = $util.newBuffer($util.base64.length(object.routingValues[i])), 0);
                        else if (object.routingValues[i].length)
                            message.routingValues[i] = object.routingValues[i];
                }
                if (object.timeoutMs != null)
                    message.timeoutMs = object.timeoutMs | 0;
                return message;
            };

            /**
             * Creates a plain object from a SearchRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.SearchRequest
             * @static
             * @param {search.proto.SearchRequest} message SearchRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SearchRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.routingValues = [];
                if (options.defaults) {
                    object.tableName = "";
                    object.indexName = "";
                    object.columnsToGet = null;
                    if (options.bytes === String)
                        object.searchQuery = "";
                    else {
                        object.searchQuery = [];
                        if (options.bytes !== Array)
                            object.searchQuery = $util.newBuffer(object.searchQuery);
                    }
                    object.timeoutMs = 0;
                }
                if (message.tableName != null && message.hasOwnProperty("tableName"))
                    object.tableName = message.tableName;
                if (message.indexName != null && message.hasOwnProperty("indexName"))
                    object.indexName = message.indexName;
                if (message.columnsToGet != null && message.hasOwnProperty("columnsToGet"))
                    object.columnsToGet = $root.search.proto.ColumnsToGet.toObject(message.columnsToGet, options);
                if (message.searchQuery != null && message.hasOwnProperty("searchQuery"))
                    object.searchQuery = options.bytes === String ? $util.base64.encode(message.searchQuery, 0, message.searchQuery.length) : options.bytes === Array ? Array.prototype.slice.call(message.searchQuery) : message.searchQuery;
                if (message.routingValues && message.routingValues.length) {
                    object.routingValues = [];
                    for (var j = 0; j < message.routingValues.length; ++j)
                        object.routingValues[j] = options.bytes === String ? $util.base64.encode(message.routingValues[j], 0, message.routingValues[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.routingValues[j]) : message.routingValues[j];
                }
                if (message.timeoutMs != null && message.hasOwnProperty("timeoutMs"))
                    object.timeoutMs = message.timeoutMs;
                return object;
            };

            /**
             * Converts this SearchRequest to JSON.
             * @function toJSON
             * @memberof search.proto.SearchRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SearchRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SearchRequest;
        })();

        proto.SearchResponse = (function() {

            /**
             * Properties of a SearchResponse.
             * @memberof search.proto
             * @interface ISearchResponse
             * @property {number|Long|null} [totalHits] SearchResponse totalHits
             * @property {Array.<Uint8Array>|null} [rows] SearchResponse rows
             * @property {boolean|null} [isAllSucceeded] SearchResponse isAllSucceeded
             * @property {Array.<search.proto.ISearchHit>|null} [searchHits] SearchResponse searchHits
             * @property {Uint8Array|null} [nextToken] SearchResponse nextToken
             * @property {Uint8Array|null} [aggs] SearchResponse aggs
             * @property {Uint8Array|null} [groupBys] SearchResponse groupBys
             * @property {main.proto.IConsumedCapacity|null} [consumed] SearchResponse consumed
             * @property {main.proto.IConsumedCapacity|null} [reservedConsumed] SearchResponse reservedConsumed
             */

            /**
             * Constructs a new SearchResponse.
             * @memberof search.proto
             * @classdesc Represents a SearchResponse.
             * @implements ISearchResponse
             * @constructor
             * @param {search.proto.ISearchResponse=} [properties] Properties to set
             */
            function SearchResponse(properties) {
                this.rows = [];
                this.searchHits = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SearchResponse totalHits.
             * @member {number|Long} totalHits
             * @memberof search.proto.SearchResponse
             * @instance
             */
            SearchResponse.prototype.totalHits = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * SearchResponse rows.
             * @member {Array.<Uint8Array>} rows
             * @memberof search.proto.SearchResponse
             * @instance
             */
            SearchResponse.prototype.rows = $util.emptyArray;

            /**
             * SearchResponse isAllSucceeded.
             * @member {boolean} isAllSucceeded
             * @memberof search.proto.SearchResponse
             * @instance
             */
            SearchResponse.prototype.isAllSucceeded = false;

            /**
             * SearchResponse searchHits.
             * @member {Array.<search.proto.ISearchHit>} searchHits
             * @memberof search.proto.SearchResponse
             * @instance
             */
            SearchResponse.prototype.searchHits = $util.emptyArray;

            /**
             * SearchResponse nextToken.
             * @member {Uint8Array} nextToken
             * @memberof search.proto.SearchResponse
             * @instance
             */
            SearchResponse.prototype.nextToken = $util.newBuffer([]);

            /**
             * SearchResponse aggs.
             * @member {Uint8Array} aggs
             * @memberof search.proto.SearchResponse
             * @instance
             */
            SearchResponse.prototype.aggs = $util.newBuffer([]);

            /**
             * SearchResponse groupBys.
             * @member {Uint8Array} groupBys
             * @memberof search.proto.SearchResponse
             * @instance
             */
            SearchResponse.prototype.groupBys = $util.newBuffer([]);

            /**
             * SearchResponse consumed.
             * @member {main.proto.IConsumedCapacity|null|undefined} consumed
             * @memberof search.proto.SearchResponse
             * @instance
             */
            SearchResponse.prototype.consumed = null;

            /**
             * SearchResponse reservedConsumed.
             * @member {main.proto.IConsumedCapacity|null|undefined} reservedConsumed
             * @memberof search.proto.SearchResponse
             * @instance
             */
            SearchResponse.prototype.reservedConsumed = null;

            /**
             * Creates a new SearchResponse instance using the specified properties.
             * @function create
             * @memberof search.proto.SearchResponse
             * @static
             * @param {search.proto.ISearchResponse=} [properties] Properties to set
             * @returns {search.proto.SearchResponse} SearchResponse instance
             */
            SearchResponse.create = function create(properties) {
                return new SearchResponse(properties);
            };

            /**
             * Encodes the specified SearchResponse message. Does not implicitly {@link search.proto.SearchResponse.verify|verify} messages.
             * @function encode
             * @memberof search.proto.SearchResponse
             * @static
             * @param {search.proto.ISearchResponse} message SearchResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SearchResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.totalHits != null && Object.hasOwnProperty.call(message, "totalHits"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.totalHits);
                if (message.rows != null && message.rows.length)
                    for (var i = 0; i < message.rows.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.rows[i]);
                if (message.isAllSucceeded != null && Object.hasOwnProperty.call(message, "isAllSucceeded"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isAllSucceeded);
                if (message.searchHits != null && message.searchHits.length)
                    for (var i = 0; i < message.searchHits.length; ++i)
                        $root.search.proto.SearchHit.encode(message.searchHits[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.nextToken != null && Object.hasOwnProperty.call(message, "nextToken"))
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.nextToken);
                if (message.aggs != null && Object.hasOwnProperty.call(message, "aggs"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.aggs);
                if (message.groupBys != null && Object.hasOwnProperty.call(message, "groupBys"))
                    writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.groupBys);
                if (message.consumed != null && Object.hasOwnProperty.call(message, "consumed"))
                    $root.main.proto.ConsumedCapacity.encode(message.consumed, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.reservedConsumed != null && Object.hasOwnProperty.call(message, "reservedConsumed"))
                    $root.main.proto.ConsumedCapacity.encode(message.reservedConsumed, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SearchResponse message, length delimited. Does not implicitly {@link search.proto.SearchResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.SearchResponse
             * @static
             * @param {search.proto.ISearchResponse} message SearchResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SearchResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SearchResponse message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.SearchResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.SearchResponse} SearchResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SearchResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.SearchResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.totalHits = reader.int64();
                        break;
                    case 2:
                        if (!(message.rows && message.rows.length))
                            message.rows = [];
                        message.rows.push(reader.bytes());
                        break;
                    case 3:
                        message.isAllSucceeded = reader.bool();
                        break;
                    case 5:
                        if (!(message.searchHits && message.searchHits.length))
                            message.searchHits = [];
                        message.searchHits.push($root.search.proto.SearchHit.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        message.nextToken = reader.bytes();
                        break;
                    case 7:
                        message.aggs = reader.bytes();
                        break;
                    case 8:
                        message.groupBys = reader.bytes();
                        break;
                    case 9:
                        message.consumed = $root.main.proto.ConsumedCapacity.decode(reader, reader.uint32());
                        break;
                    case 10:
                        message.reservedConsumed = $root.main.proto.ConsumedCapacity.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SearchResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.SearchResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.SearchResponse} SearchResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SearchResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SearchResponse message.
             * @function verify
             * @memberof search.proto.SearchResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SearchResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.totalHits != null && message.hasOwnProperty("totalHits"))
                    if (!$util.isInteger(message.totalHits) && !(message.totalHits && $util.isInteger(message.totalHits.low) && $util.isInteger(message.totalHits.high)))
                        return "totalHits: integer|Long expected";
                if (message.rows != null && message.hasOwnProperty("rows")) {
                    if (!Array.isArray(message.rows))
                        return "rows: array expected";
                    for (var i = 0; i < message.rows.length; ++i)
                        if (!(message.rows[i] && typeof message.rows[i].length === "number" || $util.isString(message.rows[i])))
                            return "rows: buffer[] expected";
                }
                if (message.isAllSucceeded != null && message.hasOwnProperty("isAllSucceeded"))
                    if (typeof message.isAllSucceeded !== "boolean")
                        return "isAllSucceeded: boolean expected";
                if (message.searchHits != null && message.hasOwnProperty("searchHits")) {
                    if (!Array.isArray(message.searchHits))
                        return "searchHits: array expected";
                    for (var i = 0; i < message.searchHits.length; ++i) {
                        var error = $root.search.proto.SearchHit.verify(message.searchHits[i]);
                        if (error)
                            return "searchHits." + error;
                    }
                }
                if (message.nextToken != null && message.hasOwnProperty("nextToken"))
                    if (!(message.nextToken && typeof message.nextToken.length === "number" || $util.isString(message.nextToken)))
                        return "nextToken: buffer expected";
                if (message.aggs != null && message.hasOwnProperty("aggs"))
                    if (!(message.aggs && typeof message.aggs.length === "number" || $util.isString(message.aggs)))
                        return "aggs: buffer expected";
                if (message.groupBys != null && message.hasOwnProperty("groupBys"))
                    if (!(message.groupBys && typeof message.groupBys.length === "number" || $util.isString(message.groupBys)))
                        return "groupBys: buffer expected";
                if (message.consumed != null && message.hasOwnProperty("consumed")) {
                    var error = $root.main.proto.ConsumedCapacity.verify(message.consumed);
                    if (error)
                        return "consumed." + error;
                }
                if (message.reservedConsumed != null && message.hasOwnProperty("reservedConsumed")) {
                    var error = $root.main.proto.ConsumedCapacity.verify(message.reservedConsumed);
                    if (error)
                        return "reservedConsumed." + error;
                }
                return null;
            };

            /**
             * Creates a SearchResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.SearchResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.SearchResponse} SearchResponse
             */
            SearchResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.SearchResponse)
                    return object;
                var message = new $root.search.proto.SearchResponse();
                if (object.totalHits != null)
                    if ($util.Long)
                        (message.totalHits = $util.Long.fromValue(object.totalHits)).unsigned = false;
                    else if (typeof object.totalHits === "string")
                        message.totalHits = parseInt(object.totalHits, 10);
                    else if (typeof object.totalHits === "number")
                        message.totalHits = object.totalHits;
                    else if (typeof object.totalHits === "object")
                        message.totalHits = new $util.LongBits(object.totalHits.low >>> 0, object.totalHits.high >>> 0).toNumber();
                if (object.rows) {
                    if (!Array.isArray(object.rows))
                        throw TypeError(".search.proto.SearchResponse.rows: array expected");
                    message.rows = [];
                    for (var i = 0; i < object.rows.length; ++i)
                        if (typeof object.rows[i] === "string")
                            $util.base64.decode(object.rows[i], message.rows[i] = $util.newBuffer($util.base64.length(object.rows[i])), 0);
                        else if (object.rows[i].length)
                            message.rows[i] = object.rows[i];
                }
                if (object.isAllSucceeded != null)
                    message.isAllSucceeded = Boolean(object.isAllSucceeded);
                if (object.searchHits) {
                    if (!Array.isArray(object.searchHits))
                        throw TypeError(".search.proto.SearchResponse.searchHits: array expected");
                    message.searchHits = [];
                    for (var i = 0; i < object.searchHits.length; ++i) {
                        if (typeof object.searchHits[i] !== "object")
                            throw TypeError(".search.proto.SearchResponse.searchHits: object expected");
                        message.searchHits[i] = $root.search.proto.SearchHit.fromObject(object.searchHits[i]);
                    }
                }
                if (object.nextToken != null)
                    if (typeof object.nextToken === "string")
                        $util.base64.decode(object.nextToken, message.nextToken = $util.newBuffer($util.base64.length(object.nextToken)), 0);
                    else if (object.nextToken.length)
                        message.nextToken = object.nextToken;
                if (object.aggs != null)
                    if (typeof object.aggs === "string")
                        $util.base64.decode(object.aggs, message.aggs = $util.newBuffer($util.base64.length(object.aggs)), 0);
                    else if (object.aggs.length)
                        message.aggs = object.aggs;
                if (object.groupBys != null)
                    if (typeof object.groupBys === "string")
                        $util.base64.decode(object.groupBys, message.groupBys = $util.newBuffer($util.base64.length(object.groupBys)), 0);
                    else if (object.groupBys.length)
                        message.groupBys = object.groupBys;
                if (object.consumed != null) {
                    if (typeof object.consumed !== "object")
                        throw TypeError(".search.proto.SearchResponse.consumed: object expected");
                    message.consumed = $root.main.proto.ConsumedCapacity.fromObject(object.consumed);
                }
                if (object.reservedConsumed != null) {
                    if (typeof object.reservedConsumed !== "object")
                        throw TypeError(".search.proto.SearchResponse.reservedConsumed: object expected");
                    message.reservedConsumed = $root.main.proto.ConsumedCapacity.fromObject(object.reservedConsumed);
                }
                return message;
            };

            /**
             * Creates a plain object from a SearchResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.SearchResponse
             * @static
             * @param {search.proto.SearchResponse} message SearchResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SearchResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.rows = [];
                    object.searchHits = [];
                }
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.totalHits = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.totalHits = options.longs === String ? "0" : 0;
                    object.isAllSucceeded = false;
                    if (options.bytes === String)
                        object.nextToken = "";
                    else {
                        object.nextToken = [];
                        if (options.bytes !== Array)
                            object.nextToken = $util.newBuffer(object.nextToken);
                    }
                    if (options.bytes === String)
                        object.aggs = "";
                    else {
                        object.aggs = [];
                        if (options.bytes !== Array)
                            object.aggs = $util.newBuffer(object.aggs);
                    }
                    if (options.bytes === String)
                        object.groupBys = "";
                    else {
                        object.groupBys = [];
                        if (options.bytes !== Array)
                            object.groupBys = $util.newBuffer(object.groupBys);
                    }
                    object.consumed = null;
                    object.reservedConsumed = null;
                }
                if (message.totalHits != null && message.hasOwnProperty("totalHits"))
                    if (typeof message.totalHits === "number")
                        object.totalHits = options.longs === String ? String(message.totalHits) : message.totalHits;
                    else
                        object.totalHits = options.longs === String ? $util.Long.prototype.toString.call(message.totalHits) : options.longs === Number ? new $util.LongBits(message.totalHits.low >>> 0, message.totalHits.high >>> 0).toNumber() : message.totalHits;
                if (message.rows && message.rows.length) {
                    object.rows = [];
                    for (var j = 0; j < message.rows.length; ++j)
                        object.rows[j] = options.bytes === String ? $util.base64.encode(message.rows[j], 0, message.rows[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.rows[j]) : message.rows[j];
                }
                if (message.isAllSucceeded != null && message.hasOwnProperty("isAllSucceeded"))
                    object.isAllSucceeded = message.isAllSucceeded;
                if (message.searchHits && message.searchHits.length) {
                    object.searchHits = [];
                    for (var j = 0; j < message.searchHits.length; ++j)
                        object.searchHits[j] = $root.search.proto.SearchHit.toObject(message.searchHits[j], options);
                }
                if (message.nextToken != null && message.hasOwnProperty("nextToken"))
                    object.nextToken = options.bytes === String ? $util.base64.encode(message.nextToken, 0, message.nextToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.nextToken) : message.nextToken;
                if (message.aggs != null && message.hasOwnProperty("aggs"))
                    object.aggs = options.bytes === String ? $util.base64.encode(message.aggs, 0, message.aggs.length) : options.bytes === Array ? Array.prototype.slice.call(message.aggs) : message.aggs;
                if (message.groupBys != null && message.hasOwnProperty("groupBys"))
                    object.groupBys = options.bytes === String ? $util.base64.encode(message.groupBys, 0, message.groupBys.length) : options.bytes === Array ? Array.prototype.slice.call(message.groupBys) : message.groupBys;
                if (message.consumed != null && message.hasOwnProperty("consumed"))
                    object.consumed = $root.main.proto.ConsumedCapacity.toObject(message.consumed, options);
                if (message.reservedConsumed != null && message.hasOwnProperty("reservedConsumed"))
                    object.reservedConsumed = $root.main.proto.ConsumedCapacity.toObject(message.reservedConsumed, options);
                return object;
            };

            /**
             * Converts this SearchResponse to JSON.
             * @function toJSON
             * @memberof search.proto.SearchResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SearchResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SearchResponse;
        })();

        proto.SearchHit = (function() {

            /**
             * Properties of a SearchHit.
             * @memberof search.proto
             * @interface ISearchHit
             * @property {number|null} [score] SearchHit score
             * @property {search.proto.IHighlightResult|null} [highlightResult] SearchHit highlightResult
             * @property {Array.<search.proto.ISearchInnerHit>|null} [searchInnerHits] SearchHit searchInnerHits
             * @property {number|null} [nestedDocOffset] SearchHit nestedDocOffset
             */

            /**
             * Constructs a new SearchHit.
             * @memberof search.proto
             * @classdesc Represents a SearchHit.
             * @implements ISearchHit
             * @constructor
             * @param {search.proto.ISearchHit=} [properties] Properties to set
             */
            function SearchHit(properties) {
                this.searchInnerHits = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SearchHit score.
             * @member {number} score
             * @memberof search.proto.SearchHit
             * @instance
             */
            SearchHit.prototype.score = 0;

            /**
             * SearchHit highlightResult.
             * @member {search.proto.IHighlightResult|null|undefined} highlightResult
             * @memberof search.proto.SearchHit
             * @instance
             */
            SearchHit.prototype.highlightResult = null;

            /**
             * SearchHit searchInnerHits.
             * @member {Array.<search.proto.ISearchInnerHit>} searchInnerHits
             * @memberof search.proto.SearchHit
             * @instance
             */
            SearchHit.prototype.searchInnerHits = $util.emptyArray;

            /**
             * SearchHit nestedDocOffset.
             * @member {number} nestedDocOffset
             * @memberof search.proto.SearchHit
             * @instance
             */
            SearchHit.prototype.nestedDocOffset = 0;

            /**
             * Creates a new SearchHit instance using the specified properties.
             * @function create
             * @memberof search.proto.SearchHit
             * @static
             * @param {search.proto.ISearchHit=} [properties] Properties to set
             * @returns {search.proto.SearchHit} SearchHit instance
             */
            SearchHit.create = function create(properties) {
                return new SearchHit(properties);
            };

            /**
             * Encodes the specified SearchHit message. Does not implicitly {@link search.proto.SearchHit.verify|verify} messages.
             * @function encode
             * @memberof search.proto.SearchHit
             * @static
             * @param {search.proto.ISearchHit} message SearchHit message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SearchHit.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.score);
                if (message.highlightResult != null && Object.hasOwnProperty.call(message, "highlightResult"))
                    $root.search.proto.HighlightResult.encode(message.highlightResult, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.searchInnerHits != null && message.searchInnerHits.length)
                    for (var i = 0; i < message.searchInnerHits.length; ++i)
                        $root.search.proto.SearchInnerHit.encode(message.searchInnerHits[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.nestedDocOffset != null && Object.hasOwnProperty.call(message, "nestedDocOffset"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.nestedDocOffset);
                return writer;
            };

            /**
             * Encodes the specified SearchHit message, length delimited. Does not implicitly {@link search.proto.SearchHit.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.SearchHit
             * @static
             * @param {search.proto.ISearchHit} message SearchHit message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SearchHit.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SearchHit message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.SearchHit
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.SearchHit} SearchHit
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SearchHit.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.SearchHit();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 3:
                        message.score = reader.double();
                        break;
                    case 4:
                        message.highlightResult = $root.search.proto.HighlightResult.decode(reader, reader.uint32());
                        break;
                    case 5:
                        if (!(message.searchInnerHits && message.searchInnerHits.length))
                            message.searchInnerHits = [];
                        message.searchInnerHits.push($root.search.proto.SearchInnerHit.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        message.nestedDocOffset = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SearchHit message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.SearchHit
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.SearchHit} SearchHit
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SearchHit.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SearchHit message.
             * @function verify
             * @memberof search.proto.SearchHit
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SearchHit.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.score != null && message.hasOwnProperty("score"))
                    if (typeof message.score !== "number")
                        return "score: number expected";
                if (message.highlightResult != null && message.hasOwnProperty("highlightResult")) {
                    var error = $root.search.proto.HighlightResult.verify(message.highlightResult);
                    if (error)
                        return "highlightResult." + error;
                }
                if (message.searchInnerHits != null && message.hasOwnProperty("searchInnerHits")) {
                    if (!Array.isArray(message.searchInnerHits))
                        return "searchInnerHits: array expected";
                    for (var i = 0; i < message.searchInnerHits.length; ++i) {
                        var error = $root.search.proto.SearchInnerHit.verify(message.searchInnerHits[i]);
                        if (error)
                            return "searchInnerHits." + error;
                    }
                }
                if (message.nestedDocOffset != null && message.hasOwnProperty("nestedDocOffset"))
                    if (!$util.isInteger(message.nestedDocOffset))
                        return "nestedDocOffset: integer expected";
                return null;
            };

            /**
             * Creates a SearchHit message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.SearchHit
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.SearchHit} SearchHit
             */
            SearchHit.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.SearchHit)
                    return object;
                var message = new $root.search.proto.SearchHit();
                if (object.score != null)
                    message.score = Number(object.score);
                if (object.highlightResult != null) {
                    if (typeof object.highlightResult !== "object")
                        throw TypeError(".search.proto.SearchHit.highlightResult: object expected");
                    message.highlightResult = $root.search.proto.HighlightResult.fromObject(object.highlightResult);
                }
                if (object.searchInnerHits) {
                    if (!Array.isArray(object.searchInnerHits))
                        throw TypeError(".search.proto.SearchHit.searchInnerHits: array expected");
                    message.searchInnerHits = [];
                    for (var i = 0; i < object.searchInnerHits.length; ++i) {
                        if (typeof object.searchInnerHits[i] !== "object")
                            throw TypeError(".search.proto.SearchHit.searchInnerHits: object expected");
                        message.searchInnerHits[i] = $root.search.proto.SearchInnerHit.fromObject(object.searchInnerHits[i]);
                    }
                }
                if (object.nestedDocOffset != null)
                    message.nestedDocOffset = object.nestedDocOffset | 0;
                return message;
            };

            /**
             * Creates a plain object from a SearchHit message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.SearchHit
             * @static
             * @param {search.proto.SearchHit} message SearchHit
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SearchHit.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.searchInnerHits = [];
                if (options.defaults) {
                    object.score = 0;
                    object.highlightResult = null;
                    object.nestedDocOffset = 0;
                }
                if (message.score != null && message.hasOwnProperty("score"))
                    object.score = options.json && !isFinite(message.score) ? String(message.score) : message.score;
                if (message.highlightResult != null && message.hasOwnProperty("highlightResult"))
                    object.highlightResult = $root.search.proto.HighlightResult.toObject(message.highlightResult, options);
                if (message.searchInnerHits && message.searchInnerHits.length) {
                    object.searchInnerHits = [];
                    for (var j = 0; j < message.searchInnerHits.length; ++j)
                        object.searchInnerHits[j] = $root.search.proto.SearchInnerHit.toObject(message.searchInnerHits[j], options);
                }
                if (message.nestedDocOffset != null && message.hasOwnProperty("nestedDocOffset"))
                    object.nestedDocOffset = message.nestedDocOffset;
                return object;
            };

            /**
             * Converts this SearchHit to JSON.
             * @function toJSON
             * @memberof search.proto.SearchHit
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SearchHit.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SearchHit;
        })();

        proto.SearchInnerHit = (function() {

            /**
             * Properties of a SearchInnerHit.
             * @memberof search.proto
             * @interface ISearchInnerHit
             * @property {string|null} [path] SearchInnerHit path
             * @property {Array.<search.proto.ISearchHit>|null} [searchHits] SearchInnerHit searchHits
             */

            /**
             * Constructs a new SearchInnerHit.
             * @memberof search.proto
             * @classdesc Represents a SearchInnerHit.
             * @implements ISearchInnerHit
             * @constructor
             * @param {search.proto.ISearchInnerHit=} [properties] Properties to set
             */
            function SearchInnerHit(properties) {
                this.searchHits = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SearchInnerHit path.
             * @member {string} path
             * @memberof search.proto.SearchInnerHit
             * @instance
             */
            SearchInnerHit.prototype.path = "";

            /**
             * SearchInnerHit searchHits.
             * @member {Array.<search.proto.ISearchHit>} searchHits
             * @memberof search.proto.SearchInnerHit
             * @instance
             */
            SearchInnerHit.prototype.searchHits = $util.emptyArray;

            /**
             * Creates a new SearchInnerHit instance using the specified properties.
             * @function create
             * @memberof search.proto.SearchInnerHit
             * @static
             * @param {search.proto.ISearchInnerHit=} [properties] Properties to set
             * @returns {search.proto.SearchInnerHit} SearchInnerHit instance
             */
            SearchInnerHit.create = function create(properties) {
                return new SearchInnerHit(properties);
            };

            /**
             * Encodes the specified SearchInnerHit message. Does not implicitly {@link search.proto.SearchInnerHit.verify|verify} messages.
             * @function encode
             * @memberof search.proto.SearchInnerHit
             * @static
             * @param {search.proto.ISearchInnerHit} message SearchInnerHit message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SearchInnerHit.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.path != null && Object.hasOwnProperty.call(message, "path"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.path);
                if (message.searchHits != null && message.searchHits.length)
                    for (var i = 0; i < message.searchHits.length; ++i)
                        $root.search.proto.SearchHit.encode(message.searchHits[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SearchInnerHit message, length delimited. Does not implicitly {@link search.proto.SearchInnerHit.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.SearchInnerHit
             * @static
             * @param {search.proto.ISearchInnerHit} message SearchInnerHit message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SearchInnerHit.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SearchInnerHit message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.SearchInnerHit
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.SearchInnerHit} SearchInnerHit
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SearchInnerHit.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.SearchInnerHit();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.path = reader.string();
                        break;
                    case 2:
                        if (!(message.searchHits && message.searchHits.length))
                            message.searchHits = [];
                        message.searchHits.push($root.search.proto.SearchHit.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SearchInnerHit message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.SearchInnerHit
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.SearchInnerHit} SearchInnerHit
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SearchInnerHit.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SearchInnerHit message.
             * @function verify
             * @memberof search.proto.SearchInnerHit
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SearchInnerHit.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                if (message.searchHits != null && message.hasOwnProperty("searchHits")) {
                    if (!Array.isArray(message.searchHits))
                        return "searchHits: array expected";
                    for (var i = 0; i < message.searchHits.length; ++i) {
                        var error = $root.search.proto.SearchHit.verify(message.searchHits[i]);
                        if (error)
                            return "searchHits." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a SearchInnerHit message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.SearchInnerHit
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.SearchInnerHit} SearchInnerHit
             */
            SearchInnerHit.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.SearchInnerHit)
                    return object;
                var message = new $root.search.proto.SearchInnerHit();
                if (object.path != null)
                    message.path = String(object.path);
                if (object.searchHits) {
                    if (!Array.isArray(object.searchHits))
                        throw TypeError(".search.proto.SearchInnerHit.searchHits: array expected");
                    message.searchHits = [];
                    for (var i = 0; i < object.searchHits.length; ++i) {
                        if (typeof object.searchHits[i] !== "object")
                            throw TypeError(".search.proto.SearchInnerHit.searchHits: object expected");
                        message.searchHits[i] = $root.search.proto.SearchHit.fromObject(object.searchHits[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a SearchInnerHit message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.SearchInnerHit
             * @static
             * @param {search.proto.SearchInnerHit} message SearchInnerHit
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SearchInnerHit.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.searchHits = [];
                if (options.defaults)
                    object.path = "";
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                if (message.searchHits && message.searchHits.length) {
                    object.searchHits = [];
                    for (var j = 0; j < message.searchHits.length; ++j)
                        object.searchHits[j] = $root.search.proto.SearchHit.toObject(message.searchHits[j], options);
                }
                return object;
            };

            /**
             * Converts this SearchInnerHit to JSON.
             * @function toJSON
             * @memberof search.proto.SearchInnerHit
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SearchInnerHit.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SearchInnerHit;
        })();

        proto.HighlightResult = (function() {

            /**
             * Properties of a HighlightResult.
             * @memberof search.proto
             * @interface IHighlightResult
             * @property {Array.<search.proto.IHighlightField>|null} [highlightFields] HighlightResult highlightFields
             */

            /**
             * Constructs a new HighlightResult.
             * @memberof search.proto
             * @classdesc Represents a HighlightResult.
             * @implements IHighlightResult
             * @constructor
             * @param {search.proto.IHighlightResult=} [properties] Properties to set
             */
            function HighlightResult(properties) {
                this.highlightFields = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * HighlightResult highlightFields.
             * @member {Array.<search.proto.IHighlightField>} highlightFields
             * @memberof search.proto.HighlightResult
             * @instance
             */
            HighlightResult.prototype.highlightFields = $util.emptyArray;

            /**
             * Creates a new HighlightResult instance using the specified properties.
             * @function create
             * @memberof search.proto.HighlightResult
             * @static
             * @param {search.proto.IHighlightResult=} [properties] Properties to set
             * @returns {search.proto.HighlightResult} HighlightResult instance
             */
            HighlightResult.create = function create(properties) {
                return new HighlightResult(properties);
            };

            /**
             * Encodes the specified HighlightResult message. Does not implicitly {@link search.proto.HighlightResult.verify|verify} messages.
             * @function encode
             * @memberof search.proto.HighlightResult
             * @static
             * @param {search.proto.IHighlightResult} message HighlightResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HighlightResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.highlightFields != null && message.highlightFields.length)
                    for (var i = 0; i < message.highlightFields.length; ++i)
                        $root.search.proto.HighlightField.encode(message.highlightFields[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified HighlightResult message, length delimited. Does not implicitly {@link search.proto.HighlightResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.HighlightResult
             * @static
             * @param {search.proto.IHighlightResult} message HighlightResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HighlightResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a HighlightResult message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.HighlightResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.HighlightResult} HighlightResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HighlightResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.HighlightResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.highlightFields && message.highlightFields.length))
                            message.highlightFields = [];
                        message.highlightFields.push($root.search.proto.HighlightField.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a HighlightResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.HighlightResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.HighlightResult} HighlightResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HighlightResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a HighlightResult message.
             * @function verify
             * @memberof search.proto.HighlightResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            HighlightResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.highlightFields != null && message.hasOwnProperty("highlightFields")) {
                    if (!Array.isArray(message.highlightFields))
                        return "highlightFields: array expected";
                    for (var i = 0; i < message.highlightFields.length; ++i) {
                        var error = $root.search.proto.HighlightField.verify(message.highlightFields[i]);
                        if (error)
                            return "highlightFields." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a HighlightResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.HighlightResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.HighlightResult} HighlightResult
             */
            HighlightResult.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.HighlightResult)
                    return object;
                var message = new $root.search.proto.HighlightResult();
                if (object.highlightFields) {
                    if (!Array.isArray(object.highlightFields))
                        throw TypeError(".search.proto.HighlightResult.highlightFields: array expected");
                    message.highlightFields = [];
                    for (var i = 0; i < object.highlightFields.length; ++i) {
                        if (typeof object.highlightFields[i] !== "object")
                            throw TypeError(".search.proto.HighlightResult.highlightFields: object expected");
                        message.highlightFields[i] = $root.search.proto.HighlightField.fromObject(object.highlightFields[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a HighlightResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.HighlightResult
             * @static
             * @param {search.proto.HighlightResult} message HighlightResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            HighlightResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.highlightFields = [];
                if (message.highlightFields && message.highlightFields.length) {
                    object.highlightFields = [];
                    for (var j = 0; j < message.highlightFields.length; ++j)
                        object.highlightFields[j] = $root.search.proto.HighlightField.toObject(message.highlightFields[j], options);
                }
                return object;
            };

            /**
             * Converts this HighlightResult to JSON.
             * @function toJSON
             * @memberof search.proto.HighlightResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            HighlightResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return HighlightResult;
        })();

        proto.HighlightField = (function() {

            /**
             * Properties of a HighlightField.
             * @memberof search.proto
             * @interface IHighlightField
             * @property {string|null} [fieldName] HighlightField fieldName
             * @property {Array.<string>|null} [fieldFragments] HighlightField fieldFragments
             */

            /**
             * Constructs a new HighlightField.
             * @memberof search.proto
             * @classdesc Represents a HighlightField.
             * @implements IHighlightField
             * @constructor
             * @param {search.proto.IHighlightField=} [properties] Properties to set
             */
            function HighlightField(properties) {
                this.fieldFragments = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * HighlightField fieldName.
             * @member {string} fieldName
             * @memberof search.proto.HighlightField
             * @instance
             */
            HighlightField.prototype.fieldName = "";

            /**
             * HighlightField fieldFragments.
             * @member {Array.<string>} fieldFragments
             * @memberof search.proto.HighlightField
             * @instance
             */
            HighlightField.prototype.fieldFragments = $util.emptyArray;

            /**
             * Creates a new HighlightField instance using the specified properties.
             * @function create
             * @memberof search.proto.HighlightField
             * @static
             * @param {search.proto.IHighlightField=} [properties] Properties to set
             * @returns {search.proto.HighlightField} HighlightField instance
             */
            HighlightField.create = function create(properties) {
                return new HighlightField(properties);
            };

            /**
             * Encodes the specified HighlightField message. Does not implicitly {@link search.proto.HighlightField.verify|verify} messages.
             * @function encode
             * @memberof search.proto.HighlightField
             * @static
             * @param {search.proto.IHighlightField} message HighlightField message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HighlightField.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fieldName != null && Object.hasOwnProperty.call(message, "fieldName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fieldName);
                if (message.fieldFragments != null && message.fieldFragments.length)
                    for (var i = 0; i < message.fieldFragments.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.fieldFragments[i]);
                return writer;
            };

            /**
             * Encodes the specified HighlightField message, length delimited. Does not implicitly {@link search.proto.HighlightField.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.HighlightField
             * @static
             * @param {search.proto.IHighlightField} message HighlightField message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HighlightField.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a HighlightField message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.HighlightField
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.HighlightField} HighlightField
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HighlightField.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.HighlightField();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fieldName = reader.string();
                        break;
                    case 2:
                        if (!(message.fieldFragments && message.fieldFragments.length))
                            message.fieldFragments = [];
                        message.fieldFragments.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a HighlightField message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.HighlightField
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.HighlightField} HighlightField
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HighlightField.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a HighlightField message.
             * @function verify
             * @memberof search.proto.HighlightField
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            HighlightField.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    if (!$util.isString(message.fieldName))
                        return "fieldName: string expected";
                if (message.fieldFragments != null && message.hasOwnProperty("fieldFragments")) {
                    if (!Array.isArray(message.fieldFragments))
                        return "fieldFragments: array expected";
                    for (var i = 0; i < message.fieldFragments.length; ++i)
                        if (!$util.isString(message.fieldFragments[i]))
                            return "fieldFragments: string[] expected";
                }
                return null;
            };

            /**
             * Creates a HighlightField message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.HighlightField
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.HighlightField} HighlightField
             */
            HighlightField.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.HighlightField)
                    return object;
                var message = new $root.search.proto.HighlightField();
                if (object.fieldName != null)
                    message.fieldName = String(object.fieldName);
                if (object.fieldFragments) {
                    if (!Array.isArray(object.fieldFragments))
                        throw TypeError(".search.proto.HighlightField.fieldFragments: array expected");
                    message.fieldFragments = [];
                    for (var i = 0; i < object.fieldFragments.length; ++i)
                        message.fieldFragments[i] = String(object.fieldFragments[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a HighlightField message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.HighlightField
             * @static
             * @param {search.proto.HighlightField} message HighlightField
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            HighlightField.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.fieldFragments = [];
                if (options.defaults)
                    object.fieldName = "";
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    object.fieldName = message.fieldName;
                if (message.fieldFragments && message.fieldFragments.length) {
                    object.fieldFragments = [];
                    for (var j = 0; j < message.fieldFragments.length; ++j)
                        object.fieldFragments[j] = message.fieldFragments[j];
                }
                return object;
            };

            /**
             * Converts this HighlightField to JSON.
             * @function toJSON
             * @memberof search.proto.HighlightField
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            HighlightField.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return HighlightField;
        })();

        /**
         * IndexOptions enum.
         * @name search.proto.IndexOptions
         * @enum {number}
         * @property {number} DOCS=1 DOCS value
         * @property {number} FREQS=2 FREQS value
         * @property {number} POSITIONS=3 POSITIONS value
         * @property {number} OFFSETS=4 OFFSETS value
         */
        proto.IndexOptions = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "DOCS"] = 1;
            values[valuesById[2] = "FREQS"] = 2;
            values[valuesById[3] = "POSITIONS"] = 3;
            values[valuesById[4] = "OFFSETS"] = 4;
            return values;
        })();

        /**
         * FieldType enum.
         * @name search.proto.FieldType
         * @enum {number}
         * @property {number} LONG=1 LONG value
         * @property {number} DOUBLE=2 DOUBLE value
         * @property {number} BOOLEAN=3 BOOLEAN value
         * @property {number} KEYWORD=4 KEYWORD value
         * @property {number} TEXT=5 TEXT value
         * @property {number} NESTED=6 NESTED value
         * @property {number} GEO_POINT=7 GEO_POINT value
         * @property {number} DATE=8 DATE value
         * @property {number} VECTOR=9 VECTOR value
         */
        proto.FieldType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "LONG"] = 1;
            values[valuesById[2] = "DOUBLE"] = 2;
            values[valuesById[3] = "BOOLEAN"] = 3;
            values[valuesById[4] = "KEYWORD"] = 4;
            values[valuesById[5] = "TEXT"] = 5;
            values[valuesById[6] = "NESTED"] = 6;
            values[valuesById[7] = "GEO_POINT"] = 7;
            values[valuesById[8] = "DATE"] = 8;
            values[valuesById[9] = "VECTOR"] = 9;
            return values;
        })();

        /**
         * DateTimeUnit enum.
         * @name search.proto.DateTimeUnit
         * @enum {number}
         * @property {number} YEAR=1 YEAR value
         * @property {number} QUARTER_YEAR=2 QUARTER_YEAR value
         * @property {number} MONTH=3 MONTH value
         * @property {number} WEEK=4 WEEK value
         * @property {number} DAY=5 DAY value
         * @property {number} HOUR=6 HOUR value
         * @property {number} MINUTE=7 MINUTE value
         * @property {number} SECOND=8 SECOND value
         * @property {number} MILLISECOND=9 MILLISECOND value
         */
        proto.DateTimeUnit = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "YEAR"] = 1;
            values[valuesById[2] = "QUARTER_YEAR"] = 2;
            values[valuesById[3] = "MONTH"] = 3;
            values[valuesById[4] = "WEEK"] = 4;
            values[valuesById[5] = "DAY"] = 5;
            values[valuesById[6] = "HOUR"] = 6;
            values[valuesById[7] = "MINUTE"] = 7;
            values[valuesById[8] = "SECOND"] = 8;
            values[valuesById[9] = "MILLISECOND"] = 9;
            return values;
        })();

        proto.DateTimeValue = (function() {

            /**
             * Properties of a DateTimeValue.
             * @memberof search.proto
             * @interface IDateTimeValue
             * @property {number|null} [value] DateTimeValue value
             * @property {search.proto.DateTimeUnit|null} [unit] DateTimeValue unit
             */

            /**
             * Constructs a new DateTimeValue.
             * @memberof search.proto
             * @classdesc Represents a DateTimeValue.
             * @implements IDateTimeValue
             * @constructor
             * @param {search.proto.IDateTimeValue=} [properties] Properties to set
             */
            function DateTimeValue(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DateTimeValue value.
             * @member {number} value
             * @memberof search.proto.DateTimeValue
             * @instance
             */
            DateTimeValue.prototype.value = 0;

            /**
             * DateTimeValue unit.
             * @member {search.proto.DateTimeUnit} unit
             * @memberof search.proto.DateTimeValue
             * @instance
             */
            DateTimeValue.prototype.unit = 1;

            /**
             * Creates a new DateTimeValue instance using the specified properties.
             * @function create
             * @memberof search.proto.DateTimeValue
             * @static
             * @param {search.proto.IDateTimeValue=} [properties] Properties to set
             * @returns {search.proto.DateTimeValue} DateTimeValue instance
             */
            DateTimeValue.create = function create(properties) {
                return new DateTimeValue(properties);
            };

            /**
             * Encodes the specified DateTimeValue message. Does not implicitly {@link search.proto.DateTimeValue.verify|verify} messages.
             * @function encode
             * @memberof search.proto.DateTimeValue
             * @static
             * @param {search.proto.IDateTimeValue} message DateTimeValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DateTimeValue.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.value);
                if (message.unit != null && Object.hasOwnProperty.call(message, "unit"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.unit);
                return writer;
            };

            /**
             * Encodes the specified DateTimeValue message, length delimited. Does not implicitly {@link search.proto.DateTimeValue.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.DateTimeValue
             * @static
             * @param {search.proto.IDateTimeValue} message DateTimeValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DateTimeValue.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DateTimeValue message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.DateTimeValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.DateTimeValue} DateTimeValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DateTimeValue.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.DateTimeValue();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.value = reader.int32();
                        break;
                    case 2:
                        message.unit = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DateTimeValue message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.DateTimeValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.DateTimeValue} DateTimeValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DateTimeValue.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DateTimeValue message.
             * @function verify
             * @memberof search.proto.DateTimeValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DateTimeValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isInteger(message.value))
                        return "value: integer expected";
                if (message.unit != null && message.hasOwnProperty("unit"))
                    switch (message.unit) {
                    default:
                        return "unit: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                        break;
                    }
                return null;
            };

            /**
             * Creates a DateTimeValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.DateTimeValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.DateTimeValue} DateTimeValue
             */
            DateTimeValue.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.DateTimeValue)
                    return object;
                var message = new $root.search.proto.DateTimeValue();
                if (object.value != null)
                    message.value = object.value | 0;
                switch (object.unit) {
                case "YEAR":
                case 1:
                    message.unit = 1;
                    break;
                case "QUARTER_YEAR":
                case 2:
                    message.unit = 2;
                    break;
                case "MONTH":
                case 3:
                    message.unit = 3;
                    break;
                case "WEEK":
                case 4:
                    message.unit = 4;
                    break;
                case "DAY":
                case 5:
                    message.unit = 5;
                    break;
                case "HOUR":
                case 6:
                    message.unit = 6;
                    break;
                case "MINUTE":
                case 7:
                    message.unit = 7;
                    break;
                case "SECOND":
                case 8:
                    message.unit = 8;
                    break;
                case "MILLISECOND":
                case 9:
                    message.unit = 9;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a DateTimeValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.DateTimeValue
             * @static
             * @param {search.proto.DateTimeValue} message DateTimeValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DateTimeValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.value = 0;
                    object.unit = options.enums === String ? "YEAR" : 1;
                }
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                if (message.unit != null && message.hasOwnProperty("unit"))
                    object.unit = options.enums === String ? $root.search.proto.DateTimeUnit[message.unit] : message.unit;
                return object;
            };

            /**
             * Converts this DateTimeValue to JSON.
             * @function toJSON
             * @memberof search.proto.DateTimeValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DateTimeValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DateTimeValue;
        })();

        proto.SingleWordAnalyzerParameter = (function() {

            /**
             * Properties of a SingleWordAnalyzerParameter.
             * @memberof search.proto
             * @interface ISingleWordAnalyzerParameter
             * @property {boolean|null} [caseSensitive] SingleWordAnalyzerParameter caseSensitive
             * @property {boolean|null} [delimitWord] SingleWordAnalyzerParameter delimitWord
             */

            /**
             * Constructs a new SingleWordAnalyzerParameter.
             * @memberof search.proto
             * @classdesc Represents a SingleWordAnalyzerParameter.
             * @implements ISingleWordAnalyzerParameter
             * @constructor
             * @param {search.proto.ISingleWordAnalyzerParameter=} [properties] Properties to set
             */
            function SingleWordAnalyzerParameter(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SingleWordAnalyzerParameter caseSensitive.
             * @member {boolean} caseSensitive
             * @memberof search.proto.SingleWordAnalyzerParameter
             * @instance
             */
            SingleWordAnalyzerParameter.prototype.caseSensitive = false;

            /**
             * SingleWordAnalyzerParameter delimitWord.
             * @member {boolean} delimitWord
             * @memberof search.proto.SingleWordAnalyzerParameter
             * @instance
             */
            SingleWordAnalyzerParameter.prototype.delimitWord = false;

            /**
             * Creates a new SingleWordAnalyzerParameter instance using the specified properties.
             * @function create
             * @memberof search.proto.SingleWordAnalyzerParameter
             * @static
             * @param {search.proto.ISingleWordAnalyzerParameter=} [properties] Properties to set
             * @returns {search.proto.SingleWordAnalyzerParameter} SingleWordAnalyzerParameter instance
             */
            SingleWordAnalyzerParameter.create = function create(properties) {
                return new SingleWordAnalyzerParameter(properties);
            };

            /**
             * Encodes the specified SingleWordAnalyzerParameter message. Does not implicitly {@link search.proto.SingleWordAnalyzerParameter.verify|verify} messages.
             * @function encode
             * @memberof search.proto.SingleWordAnalyzerParameter
             * @static
             * @param {search.proto.ISingleWordAnalyzerParameter} message SingleWordAnalyzerParameter message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SingleWordAnalyzerParameter.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.caseSensitive != null && Object.hasOwnProperty.call(message, "caseSensitive"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.caseSensitive);
                if (message.delimitWord != null && Object.hasOwnProperty.call(message, "delimitWord"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.delimitWord);
                return writer;
            };

            /**
             * Encodes the specified SingleWordAnalyzerParameter message, length delimited. Does not implicitly {@link search.proto.SingleWordAnalyzerParameter.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.SingleWordAnalyzerParameter
             * @static
             * @param {search.proto.ISingleWordAnalyzerParameter} message SingleWordAnalyzerParameter message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SingleWordAnalyzerParameter.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SingleWordAnalyzerParameter message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.SingleWordAnalyzerParameter
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.SingleWordAnalyzerParameter} SingleWordAnalyzerParameter
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SingleWordAnalyzerParameter.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.SingleWordAnalyzerParameter();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.caseSensitive = reader.bool();
                        break;
                    case 2:
                        message.delimitWord = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SingleWordAnalyzerParameter message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.SingleWordAnalyzerParameter
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.SingleWordAnalyzerParameter} SingleWordAnalyzerParameter
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SingleWordAnalyzerParameter.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SingleWordAnalyzerParameter message.
             * @function verify
             * @memberof search.proto.SingleWordAnalyzerParameter
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SingleWordAnalyzerParameter.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.caseSensitive != null && message.hasOwnProperty("caseSensitive"))
                    if (typeof message.caseSensitive !== "boolean")
                        return "caseSensitive: boolean expected";
                if (message.delimitWord != null && message.hasOwnProperty("delimitWord"))
                    if (typeof message.delimitWord !== "boolean")
                        return "delimitWord: boolean expected";
                return null;
            };

            /**
             * Creates a SingleWordAnalyzerParameter message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.SingleWordAnalyzerParameter
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.SingleWordAnalyzerParameter} SingleWordAnalyzerParameter
             */
            SingleWordAnalyzerParameter.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.SingleWordAnalyzerParameter)
                    return object;
                var message = new $root.search.proto.SingleWordAnalyzerParameter();
                if (object.caseSensitive != null)
                    message.caseSensitive = Boolean(object.caseSensitive);
                if (object.delimitWord != null)
                    message.delimitWord = Boolean(object.delimitWord);
                return message;
            };

            /**
             * Creates a plain object from a SingleWordAnalyzerParameter message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.SingleWordAnalyzerParameter
             * @static
             * @param {search.proto.SingleWordAnalyzerParameter} message SingleWordAnalyzerParameter
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SingleWordAnalyzerParameter.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.caseSensitive = false;
                    object.delimitWord = false;
                }
                if (message.caseSensitive != null && message.hasOwnProperty("caseSensitive"))
                    object.caseSensitive = message.caseSensitive;
                if (message.delimitWord != null && message.hasOwnProperty("delimitWord"))
                    object.delimitWord = message.delimitWord;
                return object;
            };

            /**
             * Converts this SingleWordAnalyzerParameter to JSON.
             * @function toJSON
             * @memberof search.proto.SingleWordAnalyzerParameter
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SingleWordAnalyzerParameter.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SingleWordAnalyzerParameter;
        })();

        proto.SplitAnalyzerParameter = (function() {

            /**
             * Properties of a SplitAnalyzerParameter.
             * @memberof search.proto
             * @interface ISplitAnalyzerParameter
             * @property {string|null} [delimiter] SplitAnalyzerParameter delimiter
             */

            /**
             * Constructs a new SplitAnalyzerParameter.
             * @memberof search.proto
             * @classdesc Represents a SplitAnalyzerParameter.
             * @implements ISplitAnalyzerParameter
             * @constructor
             * @param {search.proto.ISplitAnalyzerParameter=} [properties] Properties to set
             */
            function SplitAnalyzerParameter(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SplitAnalyzerParameter delimiter.
             * @member {string} delimiter
             * @memberof search.proto.SplitAnalyzerParameter
             * @instance
             */
            SplitAnalyzerParameter.prototype.delimiter = "";

            /**
             * Creates a new SplitAnalyzerParameter instance using the specified properties.
             * @function create
             * @memberof search.proto.SplitAnalyzerParameter
             * @static
             * @param {search.proto.ISplitAnalyzerParameter=} [properties] Properties to set
             * @returns {search.proto.SplitAnalyzerParameter} SplitAnalyzerParameter instance
             */
            SplitAnalyzerParameter.create = function create(properties) {
                return new SplitAnalyzerParameter(properties);
            };

            /**
             * Encodes the specified SplitAnalyzerParameter message. Does not implicitly {@link search.proto.SplitAnalyzerParameter.verify|verify} messages.
             * @function encode
             * @memberof search.proto.SplitAnalyzerParameter
             * @static
             * @param {search.proto.ISplitAnalyzerParameter} message SplitAnalyzerParameter message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SplitAnalyzerParameter.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.delimiter != null && Object.hasOwnProperty.call(message, "delimiter"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.delimiter);
                return writer;
            };

            /**
             * Encodes the specified SplitAnalyzerParameter message, length delimited. Does not implicitly {@link search.proto.SplitAnalyzerParameter.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.SplitAnalyzerParameter
             * @static
             * @param {search.proto.ISplitAnalyzerParameter} message SplitAnalyzerParameter message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SplitAnalyzerParameter.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SplitAnalyzerParameter message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.SplitAnalyzerParameter
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.SplitAnalyzerParameter} SplitAnalyzerParameter
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SplitAnalyzerParameter.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.SplitAnalyzerParameter();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.delimiter = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SplitAnalyzerParameter message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.SplitAnalyzerParameter
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.SplitAnalyzerParameter} SplitAnalyzerParameter
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SplitAnalyzerParameter.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SplitAnalyzerParameter message.
             * @function verify
             * @memberof search.proto.SplitAnalyzerParameter
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SplitAnalyzerParameter.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.delimiter != null && message.hasOwnProperty("delimiter"))
                    if (!$util.isString(message.delimiter))
                        return "delimiter: string expected";
                return null;
            };

            /**
             * Creates a SplitAnalyzerParameter message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.SplitAnalyzerParameter
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.SplitAnalyzerParameter} SplitAnalyzerParameter
             */
            SplitAnalyzerParameter.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.SplitAnalyzerParameter)
                    return object;
                var message = new $root.search.proto.SplitAnalyzerParameter();
                if (object.delimiter != null)
                    message.delimiter = String(object.delimiter);
                return message;
            };

            /**
             * Creates a plain object from a SplitAnalyzerParameter message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.SplitAnalyzerParameter
             * @static
             * @param {search.proto.SplitAnalyzerParameter} message SplitAnalyzerParameter
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SplitAnalyzerParameter.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.delimiter = "";
                if (message.delimiter != null && message.hasOwnProperty("delimiter"))
                    object.delimiter = message.delimiter;
                return object;
            };

            /**
             * Converts this SplitAnalyzerParameter to JSON.
             * @function toJSON
             * @memberof search.proto.SplitAnalyzerParameter
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SplitAnalyzerParameter.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SplitAnalyzerParameter;
        })();

        proto.FuzzyAnalyzerParameter = (function() {

            /**
             * Properties of a FuzzyAnalyzerParameter.
             * @memberof search.proto
             * @interface IFuzzyAnalyzerParameter
             * @property {number|null} [minChars] FuzzyAnalyzerParameter minChars
             * @property {number|null} [maxChars] FuzzyAnalyzerParameter maxChars
             */

            /**
             * Constructs a new FuzzyAnalyzerParameter.
             * @memberof search.proto
             * @classdesc Represents a FuzzyAnalyzerParameter.
             * @implements IFuzzyAnalyzerParameter
             * @constructor
             * @param {search.proto.IFuzzyAnalyzerParameter=} [properties] Properties to set
             */
            function FuzzyAnalyzerParameter(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FuzzyAnalyzerParameter minChars.
             * @member {number} minChars
             * @memberof search.proto.FuzzyAnalyzerParameter
             * @instance
             */
            FuzzyAnalyzerParameter.prototype.minChars = 0;

            /**
             * FuzzyAnalyzerParameter maxChars.
             * @member {number} maxChars
             * @memberof search.proto.FuzzyAnalyzerParameter
             * @instance
             */
            FuzzyAnalyzerParameter.prototype.maxChars = 0;

            /**
             * Creates a new FuzzyAnalyzerParameter instance using the specified properties.
             * @function create
             * @memberof search.proto.FuzzyAnalyzerParameter
             * @static
             * @param {search.proto.IFuzzyAnalyzerParameter=} [properties] Properties to set
             * @returns {search.proto.FuzzyAnalyzerParameter} FuzzyAnalyzerParameter instance
             */
            FuzzyAnalyzerParameter.create = function create(properties) {
                return new FuzzyAnalyzerParameter(properties);
            };

            /**
             * Encodes the specified FuzzyAnalyzerParameter message. Does not implicitly {@link search.proto.FuzzyAnalyzerParameter.verify|verify} messages.
             * @function encode
             * @memberof search.proto.FuzzyAnalyzerParameter
             * @static
             * @param {search.proto.IFuzzyAnalyzerParameter} message FuzzyAnalyzerParameter message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FuzzyAnalyzerParameter.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.minChars != null && Object.hasOwnProperty.call(message, "minChars"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.minChars);
                if (message.maxChars != null && Object.hasOwnProperty.call(message, "maxChars"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.maxChars);
                return writer;
            };

            /**
             * Encodes the specified FuzzyAnalyzerParameter message, length delimited. Does not implicitly {@link search.proto.FuzzyAnalyzerParameter.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.FuzzyAnalyzerParameter
             * @static
             * @param {search.proto.IFuzzyAnalyzerParameter} message FuzzyAnalyzerParameter message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FuzzyAnalyzerParameter.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FuzzyAnalyzerParameter message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.FuzzyAnalyzerParameter
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.FuzzyAnalyzerParameter} FuzzyAnalyzerParameter
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FuzzyAnalyzerParameter.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.FuzzyAnalyzerParameter();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.minChars = reader.int32();
                        break;
                    case 2:
                        message.maxChars = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FuzzyAnalyzerParameter message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.FuzzyAnalyzerParameter
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.FuzzyAnalyzerParameter} FuzzyAnalyzerParameter
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FuzzyAnalyzerParameter.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FuzzyAnalyzerParameter message.
             * @function verify
             * @memberof search.proto.FuzzyAnalyzerParameter
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FuzzyAnalyzerParameter.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.minChars != null && message.hasOwnProperty("minChars"))
                    if (!$util.isInteger(message.minChars))
                        return "minChars: integer expected";
                if (message.maxChars != null && message.hasOwnProperty("maxChars"))
                    if (!$util.isInteger(message.maxChars))
                        return "maxChars: integer expected";
                return null;
            };

            /**
             * Creates a FuzzyAnalyzerParameter message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.FuzzyAnalyzerParameter
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.FuzzyAnalyzerParameter} FuzzyAnalyzerParameter
             */
            FuzzyAnalyzerParameter.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.FuzzyAnalyzerParameter)
                    return object;
                var message = new $root.search.proto.FuzzyAnalyzerParameter();
                if (object.minChars != null)
                    message.minChars = object.minChars | 0;
                if (object.maxChars != null)
                    message.maxChars = object.maxChars | 0;
                return message;
            };

            /**
             * Creates a plain object from a FuzzyAnalyzerParameter message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.FuzzyAnalyzerParameter
             * @static
             * @param {search.proto.FuzzyAnalyzerParameter} message FuzzyAnalyzerParameter
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FuzzyAnalyzerParameter.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.minChars = 0;
                    object.maxChars = 0;
                }
                if (message.minChars != null && message.hasOwnProperty("minChars"))
                    object.minChars = message.minChars;
                if (message.maxChars != null && message.hasOwnProperty("maxChars"))
                    object.maxChars = message.maxChars;
                return object;
            };

            /**
             * Converts this FuzzyAnalyzerParameter to JSON.
             * @function toJSON
             * @memberof search.proto.FuzzyAnalyzerParameter
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FuzzyAnalyzerParameter.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FuzzyAnalyzerParameter;
        })();

        proto.FieldSchema = (function() {

            /**
             * Properties of a FieldSchema.
             * @memberof search.proto
             * @interface IFieldSchema
             * @property {string|null} [fieldName] FieldSchema fieldName
             * @property {search.proto.FieldType|null} [fieldType] FieldSchema fieldType
             * @property {search.proto.IndexOptions|null} [indexOptions] FieldSchema indexOptions
             * @property {string|null} [analyzer] FieldSchema analyzer
             * @property {boolean|null} [index] FieldSchema index
             * @property {boolean|null} [docValues] FieldSchema docValues
             * @property {boolean|null} [store] FieldSchema store
             * @property {Array.<search.proto.IFieldSchema>|null} [fieldSchemas] FieldSchema fieldSchemas
             * @property {boolean|null} [isArray] FieldSchema isArray
             * @property {Uint8Array|null} [analyzerParameter] FieldSchema analyzerParameter
             * @property {boolean|null} [isVirtualField] FieldSchema isVirtualField
             * @property {Array.<string>|null} [sourceFieldNames] FieldSchema sourceFieldNames
             * @property {Array.<string>|null} [dateFormats] FieldSchema dateFormats
             * @property {boolean|null} [enableHighlighting] FieldSchema enableHighlighting
             * @property {search.proto.IVectorOptions|null} [vectorOptions] FieldSchema vectorOptions
             */

            /**
             * Constructs a new FieldSchema.
             * @memberof search.proto
             * @classdesc Represents a FieldSchema.
             * @implements IFieldSchema
             * @constructor
             * @param {search.proto.IFieldSchema=} [properties] Properties to set
             */
            function FieldSchema(properties) {
                this.fieldSchemas = [];
                this.sourceFieldNames = [];
                this.dateFormats = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FieldSchema fieldName.
             * @member {string} fieldName
             * @memberof search.proto.FieldSchema
             * @instance
             */
            FieldSchema.prototype.fieldName = "";

            /**
             * FieldSchema fieldType.
             * @member {search.proto.FieldType} fieldType
             * @memberof search.proto.FieldSchema
             * @instance
             */
            FieldSchema.prototype.fieldType = 1;

            /**
             * FieldSchema indexOptions.
             * @member {search.proto.IndexOptions} indexOptions
             * @memberof search.proto.FieldSchema
             * @instance
             */
            FieldSchema.prototype.indexOptions = 1;

            /**
             * FieldSchema analyzer.
             * @member {string} analyzer
             * @memberof search.proto.FieldSchema
             * @instance
             */
            FieldSchema.prototype.analyzer = "";

            /**
             * FieldSchema index.
             * @member {boolean} index
             * @memberof search.proto.FieldSchema
             * @instance
             */
            FieldSchema.prototype.index = false;

            /**
             * FieldSchema docValues.
             * @member {boolean} docValues
             * @memberof search.proto.FieldSchema
             * @instance
             */
            FieldSchema.prototype.docValues = false;

            /**
             * FieldSchema store.
             * @member {boolean} store
             * @memberof search.proto.FieldSchema
             * @instance
             */
            FieldSchema.prototype.store = false;

            /**
             * FieldSchema fieldSchemas.
             * @member {Array.<search.proto.IFieldSchema>} fieldSchemas
             * @memberof search.proto.FieldSchema
             * @instance
             */
            FieldSchema.prototype.fieldSchemas = $util.emptyArray;

            /**
             * FieldSchema isArray.
             * @member {boolean} isArray
             * @memberof search.proto.FieldSchema
             * @instance
             */
            FieldSchema.prototype.isArray = false;

            /**
             * FieldSchema analyzerParameter.
             * @member {Uint8Array} analyzerParameter
             * @memberof search.proto.FieldSchema
             * @instance
             */
            FieldSchema.prototype.analyzerParameter = $util.newBuffer([]);

            /**
             * FieldSchema isVirtualField.
             * @member {boolean} isVirtualField
             * @memberof search.proto.FieldSchema
             * @instance
             */
            FieldSchema.prototype.isVirtualField = false;

            /**
             * FieldSchema sourceFieldNames.
             * @member {Array.<string>} sourceFieldNames
             * @memberof search.proto.FieldSchema
             * @instance
             */
            FieldSchema.prototype.sourceFieldNames = $util.emptyArray;

            /**
             * FieldSchema dateFormats.
             * @member {Array.<string>} dateFormats
             * @memberof search.proto.FieldSchema
             * @instance
             */
            FieldSchema.prototype.dateFormats = $util.emptyArray;

            /**
             * FieldSchema enableHighlighting.
             * @member {boolean} enableHighlighting
             * @memberof search.proto.FieldSchema
             * @instance
             */
            FieldSchema.prototype.enableHighlighting = false;

            /**
             * FieldSchema vectorOptions.
             * @member {search.proto.IVectorOptions|null|undefined} vectorOptions
             * @memberof search.proto.FieldSchema
             * @instance
             */
            FieldSchema.prototype.vectorOptions = null;

            /**
             * Creates a new FieldSchema instance using the specified properties.
             * @function create
             * @memberof search.proto.FieldSchema
             * @static
             * @param {search.proto.IFieldSchema=} [properties] Properties to set
             * @returns {search.proto.FieldSchema} FieldSchema instance
             */
            FieldSchema.create = function create(properties) {
                return new FieldSchema(properties);
            };

            /**
             * Encodes the specified FieldSchema message. Does not implicitly {@link search.proto.FieldSchema.verify|verify} messages.
             * @function encode
             * @memberof search.proto.FieldSchema
             * @static
             * @param {search.proto.IFieldSchema} message FieldSchema message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldSchema.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fieldName != null && Object.hasOwnProperty.call(message, "fieldName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fieldName);
                if (message.fieldType != null && Object.hasOwnProperty.call(message, "fieldType"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.fieldType);
                if (message.indexOptions != null && Object.hasOwnProperty.call(message, "indexOptions"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.indexOptions);
                if (message.analyzer != null && Object.hasOwnProperty.call(message, "analyzer"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.analyzer);
                if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.index);
                if (message.docValues != null && Object.hasOwnProperty.call(message, "docValues"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.docValues);
                if (message.store != null && Object.hasOwnProperty.call(message, "store"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.store);
                if (message.fieldSchemas != null && message.fieldSchemas.length)
                    for (var i = 0; i < message.fieldSchemas.length; ++i)
                        $root.search.proto.FieldSchema.encode(message.fieldSchemas[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.isArray != null && Object.hasOwnProperty.call(message, "isArray"))
                    writer.uint32(/* id 9, wireType 0 =*/72).bool(message.isArray);
                if (message.analyzerParameter != null && Object.hasOwnProperty.call(message, "analyzerParameter"))
                    writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.analyzerParameter);
                if (message.isVirtualField != null && Object.hasOwnProperty.call(message, "isVirtualField"))
                    writer.uint32(/* id 11, wireType 0 =*/88).bool(message.isVirtualField);
                if (message.sourceFieldNames != null && message.sourceFieldNames.length)
                    for (var i = 0; i < message.sourceFieldNames.length; ++i)
                        writer.uint32(/* id 12, wireType 2 =*/98).string(message.sourceFieldNames[i]);
                if (message.dateFormats != null && message.dateFormats.length)
                    for (var i = 0; i < message.dateFormats.length; ++i)
                        writer.uint32(/* id 13, wireType 2 =*/106).string(message.dateFormats[i]);
                if (message.enableHighlighting != null && Object.hasOwnProperty.call(message, "enableHighlighting"))
                    writer.uint32(/* id 14, wireType 0 =*/112).bool(message.enableHighlighting);
                if (message.vectorOptions != null && Object.hasOwnProperty.call(message, "vectorOptions"))
                    $root.search.proto.VectorOptions.encode(message.vectorOptions, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified FieldSchema message, length delimited. Does not implicitly {@link search.proto.FieldSchema.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.FieldSchema
             * @static
             * @param {search.proto.IFieldSchema} message FieldSchema message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldSchema.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FieldSchema message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.FieldSchema
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.FieldSchema} FieldSchema
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldSchema.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.FieldSchema();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fieldName = reader.string();
                        break;
                    case 2:
                        message.fieldType = reader.int32();
                        break;
                    case 3:
                        message.indexOptions = reader.int32();
                        break;
                    case 4:
                        message.analyzer = reader.string();
                        break;
                    case 5:
                        message.index = reader.bool();
                        break;
                    case 6:
                        message.docValues = reader.bool();
                        break;
                    case 7:
                        message.store = reader.bool();
                        break;
                    case 8:
                        if (!(message.fieldSchemas && message.fieldSchemas.length))
                            message.fieldSchemas = [];
                        message.fieldSchemas.push($root.search.proto.FieldSchema.decode(reader, reader.uint32()));
                        break;
                    case 9:
                        message.isArray = reader.bool();
                        break;
                    case 10:
                        message.analyzerParameter = reader.bytes();
                        break;
                    case 11:
                        message.isVirtualField = reader.bool();
                        break;
                    case 12:
                        if (!(message.sourceFieldNames && message.sourceFieldNames.length))
                            message.sourceFieldNames = [];
                        message.sourceFieldNames.push(reader.string());
                        break;
                    case 13:
                        if (!(message.dateFormats && message.dateFormats.length))
                            message.dateFormats = [];
                        message.dateFormats.push(reader.string());
                        break;
                    case 14:
                        message.enableHighlighting = reader.bool();
                        break;
                    case 15:
                        message.vectorOptions = $root.search.proto.VectorOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FieldSchema message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.FieldSchema
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.FieldSchema} FieldSchema
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldSchema.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FieldSchema message.
             * @function verify
             * @memberof search.proto.FieldSchema
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FieldSchema.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    if (!$util.isString(message.fieldName))
                        return "fieldName: string expected";
                if (message.fieldType != null && message.hasOwnProperty("fieldType"))
                    switch (message.fieldType) {
                    default:
                        return "fieldType: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                        break;
                    }
                if (message.indexOptions != null && message.hasOwnProperty("indexOptions"))
                    switch (message.indexOptions) {
                    default:
                        return "indexOptions: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                if (message.analyzer != null && message.hasOwnProperty("analyzer"))
                    if (!$util.isString(message.analyzer))
                        return "analyzer: string expected";
                if (message.index != null && message.hasOwnProperty("index"))
                    if (typeof message.index !== "boolean")
                        return "index: boolean expected";
                if (message.docValues != null && message.hasOwnProperty("docValues"))
                    if (typeof message.docValues !== "boolean")
                        return "docValues: boolean expected";
                if (message.store != null && message.hasOwnProperty("store"))
                    if (typeof message.store !== "boolean")
                        return "store: boolean expected";
                if (message.fieldSchemas != null && message.hasOwnProperty("fieldSchemas")) {
                    if (!Array.isArray(message.fieldSchemas))
                        return "fieldSchemas: array expected";
                    for (var i = 0; i < message.fieldSchemas.length; ++i) {
                        var error = $root.search.proto.FieldSchema.verify(message.fieldSchemas[i]);
                        if (error)
                            return "fieldSchemas." + error;
                    }
                }
                if (message.isArray != null && message.hasOwnProperty("isArray"))
                    if (typeof message.isArray !== "boolean")
                        return "isArray: boolean expected";
                if (message.analyzerParameter != null && message.hasOwnProperty("analyzerParameter"))
                    if (!(message.analyzerParameter && typeof message.analyzerParameter.length === "number" || $util.isString(message.analyzerParameter)))
                        return "analyzerParameter: buffer expected";
                if (message.isVirtualField != null && message.hasOwnProperty("isVirtualField"))
                    if (typeof message.isVirtualField !== "boolean")
                        return "isVirtualField: boolean expected";
                if (message.sourceFieldNames != null && message.hasOwnProperty("sourceFieldNames")) {
                    if (!Array.isArray(message.sourceFieldNames))
                        return "sourceFieldNames: array expected";
                    for (var i = 0; i < message.sourceFieldNames.length; ++i)
                        if (!$util.isString(message.sourceFieldNames[i]))
                            return "sourceFieldNames: string[] expected";
                }
                if (message.dateFormats != null && message.hasOwnProperty("dateFormats")) {
                    if (!Array.isArray(message.dateFormats))
                        return "dateFormats: array expected";
                    for (var i = 0; i < message.dateFormats.length; ++i)
                        if (!$util.isString(message.dateFormats[i]))
                            return "dateFormats: string[] expected";
                }
                if (message.enableHighlighting != null && message.hasOwnProperty("enableHighlighting"))
                    if (typeof message.enableHighlighting !== "boolean")
                        return "enableHighlighting: boolean expected";
                if (message.vectorOptions != null && message.hasOwnProperty("vectorOptions")) {
                    var error = $root.search.proto.VectorOptions.verify(message.vectorOptions);
                    if (error)
                        return "vectorOptions." + error;
                }
                return null;
            };

            /**
             * Creates a FieldSchema message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.FieldSchema
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.FieldSchema} FieldSchema
             */
            FieldSchema.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.FieldSchema)
                    return object;
                var message = new $root.search.proto.FieldSchema();
                if (object.fieldName != null)
                    message.fieldName = String(object.fieldName);
                switch (object.fieldType) {
                case "LONG":
                case 1:
                    message.fieldType = 1;
                    break;
                case "DOUBLE":
                case 2:
                    message.fieldType = 2;
                    break;
                case "BOOLEAN":
                case 3:
                    message.fieldType = 3;
                    break;
                case "KEYWORD":
                case 4:
                    message.fieldType = 4;
                    break;
                case "TEXT":
                case 5:
                    message.fieldType = 5;
                    break;
                case "NESTED":
                case 6:
                    message.fieldType = 6;
                    break;
                case "GEO_POINT":
                case 7:
                    message.fieldType = 7;
                    break;
                case "DATE":
                case 8:
                    message.fieldType = 8;
                    break;
                case "VECTOR":
                case 9:
                    message.fieldType = 9;
                    break;
                }
                switch (object.indexOptions) {
                case "DOCS":
                case 1:
                    message.indexOptions = 1;
                    break;
                case "FREQS":
                case 2:
                    message.indexOptions = 2;
                    break;
                case "POSITIONS":
                case 3:
                    message.indexOptions = 3;
                    break;
                case "OFFSETS":
                case 4:
                    message.indexOptions = 4;
                    break;
                }
                if (object.analyzer != null)
                    message.analyzer = String(object.analyzer);
                if (object.index != null)
                    message.index = Boolean(object.index);
                if (object.docValues != null)
                    message.docValues = Boolean(object.docValues);
                if (object.store != null)
                    message.store = Boolean(object.store);
                if (object.fieldSchemas) {
                    if (!Array.isArray(object.fieldSchemas))
                        throw TypeError(".search.proto.FieldSchema.fieldSchemas: array expected");
                    message.fieldSchemas = [];
                    for (var i = 0; i < object.fieldSchemas.length; ++i) {
                        if (typeof object.fieldSchemas[i] !== "object")
                            throw TypeError(".search.proto.FieldSchema.fieldSchemas: object expected");
                        message.fieldSchemas[i] = $root.search.proto.FieldSchema.fromObject(object.fieldSchemas[i]);
                    }
                }
                if (object.isArray != null)
                    message.isArray = Boolean(object.isArray);
                if (object.analyzerParameter != null)
                    if (typeof object.analyzerParameter === "string")
                        $util.base64.decode(object.analyzerParameter, message.analyzerParameter = $util.newBuffer($util.base64.length(object.analyzerParameter)), 0);
                    else if (object.analyzerParameter.length)
                        message.analyzerParameter = object.analyzerParameter;
                if (object.isVirtualField != null)
                    message.isVirtualField = Boolean(object.isVirtualField);
                if (object.sourceFieldNames) {
                    if (!Array.isArray(object.sourceFieldNames))
                        throw TypeError(".search.proto.FieldSchema.sourceFieldNames: array expected");
                    message.sourceFieldNames = [];
                    for (var i = 0; i < object.sourceFieldNames.length; ++i)
                        message.sourceFieldNames[i] = String(object.sourceFieldNames[i]);
                }
                if (object.dateFormats) {
                    if (!Array.isArray(object.dateFormats))
                        throw TypeError(".search.proto.FieldSchema.dateFormats: array expected");
                    message.dateFormats = [];
                    for (var i = 0; i < object.dateFormats.length; ++i)
                        message.dateFormats[i] = String(object.dateFormats[i]);
                }
                if (object.enableHighlighting != null)
                    message.enableHighlighting = Boolean(object.enableHighlighting);
                if (object.vectorOptions != null) {
                    if (typeof object.vectorOptions !== "object")
                        throw TypeError(".search.proto.FieldSchema.vectorOptions: object expected");
                    message.vectorOptions = $root.search.proto.VectorOptions.fromObject(object.vectorOptions);
                }
                return message;
            };

            /**
             * Creates a plain object from a FieldSchema message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.FieldSchema
             * @static
             * @param {search.proto.FieldSchema} message FieldSchema
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FieldSchema.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.fieldSchemas = [];
                    object.sourceFieldNames = [];
                    object.dateFormats = [];
                }
                if (options.defaults) {
                    object.fieldName = "";
                    object.fieldType = options.enums === String ? "LONG" : 1;
                    object.indexOptions = options.enums === String ? "DOCS" : 1;
                    object.analyzer = "";
                    object.index = false;
                    object.docValues = false;
                    object.store = false;
                    object.isArray = false;
                    if (options.bytes === String)
                        object.analyzerParameter = "";
                    else {
                        object.analyzerParameter = [];
                        if (options.bytes !== Array)
                            object.analyzerParameter = $util.newBuffer(object.analyzerParameter);
                    }
                    object.isVirtualField = false;
                    object.enableHighlighting = false;
                    object.vectorOptions = null;
                }
                if (message.fieldName != null && message.hasOwnProperty("fieldName"))
                    object.fieldName = message.fieldName;
                if (message.fieldType != null && message.hasOwnProperty("fieldType"))
                    object.fieldType = options.enums === String ? $root.search.proto.FieldType[message.fieldType] : message.fieldType;
                if (message.indexOptions != null && message.hasOwnProperty("indexOptions"))
                    object.indexOptions = options.enums === String ? $root.search.proto.IndexOptions[message.indexOptions] : message.indexOptions;
                if (message.analyzer != null && message.hasOwnProperty("analyzer"))
                    object.analyzer = message.analyzer;
                if (message.index != null && message.hasOwnProperty("index"))
                    object.index = message.index;
                if (message.docValues != null && message.hasOwnProperty("docValues"))
                    object.docValues = message.docValues;
                if (message.store != null && message.hasOwnProperty("store"))
                    object.store = message.store;
                if (message.fieldSchemas && message.fieldSchemas.length) {
                    object.fieldSchemas = [];
                    for (var j = 0; j < message.fieldSchemas.length; ++j)
                        object.fieldSchemas[j] = $root.search.proto.FieldSchema.toObject(message.fieldSchemas[j], options);
                }
                if (message.isArray != null && message.hasOwnProperty("isArray"))
                    object.isArray = message.isArray;
                if (message.analyzerParameter != null && message.hasOwnProperty("analyzerParameter"))
                    object.analyzerParameter = options.bytes === String ? $util.base64.encode(message.analyzerParameter, 0, message.analyzerParameter.length) : options.bytes === Array ? Array.prototype.slice.call(message.analyzerParameter) : message.analyzerParameter;
                if (message.isVirtualField != null && message.hasOwnProperty("isVirtualField"))
                    object.isVirtualField = message.isVirtualField;
                if (message.sourceFieldNames && message.sourceFieldNames.length) {
                    object.sourceFieldNames = [];
                    for (var j = 0; j < message.sourceFieldNames.length; ++j)
                        object.sourceFieldNames[j] = message.sourceFieldNames[j];
                }
                if (message.dateFormats && message.dateFormats.length) {
                    object.dateFormats = [];
                    for (var j = 0; j < message.dateFormats.length; ++j)
                        object.dateFormats[j] = message.dateFormats[j];
                }
                if (message.enableHighlighting != null && message.hasOwnProperty("enableHighlighting"))
                    object.enableHighlighting = message.enableHighlighting;
                if (message.vectorOptions != null && message.hasOwnProperty("vectorOptions"))
                    object.vectorOptions = $root.search.proto.VectorOptions.toObject(message.vectorOptions, options);
                return object;
            };

            /**
             * Converts this FieldSchema to JSON.
             * @function toJSON
             * @memberof search.proto.FieldSchema
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FieldSchema.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FieldSchema;
        })();

        /**
         * VectorDataType enum.
         * @name search.proto.VectorDataType
         * @enum {number}
         * @property {number} VD_FLOAT_32=2 VD_FLOAT_32 value
         */
        proto.VectorDataType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[2] = "VD_FLOAT_32"] = 2;
            return values;
        })();

        proto.VectorOptions = (function() {

            /**
             * Properties of a VectorOptions.
             * @memberof search.proto
             * @interface IVectorOptions
             * @property {search.proto.VectorDataType|null} [dataType] VectorOptions dataType
             * @property {number|null} [dimension] VectorOptions dimension
             * @property {search.proto.VectorMetricType|null} [metricType] VectorOptions metricType
             */

            /**
             * Constructs a new VectorOptions.
             * @memberof search.proto
             * @classdesc Represents a VectorOptions.
             * @implements IVectorOptions
             * @constructor
             * @param {search.proto.IVectorOptions=} [properties] Properties to set
             */
            function VectorOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * VectorOptions dataType.
             * @member {search.proto.VectorDataType} dataType
             * @memberof search.proto.VectorOptions
             * @instance
             */
            VectorOptions.prototype.dataType = 2;

            /**
             * VectorOptions dimension.
             * @member {number} dimension
             * @memberof search.proto.VectorOptions
             * @instance
             */
            VectorOptions.prototype.dimension = 0;

            /**
             * VectorOptions metricType.
             * @member {search.proto.VectorMetricType} metricType
             * @memberof search.proto.VectorOptions
             * @instance
             */
            VectorOptions.prototype.metricType = 0;

            /**
             * Creates a new VectorOptions instance using the specified properties.
             * @function create
             * @memberof search.proto.VectorOptions
             * @static
             * @param {search.proto.IVectorOptions=} [properties] Properties to set
             * @returns {search.proto.VectorOptions} VectorOptions instance
             */
            VectorOptions.create = function create(properties) {
                return new VectorOptions(properties);
            };

            /**
             * Encodes the specified VectorOptions message. Does not implicitly {@link search.proto.VectorOptions.verify|verify} messages.
             * @function encode
             * @memberof search.proto.VectorOptions
             * @static
             * @param {search.proto.IVectorOptions} message VectorOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VectorOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.dataType != null && Object.hasOwnProperty.call(message, "dataType"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.dataType);
                if (message.dimension != null && Object.hasOwnProperty.call(message, "dimension"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.dimension);
                if (message.metricType != null && Object.hasOwnProperty.call(message, "metricType"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.metricType);
                return writer;
            };

            /**
             * Encodes the specified VectorOptions message, length delimited. Does not implicitly {@link search.proto.VectorOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.VectorOptions
             * @static
             * @param {search.proto.IVectorOptions} message VectorOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VectorOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a VectorOptions message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.VectorOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.VectorOptions} VectorOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VectorOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.VectorOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.dataType = reader.int32();
                        break;
                    case 2:
                        message.dimension = reader.int32();
                        break;
                    case 3:
                        message.metricType = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a VectorOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.VectorOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.VectorOptions} VectorOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VectorOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a VectorOptions message.
             * @function verify
             * @memberof search.proto.VectorOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            VectorOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.dataType != null && message.hasOwnProperty("dataType"))
                    switch (message.dataType) {
                    default:
                        return "dataType: enum value expected";
                    case 2:
                        break;
                    }
                if (message.dimension != null && message.hasOwnProperty("dimension"))
                    if (!$util.isInteger(message.dimension))
                        return "dimension: integer expected";
                if (message.metricType != null && message.hasOwnProperty("metricType"))
                    switch (message.metricType) {
                    default:
                        return "metricType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };

            /**
             * Creates a VectorOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.VectorOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.VectorOptions} VectorOptions
             */
            VectorOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.VectorOptions)
                    return object;
                var message = new $root.search.proto.VectorOptions();
                switch (object.dataType) {
                case "VD_FLOAT_32":
                case 2:
                    message.dataType = 2;
                    break;
                }
                if (object.dimension != null)
                    message.dimension = object.dimension | 0;
                switch (object.metricType) {
                case "VM_EUCLIDEAN":
                case 0:
                    message.metricType = 0;
                    break;
                case "VM_COSINE":
                case 1:
                    message.metricType = 1;
                    break;
                case "VM_DOT_PRODUCT":
                case 2:
                    message.metricType = 2;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a VectorOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.VectorOptions
             * @static
             * @param {search.proto.VectorOptions} message VectorOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            VectorOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.dataType = options.enums === String ? "VD_FLOAT_32" : 2;
                    object.dimension = 0;
                    object.metricType = options.enums === String ? "VM_EUCLIDEAN" : 0;
                }
                if (message.dataType != null && message.hasOwnProperty("dataType"))
                    object.dataType = options.enums === String ? $root.search.proto.VectorDataType[message.dataType] : message.dataType;
                if (message.dimension != null && message.hasOwnProperty("dimension"))
                    object.dimension = message.dimension;
                if (message.metricType != null && message.hasOwnProperty("metricType"))
                    object.metricType = options.enums === String ? $root.search.proto.VectorMetricType[message.metricType] : message.metricType;
                return object;
            };

            /**
             * Converts this VectorOptions to JSON.
             * @function toJSON
             * @memberof search.proto.VectorOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            VectorOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return VectorOptions;
        })();

        /**
         * VectorMetricType enum.
         * @name search.proto.VectorMetricType
         * @enum {number}
         * @property {number} VM_EUCLIDEAN=0 VM_EUCLIDEAN value
         * @property {number} VM_COSINE=1 VM_COSINE value
         * @property {number} VM_DOT_PRODUCT=2 VM_DOT_PRODUCT value
         */
        proto.VectorMetricType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "VM_EUCLIDEAN"] = 0;
            values[valuesById[1] = "VM_COSINE"] = 1;
            values[valuesById[2] = "VM_DOT_PRODUCT"] = 2;
            return values;
        })();

        proto.IndexSchema = (function() {

            /**
             * Properties of an IndexSchema.
             * @memberof search.proto
             * @interface IIndexSchema
             * @property {Array.<search.proto.IFieldSchema>|null} [fieldSchemas] IndexSchema fieldSchemas
             * @property {search.proto.IIndexSetting|null} [indexSetting] IndexSchema indexSetting
             * @property {search.proto.ISort|null} [indexSort] IndexSchema indexSort
             */

            /**
             * Constructs a new IndexSchema.
             * @memberof search.proto
             * @classdesc Represents an IndexSchema.
             * @implements IIndexSchema
             * @constructor
             * @param {search.proto.IIndexSchema=} [properties] Properties to set
             */
            function IndexSchema(properties) {
                this.fieldSchemas = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * IndexSchema fieldSchemas.
             * @member {Array.<search.proto.IFieldSchema>} fieldSchemas
             * @memberof search.proto.IndexSchema
             * @instance
             */
            IndexSchema.prototype.fieldSchemas = $util.emptyArray;

            /**
             * IndexSchema indexSetting.
             * @member {search.proto.IIndexSetting|null|undefined} indexSetting
             * @memberof search.proto.IndexSchema
             * @instance
             */
            IndexSchema.prototype.indexSetting = null;

            /**
             * IndexSchema indexSort.
             * @member {search.proto.ISort|null|undefined} indexSort
             * @memberof search.proto.IndexSchema
             * @instance
             */
            IndexSchema.prototype.indexSort = null;

            /**
             * Creates a new IndexSchema instance using the specified properties.
             * @function create
             * @memberof search.proto.IndexSchema
             * @static
             * @param {search.proto.IIndexSchema=} [properties] Properties to set
             * @returns {search.proto.IndexSchema} IndexSchema instance
             */
            IndexSchema.create = function create(properties) {
                return new IndexSchema(properties);
            };

            /**
             * Encodes the specified IndexSchema message. Does not implicitly {@link search.proto.IndexSchema.verify|verify} messages.
             * @function encode
             * @memberof search.proto.IndexSchema
             * @static
             * @param {search.proto.IIndexSchema} message IndexSchema message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IndexSchema.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fieldSchemas != null && message.fieldSchemas.length)
                    for (var i = 0; i < message.fieldSchemas.length; ++i)
                        $root.search.proto.FieldSchema.encode(message.fieldSchemas[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.indexSetting != null && Object.hasOwnProperty.call(message, "indexSetting"))
                    $root.search.proto.IndexSetting.encode(message.indexSetting, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.indexSort != null && Object.hasOwnProperty.call(message, "indexSort"))
                    $root.search.proto.Sort.encode(message.indexSort, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified IndexSchema message, length delimited. Does not implicitly {@link search.proto.IndexSchema.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.IndexSchema
             * @static
             * @param {search.proto.IIndexSchema} message IndexSchema message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IndexSchema.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an IndexSchema message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.IndexSchema
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.IndexSchema} IndexSchema
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IndexSchema.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.IndexSchema();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.fieldSchemas && message.fieldSchemas.length))
                            message.fieldSchemas = [];
                        message.fieldSchemas.push($root.search.proto.FieldSchema.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.indexSetting = $root.search.proto.IndexSetting.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.indexSort = $root.search.proto.Sort.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an IndexSchema message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.IndexSchema
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.IndexSchema} IndexSchema
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IndexSchema.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an IndexSchema message.
             * @function verify
             * @memberof search.proto.IndexSchema
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            IndexSchema.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fieldSchemas != null && message.hasOwnProperty("fieldSchemas")) {
                    if (!Array.isArray(message.fieldSchemas))
                        return "fieldSchemas: array expected";
                    for (var i = 0; i < message.fieldSchemas.length; ++i) {
                        var error = $root.search.proto.FieldSchema.verify(message.fieldSchemas[i]);
                        if (error)
                            return "fieldSchemas." + error;
                    }
                }
                if (message.indexSetting != null && message.hasOwnProperty("indexSetting")) {
                    var error = $root.search.proto.IndexSetting.verify(message.indexSetting);
                    if (error)
                        return "indexSetting." + error;
                }
                if (message.indexSort != null && message.hasOwnProperty("indexSort")) {
                    var error = $root.search.proto.Sort.verify(message.indexSort);
                    if (error)
                        return "indexSort." + error;
                }
                return null;
            };

            /**
             * Creates an IndexSchema message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.IndexSchema
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.IndexSchema} IndexSchema
             */
            IndexSchema.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.IndexSchema)
                    return object;
                var message = new $root.search.proto.IndexSchema();
                if (object.fieldSchemas) {
                    if (!Array.isArray(object.fieldSchemas))
                        throw TypeError(".search.proto.IndexSchema.fieldSchemas: array expected");
                    message.fieldSchemas = [];
                    for (var i = 0; i < object.fieldSchemas.length; ++i) {
                        if (typeof object.fieldSchemas[i] !== "object")
                            throw TypeError(".search.proto.IndexSchema.fieldSchemas: object expected");
                        message.fieldSchemas[i] = $root.search.proto.FieldSchema.fromObject(object.fieldSchemas[i]);
                    }
                }
                if (object.indexSetting != null) {
                    if (typeof object.indexSetting !== "object")
                        throw TypeError(".search.proto.IndexSchema.indexSetting: object expected");
                    message.indexSetting = $root.search.proto.IndexSetting.fromObject(object.indexSetting);
                }
                if (object.indexSort != null) {
                    if (typeof object.indexSort !== "object")
                        throw TypeError(".search.proto.IndexSchema.indexSort: object expected");
                    message.indexSort = $root.search.proto.Sort.fromObject(object.indexSort);
                }
                return message;
            };

            /**
             * Creates a plain object from an IndexSchema message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.IndexSchema
             * @static
             * @param {search.proto.IndexSchema} message IndexSchema
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            IndexSchema.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.fieldSchemas = [];
                if (options.defaults) {
                    object.indexSetting = null;
                    object.indexSort = null;
                }
                if (message.fieldSchemas && message.fieldSchemas.length) {
                    object.fieldSchemas = [];
                    for (var j = 0; j < message.fieldSchemas.length; ++j)
                        object.fieldSchemas[j] = $root.search.proto.FieldSchema.toObject(message.fieldSchemas[j], options);
                }
                if (message.indexSetting != null && message.hasOwnProperty("indexSetting"))
                    object.indexSetting = $root.search.proto.IndexSetting.toObject(message.indexSetting, options);
                if (message.indexSort != null && message.hasOwnProperty("indexSort"))
                    object.indexSort = $root.search.proto.Sort.toObject(message.indexSort, options);
                return object;
            };

            /**
             * Converts this IndexSchema to JSON.
             * @function toJSON
             * @memberof search.proto.IndexSchema
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            IndexSchema.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return IndexSchema;
        })();

        proto.IndexSetting = (function() {

            /**
             * Properties of an IndexSetting.
             * @memberof search.proto
             * @interface IIndexSetting
             * @property {number|null} [numberOfShards] IndexSetting numberOfShards
             * @property {Array.<string>|null} [routingFields] IndexSetting routingFields
             * @property {number|null} [routingPartitionSize] IndexSetting routingPartitionSize
             */

            /**
             * Constructs a new IndexSetting.
             * @memberof search.proto
             * @classdesc Represents an IndexSetting.
             * @implements IIndexSetting
             * @constructor
             * @param {search.proto.IIndexSetting=} [properties] Properties to set
             */
            function IndexSetting(properties) {
                this.routingFields = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * IndexSetting numberOfShards.
             * @member {number} numberOfShards
             * @memberof search.proto.IndexSetting
             * @instance
             */
            IndexSetting.prototype.numberOfShards = 0;

            /**
             * IndexSetting routingFields.
             * @member {Array.<string>} routingFields
             * @memberof search.proto.IndexSetting
             * @instance
             */
            IndexSetting.prototype.routingFields = $util.emptyArray;

            /**
             * IndexSetting routingPartitionSize.
             * @member {number} routingPartitionSize
             * @memberof search.proto.IndexSetting
             * @instance
             */
            IndexSetting.prototype.routingPartitionSize = 0;

            /**
             * Creates a new IndexSetting instance using the specified properties.
             * @function create
             * @memberof search.proto.IndexSetting
             * @static
             * @param {search.proto.IIndexSetting=} [properties] Properties to set
             * @returns {search.proto.IndexSetting} IndexSetting instance
             */
            IndexSetting.create = function create(properties) {
                return new IndexSetting(properties);
            };

            /**
             * Encodes the specified IndexSetting message. Does not implicitly {@link search.proto.IndexSetting.verify|verify} messages.
             * @function encode
             * @memberof search.proto.IndexSetting
             * @static
             * @param {search.proto.IIndexSetting} message IndexSetting message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IndexSetting.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.numberOfShards != null && Object.hasOwnProperty.call(message, "numberOfShards"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.numberOfShards);
                if (message.routingFields != null && message.routingFields.length)
                    for (var i = 0; i < message.routingFields.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.routingFields[i]);
                if (message.routingPartitionSize != null && Object.hasOwnProperty.call(message, "routingPartitionSize"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.routingPartitionSize);
                return writer;
            };

            /**
             * Encodes the specified IndexSetting message, length delimited. Does not implicitly {@link search.proto.IndexSetting.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.IndexSetting
             * @static
             * @param {search.proto.IIndexSetting} message IndexSetting message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IndexSetting.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an IndexSetting message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.IndexSetting
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.IndexSetting} IndexSetting
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IndexSetting.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.IndexSetting();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.numberOfShards = reader.int32();
                        break;
                    case 2:
                        if (!(message.routingFields && message.routingFields.length))
                            message.routingFields = [];
                        message.routingFields.push(reader.string());
                        break;
                    case 3:
                        message.routingPartitionSize = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an IndexSetting message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.IndexSetting
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.IndexSetting} IndexSetting
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IndexSetting.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an IndexSetting message.
             * @function verify
             * @memberof search.proto.IndexSetting
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            IndexSetting.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.numberOfShards != null && message.hasOwnProperty("numberOfShards"))
                    if (!$util.isInteger(message.numberOfShards))
                        return "numberOfShards: integer expected";
                if (message.routingFields != null && message.hasOwnProperty("routingFields")) {
                    if (!Array.isArray(message.routingFields))
                        return "routingFields: array expected";
                    for (var i = 0; i < message.routingFields.length; ++i)
                        if (!$util.isString(message.routingFields[i]))
                            return "routingFields: string[] expected";
                }
                if (message.routingPartitionSize != null && message.hasOwnProperty("routingPartitionSize"))
                    if (!$util.isInteger(message.routingPartitionSize))
                        return "routingPartitionSize: integer expected";
                return null;
            };

            /**
             * Creates an IndexSetting message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.IndexSetting
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.IndexSetting} IndexSetting
             */
            IndexSetting.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.IndexSetting)
                    return object;
                var message = new $root.search.proto.IndexSetting();
                if (object.numberOfShards != null)
                    message.numberOfShards = object.numberOfShards | 0;
                if (object.routingFields) {
                    if (!Array.isArray(object.routingFields))
                        throw TypeError(".search.proto.IndexSetting.routingFields: array expected");
                    message.routingFields = [];
                    for (var i = 0; i < object.routingFields.length; ++i)
                        message.routingFields[i] = String(object.routingFields[i]);
                }
                if (object.routingPartitionSize != null)
                    message.routingPartitionSize = object.routingPartitionSize | 0;
                return message;
            };

            /**
             * Creates a plain object from an IndexSetting message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.IndexSetting
             * @static
             * @param {search.proto.IndexSetting} message IndexSetting
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            IndexSetting.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.routingFields = [];
                if (options.defaults) {
                    object.numberOfShards = 0;
                    object.routingPartitionSize = 0;
                }
                if (message.numberOfShards != null && message.hasOwnProperty("numberOfShards"))
                    object.numberOfShards = message.numberOfShards;
                if (message.routingFields && message.routingFields.length) {
                    object.routingFields = [];
                    for (var j = 0; j < message.routingFields.length; ++j)
                        object.routingFields[j] = message.routingFields[j];
                }
                if (message.routingPartitionSize != null && message.hasOwnProperty("routingPartitionSize"))
                    object.routingPartitionSize = message.routingPartitionSize;
                return object;
            };

            /**
             * Converts this IndexSetting to JSON.
             * @function toJSON
             * @memberof search.proto.IndexSetting
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            IndexSetting.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return IndexSetting;
        })();

        proto.CreateSearchIndexRequest = (function() {

            /**
             * Properties of a CreateSearchIndexRequest.
             * @memberof search.proto
             * @interface ICreateSearchIndexRequest
             * @property {string} tableName CreateSearchIndexRequest tableName
             * @property {string} indexName CreateSearchIndexRequest indexName
             * @property {search.proto.IIndexSchema|null} [schema] CreateSearchIndexRequest schema
             * @property {string|null} [sourceIndexName] CreateSearchIndexRequest sourceIndexName
             * @property {number|null} [timeToLive] CreateSearchIndexRequest timeToLive
             */

            /**
             * Constructs a new CreateSearchIndexRequest.
             * @memberof search.proto
             * @classdesc Represents a CreateSearchIndexRequest.
             * @implements ICreateSearchIndexRequest
             * @constructor
             * @param {search.proto.ICreateSearchIndexRequest=} [properties] Properties to set
             */
            function CreateSearchIndexRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreateSearchIndexRequest tableName.
             * @member {string} tableName
             * @memberof search.proto.CreateSearchIndexRequest
             * @instance
             */
            CreateSearchIndexRequest.prototype.tableName = "";

            /**
             * CreateSearchIndexRequest indexName.
             * @member {string} indexName
             * @memberof search.proto.CreateSearchIndexRequest
             * @instance
             */
            CreateSearchIndexRequest.prototype.indexName = "";

            /**
             * CreateSearchIndexRequest schema.
             * @member {search.proto.IIndexSchema|null|undefined} schema
             * @memberof search.proto.CreateSearchIndexRequest
             * @instance
             */
            CreateSearchIndexRequest.prototype.schema = null;

            /**
             * CreateSearchIndexRequest sourceIndexName.
             * @member {string} sourceIndexName
             * @memberof search.proto.CreateSearchIndexRequest
             * @instance
             */
            CreateSearchIndexRequest.prototype.sourceIndexName = "";

            /**
             * CreateSearchIndexRequest timeToLive.
             * @member {number} timeToLive
             * @memberof search.proto.CreateSearchIndexRequest
             * @instance
             */
            CreateSearchIndexRequest.prototype.timeToLive = 0;

            /**
             * Creates a new CreateSearchIndexRequest instance using the specified properties.
             * @function create
             * @memberof search.proto.CreateSearchIndexRequest
             * @static
             * @param {search.proto.ICreateSearchIndexRequest=} [properties] Properties to set
             * @returns {search.proto.CreateSearchIndexRequest} CreateSearchIndexRequest instance
             */
            CreateSearchIndexRequest.create = function create(properties) {
                return new CreateSearchIndexRequest(properties);
            };

            /**
             * Encodes the specified CreateSearchIndexRequest message. Does not implicitly {@link search.proto.CreateSearchIndexRequest.verify|verify} messages.
             * @function encode
             * @memberof search.proto.CreateSearchIndexRequest
             * @static
             * @param {search.proto.ICreateSearchIndexRequest} message CreateSearchIndexRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateSearchIndexRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.tableName);
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.indexName);
                if (message.schema != null && Object.hasOwnProperty.call(message, "schema"))
                    $root.search.proto.IndexSchema.encode(message.schema, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.sourceIndexName != null && Object.hasOwnProperty.call(message, "sourceIndexName"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.sourceIndexName);
                if (message.timeToLive != null && Object.hasOwnProperty.call(message, "timeToLive"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.timeToLive);
                return writer;
            };

            /**
             * Encodes the specified CreateSearchIndexRequest message, length delimited. Does not implicitly {@link search.proto.CreateSearchIndexRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.CreateSearchIndexRequest
             * @static
             * @param {search.proto.ICreateSearchIndexRequest} message CreateSearchIndexRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateSearchIndexRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateSearchIndexRequest message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.CreateSearchIndexRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.CreateSearchIndexRequest} CreateSearchIndexRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateSearchIndexRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.CreateSearchIndexRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tableName = reader.string();
                        break;
                    case 2:
                        message.indexName = reader.string();
                        break;
                    case 3:
                        message.schema = $root.search.proto.IndexSchema.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.sourceIndexName = reader.string();
                        break;
                    case 5:
                        message.timeToLive = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("tableName"))
                    throw $util.ProtocolError("missing required 'tableName'", { instance: message });
                if (!message.hasOwnProperty("indexName"))
                    throw $util.ProtocolError("missing required 'indexName'", { instance: message });
                return message;
            };

            /**
             * Decodes a CreateSearchIndexRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.CreateSearchIndexRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.CreateSearchIndexRequest} CreateSearchIndexRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateSearchIndexRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateSearchIndexRequest message.
             * @function verify
             * @memberof search.proto.CreateSearchIndexRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateSearchIndexRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.tableName))
                    return "tableName: string expected";
                if (!$util.isString(message.indexName))
                    return "indexName: string expected";
                if (message.schema != null && message.hasOwnProperty("schema")) {
                    var error = $root.search.proto.IndexSchema.verify(message.schema);
                    if (error)
                        return "schema." + error;
                }
                if (message.sourceIndexName != null && message.hasOwnProperty("sourceIndexName"))
                    if (!$util.isString(message.sourceIndexName))
                        return "sourceIndexName: string expected";
                if (message.timeToLive != null && message.hasOwnProperty("timeToLive"))
                    if (!$util.isInteger(message.timeToLive))
                        return "timeToLive: integer expected";
                return null;
            };

            /**
             * Creates a CreateSearchIndexRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.CreateSearchIndexRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.CreateSearchIndexRequest} CreateSearchIndexRequest
             */
            CreateSearchIndexRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.CreateSearchIndexRequest)
                    return object;
                var message = new $root.search.proto.CreateSearchIndexRequest();
                if (object.tableName != null)
                    message.tableName = String(object.tableName);
                if (object.indexName != null)
                    message.indexName = String(object.indexName);
                if (object.schema != null) {
                    if (typeof object.schema !== "object")
                        throw TypeError(".search.proto.CreateSearchIndexRequest.schema: object expected");
                    message.schema = $root.search.proto.IndexSchema.fromObject(object.schema);
                }
                if (object.sourceIndexName != null)
                    message.sourceIndexName = String(object.sourceIndexName);
                if (object.timeToLive != null)
                    message.timeToLive = object.timeToLive | 0;
                return message;
            };

            /**
             * Creates a plain object from a CreateSearchIndexRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.CreateSearchIndexRequest
             * @static
             * @param {search.proto.CreateSearchIndexRequest} message CreateSearchIndexRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateSearchIndexRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.tableName = "";
                    object.indexName = "";
                    object.schema = null;
                    object.sourceIndexName = "";
                    object.timeToLive = 0;
                }
                if (message.tableName != null && message.hasOwnProperty("tableName"))
                    object.tableName = message.tableName;
                if (message.indexName != null && message.hasOwnProperty("indexName"))
                    object.indexName = message.indexName;
                if (message.schema != null && message.hasOwnProperty("schema"))
                    object.schema = $root.search.proto.IndexSchema.toObject(message.schema, options);
                if (message.sourceIndexName != null && message.hasOwnProperty("sourceIndexName"))
                    object.sourceIndexName = message.sourceIndexName;
                if (message.timeToLive != null && message.hasOwnProperty("timeToLive"))
                    object.timeToLive = message.timeToLive;
                return object;
            };

            /**
             * Converts this CreateSearchIndexRequest to JSON.
             * @function toJSON
             * @memberof search.proto.CreateSearchIndexRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateSearchIndexRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CreateSearchIndexRequest;
        })();

        proto.CreateSearchIndexResponse = (function() {

            /**
             * Properties of a CreateSearchIndexResponse.
             * @memberof search.proto
             * @interface ICreateSearchIndexResponse
             */

            /**
             * Constructs a new CreateSearchIndexResponse.
             * @memberof search.proto
             * @classdesc Represents a CreateSearchIndexResponse.
             * @implements ICreateSearchIndexResponse
             * @constructor
             * @param {search.proto.ICreateSearchIndexResponse=} [properties] Properties to set
             */
            function CreateSearchIndexResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new CreateSearchIndexResponse instance using the specified properties.
             * @function create
             * @memberof search.proto.CreateSearchIndexResponse
             * @static
             * @param {search.proto.ICreateSearchIndexResponse=} [properties] Properties to set
             * @returns {search.proto.CreateSearchIndexResponse} CreateSearchIndexResponse instance
             */
            CreateSearchIndexResponse.create = function create(properties) {
                return new CreateSearchIndexResponse(properties);
            };

            /**
             * Encodes the specified CreateSearchIndexResponse message. Does not implicitly {@link search.proto.CreateSearchIndexResponse.verify|verify} messages.
             * @function encode
             * @memberof search.proto.CreateSearchIndexResponse
             * @static
             * @param {search.proto.ICreateSearchIndexResponse} message CreateSearchIndexResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateSearchIndexResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified CreateSearchIndexResponse message, length delimited. Does not implicitly {@link search.proto.CreateSearchIndexResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.CreateSearchIndexResponse
             * @static
             * @param {search.proto.ICreateSearchIndexResponse} message CreateSearchIndexResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateSearchIndexResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateSearchIndexResponse message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.CreateSearchIndexResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.CreateSearchIndexResponse} CreateSearchIndexResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateSearchIndexResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.CreateSearchIndexResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CreateSearchIndexResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.CreateSearchIndexResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.CreateSearchIndexResponse} CreateSearchIndexResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateSearchIndexResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateSearchIndexResponse message.
             * @function verify
             * @memberof search.proto.CreateSearchIndexResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateSearchIndexResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a CreateSearchIndexResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.CreateSearchIndexResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.CreateSearchIndexResponse} CreateSearchIndexResponse
             */
            CreateSearchIndexResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.CreateSearchIndexResponse)
                    return object;
                return new $root.search.proto.CreateSearchIndexResponse();
            };

            /**
             * Creates a plain object from a CreateSearchIndexResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.CreateSearchIndexResponse
             * @static
             * @param {search.proto.CreateSearchIndexResponse} message CreateSearchIndexResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateSearchIndexResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this CreateSearchIndexResponse to JSON.
             * @function toJSON
             * @memberof search.proto.CreateSearchIndexResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateSearchIndexResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CreateSearchIndexResponse;
        })();

        proto.UpdateSearchIndexRequest = (function() {

            /**
             * Properties of an UpdateSearchIndexRequest.
             * @memberof search.proto
             * @interface IUpdateSearchIndexRequest
             * @property {string|null} [tableName] UpdateSearchIndexRequest tableName
             * @property {string|null} [indexName] UpdateSearchIndexRequest indexName
             * @property {number|null} [timeToLive] UpdateSearchIndexRequest timeToLive
             */

            /**
             * Constructs a new UpdateSearchIndexRequest.
             * @memberof search.proto
             * @classdesc Represents an UpdateSearchIndexRequest.
             * @implements IUpdateSearchIndexRequest
             * @constructor
             * @param {search.proto.IUpdateSearchIndexRequest=} [properties] Properties to set
             */
            function UpdateSearchIndexRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UpdateSearchIndexRequest tableName.
             * @member {string} tableName
             * @memberof search.proto.UpdateSearchIndexRequest
             * @instance
             */
            UpdateSearchIndexRequest.prototype.tableName = "";

            /**
             * UpdateSearchIndexRequest indexName.
             * @member {string} indexName
             * @memberof search.proto.UpdateSearchIndexRequest
             * @instance
             */
            UpdateSearchIndexRequest.prototype.indexName = "";

            /**
             * UpdateSearchIndexRequest timeToLive.
             * @member {number} timeToLive
             * @memberof search.proto.UpdateSearchIndexRequest
             * @instance
             */
            UpdateSearchIndexRequest.prototype.timeToLive = 0;

            /**
             * Creates a new UpdateSearchIndexRequest instance using the specified properties.
             * @function create
             * @memberof search.proto.UpdateSearchIndexRequest
             * @static
             * @param {search.proto.IUpdateSearchIndexRequest=} [properties] Properties to set
             * @returns {search.proto.UpdateSearchIndexRequest} UpdateSearchIndexRequest instance
             */
            UpdateSearchIndexRequest.create = function create(properties) {
                return new UpdateSearchIndexRequest(properties);
            };

            /**
             * Encodes the specified UpdateSearchIndexRequest message. Does not implicitly {@link search.proto.UpdateSearchIndexRequest.verify|verify} messages.
             * @function encode
             * @memberof search.proto.UpdateSearchIndexRequest
             * @static
             * @param {search.proto.IUpdateSearchIndexRequest} message UpdateSearchIndexRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateSearchIndexRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tableName != null && Object.hasOwnProperty.call(message, "tableName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.tableName);
                if (message.indexName != null && Object.hasOwnProperty.call(message, "indexName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.indexName);
                if (message.timeToLive != null && Object.hasOwnProperty.call(message, "timeToLive"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.timeToLive);
                return writer;
            };

            /**
             * Encodes the specified UpdateSearchIndexRequest message, length delimited. Does not implicitly {@link search.proto.UpdateSearchIndexRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.UpdateSearchIndexRequest
             * @static
             * @param {search.proto.IUpdateSearchIndexRequest} message UpdateSearchIndexRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateSearchIndexRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UpdateSearchIndexRequest message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.UpdateSearchIndexRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.UpdateSearchIndexRequest} UpdateSearchIndexRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateSearchIndexRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.UpdateSearchIndexRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tableName = reader.string();
                        break;
                    case 2:
                        message.indexName = reader.string();
                        break;
                    case 5:
                        message.timeToLive = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UpdateSearchIndexRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.UpdateSearchIndexRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.UpdateSearchIndexRequest} UpdateSearchIndexRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateSearchIndexRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UpdateSearchIndexRequest message.
             * @function verify
             * @memberof search.proto.UpdateSearchIndexRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UpdateSearchIndexRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tableName != null && message.hasOwnProperty("tableName"))
                    if (!$util.isString(message.tableName))
                        return "tableName: string expected";
                if (message.indexName != null && message.hasOwnProperty("indexName"))
                    if (!$util.isString(message.indexName))
                        return "indexName: string expected";
                if (message.timeToLive != null && message.hasOwnProperty("timeToLive"))
                    if (!$util.isInteger(message.timeToLive))
                        return "timeToLive: integer expected";
                return null;
            };

            /**
             * Creates an UpdateSearchIndexRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.UpdateSearchIndexRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.UpdateSearchIndexRequest} UpdateSearchIndexRequest
             */
            UpdateSearchIndexRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.UpdateSearchIndexRequest)
                    return object;
                var message = new $root.search.proto.UpdateSearchIndexRequest();
                if (object.tableName != null)
                    message.tableName = String(object.tableName);
                if (object.indexName != null)
                    message.indexName = String(object.indexName);
                if (object.timeToLive != null)
                    message.timeToLive = object.timeToLive | 0;
                return message;
            };

            /**
             * Creates a plain object from an UpdateSearchIndexRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.UpdateSearchIndexRequest
             * @static
             * @param {search.proto.UpdateSearchIndexRequest} message UpdateSearchIndexRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UpdateSearchIndexRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.tableName = "";
                    object.indexName = "";
                    object.timeToLive = 0;
                }
                if (message.tableName != null && message.hasOwnProperty("tableName"))
                    object.tableName = message.tableName;
                if (message.indexName != null && message.hasOwnProperty("indexName"))
                    object.indexName = message.indexName;
                if (message.timeToLive != null && message.hasOwnProperty("timeToLive"))
                    object.timeToLive = message.timeToLive;
                return object;
            };

            /**
             * Converts this UpdateSearchIndexRequest to JSON.
             * @function toJSON
             * @memberof search.proto.UpdateSearchIndexRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UpdateSearchIndexRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return UpdateSearchIndexRequest;
        })();

        proto.UpdateSearchIndexResponse = (function() {

            /**
             * Properties of an UpdateSearchIndexResponse.
             * @memberof search.proto
             * @interface IUpdateSearchIndexResponse
             */

            /**
             * Constructs a new UpdateSearchIndexResponse.
             * @memberof search.proto
             * @classdesc Represents an UpdateSearchIndexResponse.
             * @implements IUpdateSearchIndexResponse
             * @constructor
             * @param {search.proto.IUpdateSearchIndexResponse=} [properties] Properties to set
             */
            function UpdateSearchIndexResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new UpdateSearchIndexResponse instance using the specified properties.
             * @function create
             * @memberof search.proto.UpdateSearchIndexResponse
             * @static
             * @param {search.proto.IUpdateSearchIndexResponse=} [properties] Properties to set
             * @returns {search.proto.UpdateSearchIndexResponse} UpdateSearchIndexResponse instance
             */
            UpdateSearchIndexResponse.create = function create(properties) {
                return new UpdateSearchIndexResponse(properties);
            };

            /**
             * Encodes the specified UpdateSearchIndexResponse message. Does not implicitly {@link search.proto.UpdateSearchIndexResponse.verify|verify} messages.
             * @function encode
             * @memberof search.proto.UpdateSearchIndexResponse
             * @static
             * @param {search.proto.IUpdateSearchIndexResponse} message UpdateSearchIndexResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateSearchIndexResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified UpdateSearchIndexResponse message, length delimited. Does not implicitly {@link search.proto.UpdateSearchIndexResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.UpdateSearchIndexResponse
             * @static
             * @param {search.proto.IUpdateSearchIndexResponse} message UpdateSearchIndexResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateSearchIndexResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UpdateSearchIndexResponse message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.UpdateSearchIndexResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.UpdateSearchIndexResponse} UpdateSearchIndexResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateSearchIndexResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.UpdateSearchIndexResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UpdateSearchIndexResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.UpdateSearchIndexResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.UpdateSearchIndexResponse} UpdateSearchIndexResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateSearchIndexResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UpdateSearchIndexResponse message.
             * @function verify
             * @memberof search.proto.UpdateSearchIndexResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UpdateSearchIndexResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an UpdateSearchIndexResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.UpdateSearchIndexResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.UpdateSearchIndexResponse} UpdateSearchIndexResponse
             */
            UpdateSearchIndexResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.UpdateSearchIndexResponse)
                    return object;
                return new $root.search.proto.UpdateSearchIndexResponse();
            };

            /**
             * Creates a plain object from an UpdateSearchIndexResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.UpdateSearchIndexResponse
             * @static
             * @param {search.proto.UpdateSearchIndexResponse} message UpdateSearchIndexResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UpdateSearchIndexResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this UpdateSearchIndexResponse to JSON.
             * @function toJSON
             * @memberof search.proto.UpdateSearchIndexResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UpdateSearchIndexResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return UpdateSearchIndexResponse;
        })();

        proto.IndexInfo = (function() {

            /**
             * Properties of an IndexInfo.
             * @memberof search.proto
             * @interface IIndexInfo
             * @property {string|null} [tableName] IndexInfo tableName
             * @property {string|null} [indexName] IndexInfo indexName
             */

            /**
             * Constructs a new IndexInfo.
             * @memberof search.proto
             * @classdesc Represents an IndexInfo.
             * @implements IIndexInfo
             * @constructor
             * @param {search.proto.IIndexInfo=} [properties] Properties to set
             */
            function IndexInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * IndexInfo tableName.
             * @member {string} tableName
             * @memberof search.proto.IndexInfo
             * @instance
             */
            IndexInfo.prototype.tableName = "";

            /**
             * IndexInfo indexName.
             * @member {string} indexName
             * @memberof search.proto.IndexInfo
             * @instance
             */
            IndexInfo.prototype.indexName = "";

            /**
             * Creates a new IndexInfo instance using the specified properties.
             * @function create
             * @memberof search.proto.IndexInfo
             * @static
             * @param {search.proto.IIndexInfo=} [properties] Properties to set
             * @returns {search.proto.IndexInfo} IndexInfo instance
             */
            IndexInfo.create = function create(properties) {
                return new IndexInfo(properties);
            };

            /**
             * Encodes the specified IndexInfo message. Does not implicitly {@link search.proto.IndexInfo.verify|verify} messages.
             * @function encode
             * @memberof search.proto.IndexInfo
             * @static
             * @param {search.proto.IIndexInfo} message IndexInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IndexInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tableName != null && Object.hasOwnProperty.call(message, "tableName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.tableName);
                if (message.indexName != null && Object.hasOwnProperty.call(message, "indexName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.indexName);
                return writer;
            };

            /**
             * Encodes the specified IndexInfo message, length delimited. Does not implicitly {@link search.proto.IndexInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.IndexInfo
             * @static
             * @param {search.proto.IIndexInfo} message IndexInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IndexInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an IndexInfo message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.IndexInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.IndexInfo} IndexInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IndexInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.IndexInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tableName = reader.string();
                        break;
                    case 2:
                        message.indexName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an IndexInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.IndexInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.IndexInfo} IndexInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IndexInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an IndexInfo message.
             * @function verify
             * @memberof search.proto.IndexInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            IndexInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tableName != null && message.hasOwnProperty("tableName"))
                    if (!$util.isString(message.tableName))
                        return "tableName: string expected";
                if (message.indexName != null && message.hasOwnProperty("indexName"))
                    if (!$util.isString(message.indexName))
                        return "indexName: string expected";
                return null;
            };

            /**
             * Creates an IndexInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.IndexInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.IndexInfo} IndexInfo
             */
            IndexInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.IndexInfo)
                    return object;
                var message = new $root.search.proto.IndexInfo();
                if (object.tableName != null)
                    message.tableName = String(object.tableName);
                if (object.indexName != null)
                    message.indexName = String(object.indexName);
                return message;
            };

            /**
             * Creates a plain object from an IndexInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.IndexInfo
             * @static
             * @param {search.proto.IndexInfo} message IndexInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            IndexInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.tableName = "";
                    object.indexName = "";
                }
                if (message.tableName != null && message.hasOwnProperty("tableName"))
                    object.tableName = message.tableName;
                if (message.indexName != null && message.hasOwnProperty("indexName"))
                    object.indexName = message.indexName;
                return object;
            };

            /**
             * Converts this IndexInfo to JSON.
             * @function toJSON
             * @memberof search.proto.IndexInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            IndexInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return IndexInfo;
        })();

        proto.ListSearchIndexRequest = (function() {

            /**
             * Properties of a ListSearchIndexRequest.
             * @memberof search.proto
             * @interface IListSearchIndexRequest
             * @property {string|null} [tableName] ListSearchIndexRequest tableName
             */

            /**
             * Constructs a new ListSearchIndexRequest.
             * @memberof search.proto
             * @classdesc Represents a ListSearchIndexRequest.
             * @implements IListSearchIndexRequest
             * @constructor
             * @param {search.proto.IListSearchIndexRequest=} [properties] Properties to set
             */
            function ListSearchIndexRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListSearchIndexRequest tableName.
             * @member {string} tableName
             * @memberof search.proto.ListSearchIndexRequest
             * @instance
             */
            ListSearchIndexRequest.prototype.tableName = "";

            /**
             * Creates a new ListSearchIndexRequest instance using the specified properties.
             * @function create
             * @memberof search.proto.ListSearchIndexRequest
             * @static
             * @param {search.proto.IListSearchIndexRequest=} [properties] Properties to set
             * @returns {search.proto.ListSearchIndexRequest} ListSearchIndexRequest instance
             */
            ListSearchIndexRequest.create = function create(properties) {
                return new ListSearchIndexRequest(properties);
            };

            /**
             * Encodes the specified ListSearchIndexRequest message. Does not implicitly {@link search.proto.ListSearchIndexRequest.verify|verify} messages.
             * @function encode
             * @memberof search.proto.ListSearchIndexRequest
             * @static
             * @param {search.proto.IListSearchIndexRequest} message ListSearchIndexRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListSearchIndexRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tableName != null && Object.hasOwnProperty.call(message, "tableName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.tableName);
                return writer;
            };

            /**
             * Encodes the specified ListSearchIndexRequest message, length delimited. Does not implicitly {@link search.proto.ListSearchIndexRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.ListSearchIndexRequest
             * @static
             * @param {search.proto.IListSearchIndexRequest} message ListSearchIndexRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListSearchIndexRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListSearchIndexRequest message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.ListSearchIndexRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.ListSearchIndexRequest} ListSearchIndexRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListSearchIndexRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.ListSearchIndexRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tableName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListSearchIndexRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.ListSearchIndexRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.ListSearchIndexRequest} ListSearchIndexRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListSearchIndexRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListSearchIndexRequest message.
             * @function verify
             * @memberof search.proto.ListSearchIndexRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListSearchIndexRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tableName != null && message.hasOwnProperty("tableName"))
                    if (!$util.isString(message.tableName))
                        return "tableName: string expected";
                return null;
            };

            /**
             * Creates a ListSearchIndexRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.ListSearchIndexRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.ListSearchIndexRequest} ListSearchIndexRequest
             */
            ListSearchIndexRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.ListSearchIndexRequest)
                    return object;
                var message = new $root.search.proto.ListSearchIndexRequest();
                if (object.tableName != null)
                    message.tableName = String(object.tableName);
                return message;
            };

            /**
             * Creates a plain object from a ListSearchIndexRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.ListSearchIndexRequest
             * @static
             * @param {search.proto.ListSearchIndexRequest} message ListSearchIndexRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListSearchIndexRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.tableName = "";
                if (message.tableName != null && message.hasOwnProperty("tableName"))
                    object.tableName = message.tableName;
                return object;
            };

            /**
             * Converts this ListSearchIndexRequest to JSON.
             * @function toJSON
             * @memberof search.proto.ListSearchIndexRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListSearchIndexRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListSearchIndexRequest;
        })();

        proto.ListSearchIndexResponse = (function() {

            /**
             * Properties of a ListSearchIndexResponse.
             * @memberof search.proto
             * @interface IListSearchIndexResponse
             * @property {Array.<search.proto.IIndexInfo>|null} [indices] ListSearchIndexResponse indices
             */

            /**
             * Constructs a new ListSearchIndexResponse.
             * @memberof search.proto
             * @classdesc Represents a ListSearchIndexResponse.
             * @implements IListSearchIndexResponse
             * @constructor
             * @param {search.proto.IListSearchIndexResponse=} [properties] Properties to set
             */
            function ListSearchIndexResponse(properties) {
                this.indices = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListSearchIndexResponse indices.
             * @member {Array.<search.proto.IIndexInfo>} indices
             * @memberof search.proto.ListSearchIndexResponse
             * @instance
             */
            ListSearchIndexResponse.prototype.indices = $util.emptyArray;

            /**
             * Creates a new ListSearchIndexResponse instance using the specified properties.
             * @function create
             * @memberof search.proto.ListSearchIndexResponse
             * @static
             * @param {search.proto.IListSearchIndexResponse=} [properties] Properties to set
             * @returns {search.proto.ListSearchIndexResponse} ListSearchIndexResponse instance
             */
            ListSearchIndexResponse.create = function create(properties) {
                return new ListSearchIndexResponse(properties);
            };

            /**
             * Encodes the specified ListSearchIndexResponse message. Does not implicitly {@link search.proto.ListSearchIndexResponse.verify|verify} messages.
             * @function encode
             * @memberof search.proto.ListSearchIndexResponse
             * @static
             * @param {search.proto.IListSearchIndexResponse} message ListSearchIndexResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListSearchIndexResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.indices != null && message.indices.length)
                    for (var i = 0; i < message.indices.length; ++i)
                        $root.search.proto.IndexInfo.encode(message.indices[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ListSearchIndexResponse message, length delimited. Does not implicitly {@link search.proto.ListSearchIndexResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.ListSearchIndexResponse
             * @static
             * @param {search.proto.IListSearchIndexResponse} message ListSearchIndexResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListSearchIndexResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListSearchIndexResponse message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.ListSearchIndexResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.ListSearchIndexResponse} ListSearchIndexResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListSearchIndexResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.ListSearchIndexResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.indices && message.indices.length))
                            message.indices = [];
                        message.indices.push($root.search.proto.IndexInfo.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListSearchIndexResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.ListSearchIndexResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.ListSearchIndexResponse} ListSearchIndexResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListSearchIndexResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListSearchIndexResponse message.
             * @function verify
             * @memberof search.proto.ListSearchIndexResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListSearchIndexResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.indices != null && message.hasOwnProperty("indices")) {
                    if (!Array.isArray(message.indices))
                        return "indices: array expected";
                    for (var i = 0; i < message.indices.length; ++i) {
                        var error = $root.search.proto.IndexInfo.verify(message.indices[i]);
                        if (error)
                            return "indices." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ListSearchIndexResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.ListSearchIndexResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.ListSearchIndexResponse} ListSearchIndexResponse
             */
            ListSearchIndexResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.ListSearchIndexResponse)
                    return object;
                var message = new $root.search.proto.ListSearchIndexResponse();
                if (object.indices) {
                    if (!Array.isArray(object.indices))
                        throw TypeError(".search.proto.ListSearchIndexResponse.indices: array expected");
                    message.indices = [];
                    for (var i = 0; i < object.indices.length; ++i) {
                        if (typeof object.indices[i] !== "object")
                            throw TypeError(".search.proto.ListSearchIndexResponse.indices: object expected");
                        message.indices[i] = $root.search.proto.IndexInfo.fromObject(object.indices[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a ListSearchIndexResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.ListSearchIndexResponse
             * @static
             * @param {search.proto.ListSearchIndexResponse} message ListSearchIndexResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListSearchIndexResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.indices = [];
                if (message.indices && message.indices.length) {
                    object.indices = [];
                    for (var j = 0; j < message.indices.length; ++j)
                        object.indices[j] = $root.search.proto.IndexInfo.toObject(message.indices[j], options);
                }
                return object;
            };

            /**
             * Converts this ListSearchIndexResponse to JSON.
             * @function toJSON
             * @memberof search.proto.ListSearchIndexResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListSearchIndexResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListSearchIndexResponse;
        })();

        proto.DeleteSearchIndexRequest = (function() {

            /**
             * Properties of a DeleteSearchIndexRequest.
             * @memberof search.proto
             * @interface IDeleteSearchIndexRequest
             * @property {string|null} [tableName] DeleteSearchIndexRequest tableName
             * @property {string|null} [indexName] DeleteSearchIndexRequest indexName
             */

            /**
             * Constructs a new DeleteSearchIndexRequest.
             * @memberof search.proto
             * @classdesc Represents a DeleteSearchIndexRequest.
             * @implements IDeleteSearchIndexRequest
             * @constructor
             * @param {search.proto.IDeleteSearchIndexRequest=} [properties] Properties to set
             */
            function DeleteSearchIndexRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeleteSearchIndexRequest tableName.
             * @member {string} tableName
             * @memberof search.proto.DeleteSearchIndexRequest
             * @instance
             */
            DeleteSearchIndexRequest.prototype.tableName = "";

            /**
             * DeleteSearchIndexRequest indexName.
             * @member {string} indexName
             * @memberof search.proto.DeleteSearchIndexRequest
             * @instance
             */
            DeleteSearchIndexRequest.prototype.indexName = "";

            /**
             * Creates a new DeleteSearchIndexRequest instance using the specified properties.
             * @function create
             * @memberof search.proto.DeleteSearchIndexRequest
             * @static
             * @param {search.proto.IDeleteSearchIndexRequest=} [properties] Properties to set
             * @returns {search.proto.DeleteSearchIndexRequest} DeleteSearchIndexRequest instance
             */
            DeleteSearchIndexRequest.create = function create(properties) {
                return new DeleteSearchIndexRequest(properties);
            };

            /**
             * Encodes the specified DeleteSearchIndexRequest message. Does not implicitly {@link search.proto.DeleteSearchIndexRequest.verify|verify} messages.
             * @function encode
             * @memberof search.proto.DeleteSearchIndexRequest
             * @static
             * @param {search.proto.IDeleteSearchIndexRequest} message DeleteSearchIndexRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteSearchIndexRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tableName != null && Object.hasOwnProperty.call(message, "tableName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.tableName);
                if (message.indexName != null && Object.hasOwnProperty.call(message, "indexName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.indexName);
                return writer;
            };

            /**
             * Encodes the specified DeleteSearchIndexRequest message, length delimited. Does not implicitly {@link search.proto.DeleteSearchIndexRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.DeleteSearchIndexRequest
             * @static
             * @param {search.proto.IDeleteSearchIndexRequest} message DeleteSearchIndexRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteSearchIndexRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteSearchIndexRequest message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.DeleteSearchIndexRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.DeleteSearchIndexRequest} DeleteSearchIndexRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteSearchIndexRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.DeleteSearchIndexRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tableName = reader.string();
                        break;
                    case 2:
                        message.indexName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteSearchIndexRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.DeleteSearchIndexRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.DeleteSearchIndexRequest} DeleteSearchIndexRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteSearchIndexRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteSearchIndexRequest message.
             * @function verify
             * @memberof search.proto.DeleteSearchIndexRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteSearchIndexRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tableName != null && message.hasOwnProperty("tableName"))
                    if (!$util.isString(message.tableName))
                        return "tableName: string expected";
                if (message.indexName != null && message.hasOwnProperty("indexName"))
                    if (!$util.isString(message.indexName))
                        return "indexName: string expected";
                return null;
            };

            /**
             * Creates a DeleteSearchIndexRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.DeleteSearchIndexRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.DeleteSearchIndexRequest} DeleteSearchIndexRequest
             */
            DeleteSearchIndexRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.DeleteSearchIndexRequest)
                    return object;
                var message = new $root.search.proto.DeleteSearchIndexRequest();
                if (object.tableName != null)
                    message.tableName = String(object.tableName);
                if (object.indexName != null)
                    message.indexName = String(object.indexName);
                return message;
            };

            /**
             * Creates a plain object from a DeleteSearchIndexRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.DeleteSearchIndexRequest
             * @static
             * @param {search.proto.DeleteSearchIndexRequest} message DeleteSearchIndexRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteSearchIndexRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.tableName = "";
                    object.indexName = "";
                }
                if (message.tableName != null && message.hasOwnProperty("tableName"))
                    object.tableName = message.tableName;
                if (message.indexName != null && message.hasOwnProperty("indexName"))
                    object.indexName = message.indexName;
                return object;
            };

            /**
             * Converts this DeleteSearchIndexRequest to JSON.
             * @function toJSON
             * @memberof search.proto.DeleteSearchIndexRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteSearchIndexRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DeleteSearchIndexRequest;
        })();

        proto.DeleteSearchIndexResponse = (function() {

            /**
             * Properties of a DeleteSearchIndexResponse.
             * @memberof search.proto
             * @interface IDeleteSearchIndexResponse
             */

            /**
             * Constructs a new DeleteSearchIndexResponse.
             * @memberof search.proto
             * @classdesc Represents a DeleteSearchIndexResponse.
             * @implements IDeleteSearchIndexResponse
             * @constructor
             * @param {search.proto.IDeleteSearchIndexResponse=} [properties] Properties to set
             */
            function DeleteSearchIndexResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new DeleteSearchIndexResponse instance using the specified properties.
             * @function create
             * @memberof search.proto.DeleteSearchIndexResponse
             * @static
             * @param {search.proto.IDeleteSearchIndexResponse=} [properties] Properties to set
             * @returns {search.proto.DeleteSearchIndexResponse} DeleteSearchIndexResponse instance
             */
            DeleteSearchIndexResponse.create = function create(properties) {
                return new DeleteSearchIndexResponse(properties);
            };

            /**
             * Encodes the specified DeleteSearchIndexResponse message. Does not implicitly {@link search.proto.DeleteSearchIndexResponse.verify|verify} messages.
             * @function encode
             * @memberof search.proto.DeleteSearchIndexResponse
             * @static
             * @param {search.proto.IDeleteSearchIndexResponse} message DeleteSearchIndexResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteSearchIndexResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified DeleteSearchIndexResponse message, length delimited. Does not implicitly {@link search.proto.DeleteSearchIndexResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.DeleteSearchIndexResponse
             * @static
             * @param {search.proto.IDeleteSearchIndexResponse} message DeleteSearchIndexResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteSearchIndexResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteSearchIndexResponse message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.DeleteSearchIndexResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.DeleteSearchIndexResponse} DeleteSearchIndexResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteSearchIndexResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.DeleteSearchIndexResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteSearchIndexResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.DeleteSearchIndexResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.DeleteSearchIndexResponse} DeleteSearchIndexResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteSearchIndexResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteSearchIndexResponse message.
             * @function verify
             * @memberof search.proto.DeleteSearchIndexResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteSearchIndexResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a DeleteSearchIndexResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.DeleteSearchIndexResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.DeleteSearchIndexResponse} DeleteSearchIndexResponse
             */
            DeleteSearchIndexResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.DeleteSearchIndexResponse)
                    return object;
                return new $root.search.proto.DeleteSearchIndexResponse();
            };

            /**
             * Creates a plain object from a DeleteSearchIndexResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.DeleteSearchIndexResponse
             * @static
             * @param {search.proto.DeleteSearchIndexResponse} message DeleteSearchIndexResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteSearchIndexResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this DeleteSearchIndexResponse to JSON.
             * @function toJSON
             * @memberof search.proto.DeleteSearchIndexResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteSearchIndexResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DeleteSearchIndexResponse;
        })();

        /**
         * SyncPhase enum.
         * @name search.proto.SyncPhase
         * @enum {number}
         * @property {number} FULL=1 FULL value
         * @property {number} INCR=2 INCR value
         */
        proto.SyncPhase = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "FULL"] = 1;
            values[valuesById[2] = "INCR"] = 2;
            return values;
        })();

        proto.SyncStat = (function() {

            /**
             * Properties of a SyncStat.
             * @memberof search.proto
             * @interface ISyncStat
             * @property {search.proto.SyncPhase|null} [syncPhase] SyncStat syncPhase
             * @property {number|Long|null} [currentSyncTimestamp] SyncStat currentSyncTimestamp
             */

            /**
             * Constructs a new SyncStat.
             * @memberof search.proto
             * @classdesc Represents a SyncStat.
             * @implements ISyncStat
             * @constructor
             * @param {search.proto.ISyncStat=} [properties] Properties to set
             */
            function SyncStat(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SyncStat syncPhase.
             * @member {search.proto.SyncPhase} syncPhase
             * @memberof search.proto.SyncStat
             * @instance
             */
            SyncStat.prototype.syncPhase = 1;

            /**
             * SyncStat currentSyncTimestamp.
             * @member {number|Long} currentSyncTimestamp
             * @memberof search.proto.SyncStat
             * @instance
             */
            SyncStat.prototype.currentSyncTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new SyncStat instance using the specified properties.
             * @function create
             * @memberof search.proto.SyncStat
             * @static
             * @param {search.proto.ISyncStat=} [properties] Properties to set
             * @returns {search.proto.SyncStat} SyncStat instance
             */
            SyncStat.create = function create(properties) {
                return new SyncStat(properties);
            };

            /**
             * Encodes the specified SyncStat message. Does not implicitly {@link search.proto.SyncStat.verify|verify} messages.
             * @function encode
             * @memberof search.proto.SyncStat
             * @static
             * @param {search.proto.ISyncStat} message SyncStat message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SyncStat.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.syncPhase != null && Object.hasOwnProperty.call(message, "syncPhase"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.syncPhase);
                if (message.currentSyncTimestamp != null && Object.hasOwnProperty.call(message, "currentSyncTimestamp"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.currentSyncTimestamp);
                return writer;
            };

            /**
             * Encodes the specified SyncStat message, length delimited. Does not implicitly {@link search.proto.SyncStat.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.SyncStat
             * @static
             * @param {search.proto.ISyncStat} message SyncStat message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SyncStat.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SyncStat message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.SyncStat
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.SyncStat} SyncStat
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SyncStat.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.SyncStat();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.syncPhase = reader.int32();
                        break;
                    case 2:
                        message.currentSyncTimestamp = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SyncStat message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.SyncStat
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.SyncStat} SyncStat
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SyncStat.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SyncStat message.
             * @function verify
             * @memberof search.proto.SyncStat
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SyncStat.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.syncPhase != null && message.hasOwnProperty("syncPhase"))
                    switch (message.syncPhase) {
                    default:
                        return "syncPhase: enum value expected";
                    case 1:
                    case 2:
                        break;
                    }
                if (message.currentSyncTimestamp != null && message.hasOwnProperty("currentSyncTimestamp"))
                    if (!$util.isInteger(message.currentSyncTimestamp) && !(message.currentSyncTimestamp && $util.isInteger(message.currentSyncTimestamp.low) && $util.isInteger(message.currentSyncTimestamp.high)))
                        return "currentSyncTimestamp: integer|Long expected";
                return null;
            };

            /**
             * Creates a SyncStat message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.SyncStat
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.SyncStat} SyncStat
             */
            SyncStat.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.SyncStat)
                    return object;
                var message = new $root.search.proto.SyncStat();
                switch (object.syncPhase) {
                case "FULL":
                case 1:
                    message.syncPhase = 1;
                    break;
                case "INCR":
                case 2:
                    message.syncPhase = 2;
                    break;
                }
                if (object.currentSyncTimestamp != null)
                    if ($util.Long)
                        (message.currentSyncTimestamp = $util.Long.fromValue(object.currentSyncTimestamp)).unsigned = false;
                    else if (typeof object.currentSyncTimestamp === "string")
                        message.currentSyncTimestamp = parseInt(object.currentSyncTimestamp, 10);
                    else if (typeof object.currentSyncTimestamp === "number")
                        message.currentSyncTimestamp = object.currentSyncTimestamp;
                    else if (typeof object.currentSyncTimestamp === "object")
                        message.currentSyncTimestamp = new $util.LongBits(object.currentSyncTimestamp.low >>> 0, object.currentSyncTimestamp.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a SyncStat message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.SyncStat
             * @static
             * @param {search.proto.SyncStat} message SyncStat
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SyncStat.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.syncPhase = options.enums === String ? "FULL" : 1;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.currentSyncTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.currentSyncTimestamp = options.longs === String ? "0" : 0;
                }
                if (message.syncPhase != null && message.hasOwnProperty("syncPhase"))
                    object.syncPhase = options.enums === String ? $root.search.proto.SyncPhase[message.syncPhase] : message.syncPhase;
                if (message.currentSyncTimestamp != null && message.hasOwnProperty("currentSyncTimestamp"))
                    if (typeof message.currentSyncTimestamp === "number")
                        object.currentSyncTimestamp = options.longs === String ? String(message.currentSyncTimestamp) : message.currentSyncTimestamp;
                    else
                        object.currentSyncTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.currentSyncTimestamp) : options.longs === Number ? new $util.LongBits(message.currentSyncTimestamp.low >>> 0, message.currentSyncTimestamp.high >>> 0).toNumber() : message.currentSyncTimestamp;
                return object;
            };

            /**
             * Converts this SyncStat to JSON.
             * @function toJSON
             * @memberof search.proto.SyncStat
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SyncStat.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SyncStat;
        })();

        proto.MeteringInfo = (function() {

            /**
             * Properties of a MeteringInfo.
             * @memberof search.proto
             * @interface IMeteringInfo
             * @property {number|Long|null} [storageSize] MeteringInfo storageSize
             * @property {number|Long|null} [rowCount] MeteringInfo rowCount
             * @property {number|Long|null} [reservedReadCu] MeteringInfo reservedReadCu
             * @property {number|Long|null} [timestamp] MeteringInfo timestamp
             */

            /**
             * Constructs a new MeteringInfo.
             * @memberof search.proto
             * @classdesc Represents a MeteringInfo.
             * @implements IMeteringInfo
             * @constructor
             * @param {search.proto.IMeteringInfo=} [properties] Properties to set
             */
            function MeteringInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MeteringInfo storageSize.
             * @member {number|Long} storageSize
             * @memberof search.proto.MeteringInfo
             * @instance
             */
            MeteringInfo.prototype.storageSize = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * MeteringInfo rowCount.
             * @member {number|Long} rowCount
             * @memberof search.proto.MeteringInfo
             * @instance
             */
            MeteringInfo.prototype.rowCount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * MeteringInfo reservedReadCu.
             * @member {number|Long} reservedReadCu
             * @memberof search.proto.MeteringInfo
             * @instance
             */
            MeteringInfo.prototype.reservedReadCu = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * MeteringInfo timestamp.
             * @member {number|Long} timestamp
             * @memberof search.proto.MeteringInfo
             * @instance
             */
            MeteringInfo.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new MeteringInfo instance using the specified properties.
             * @function create
             * @memberof search.proto.MeteringInfo
             * @static
             * @param {search.proto.IMeteringInfo=} [properties] Properties to set
             * @returns {search.proto.MeteringInfo} MeteringInfo instance
             */
            MeteringInfo.create = function create(properties) {
                return new MeteringInfo(properties);
            };

            /**
             * Encodes the specified MeteringInfo message. Does not implicitly {@link search.proto.MeteringInfo.verify|verify} messages.
             * @function encode
             * @memberof search.proto.MeteringInfo
             * @static
             * @param {search.proto.IMeteringInfo} message MeteringInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MeteringInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.storageSize != null && Object.hasOwnProperty.call(message, "storageSize"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.storageSize);
                if (message.rowCount != null && Object.hasOwnProperty.call(message, "rowCount"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.rowCount);
                if (message.reservedReadCu != null && Object.hasOwnProperty.call(message, "reservedReadCu"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.reservedReadCu);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.timestamp);
                return writer;
            };

            /**
             * Encodes the specified MeteringInfo message, length delimited. Does not implicitly {@link search.proto.MeteringInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.MeteringInfo
             * @static
             * @param {search.proto.IMeteringInfo} message MeteringInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MeteringInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MeteringInfo message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.MeteringInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.MeteringInfo} MeteringInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MeteringInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.MeteringInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.storageSize = reader.int64();
                        break;
                    case 2:
                        message.rowCount = reader.int64();
                        break;
                    case 3:
                        message.reservedReadCu = reader.int64();
                        break;
                    case 4:
                        message.timestamp = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MeteringInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.MeteringInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.MeteringInfo} MeteringInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MeteringInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MeteringInfo message.
             * @function verify
             * @memberof search.proto.MeteringInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MeteringInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.storageSize != null && message.hasOwnProperty("storageSize"))
                    if (!$util.isInteger(message.storageSize) && !(message.storageSize && $util.isInteger(message.storageSize.low) && $util.isInteger(message.storageSize.high)))
                        return "storageSize: integer|Long expected";
                if (message.rowCount != null && message.hasOwnProperty("rowCount"))
                    if (!$util.isInteger(message.rowCount) && !(message.rowCount && $util.isInteger(message.rowCount.low) && $util.isInteger(message.rowCount.high)))
                        return "rowCount: integer|Long expected";
                if (message.reservedReadCu != null && message.hasOwnProperty("reservedReadCu"))
                    if (!$util.isInteger(message.reservedReadCu) && !(message.reservedReadCu && $util.isInteger(message.reservedReadCu.low) && $util.isInteger(message.reservedReadCu.high)))
                        return "reservedReadCu: integer|Long expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                return null;
            };

            /**
             * Creates a MeteringInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.MeteringInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.MeteringInfo} MeteringInfo
             */
            MeteringInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.MeteringInfo)
                    return object;
                var message = new $root.search.proto.MeteringInfo();
                if (object.storageSize != null)
                    if ($util.Long)
                        (message.storageSize = $util.Long.fromValue(object.storageSize)).unsigned = false;
                    else if (typeof object.storageSize === "string")
                        message.storageSize = parseInt(object.storageSize, 10);
                    else if (typeof object.storageSize === "number")
                        message.storageSize = object.storageSize;
                    else if (typeof object.storageSize === "object")
                        message.storageSize = new $util.LongBits(object.storageSize.low >>> 0, object.storageSize.high >>> 0).toNumber();
                if (object.rowCount != null)
                    if ($util.Long)
                        (message.rowCount = $util.Long.fromValue(object.rowCount)).unsigned = false;
                    else if (typeof object.rowCount === "string")
                        message.rowCount = parseInt(object.rowCount, 10);
                    else if (typeof object.rowCount === "number")
                        message.rowCount = object.rowCount;
                    else if (typeof object.rowCount === "object")
                        message.rowCount = new $util.LongBits(object.rowCount.low >>> 0, object.rowCount.high >>> 0).toNumber();
                if (object.reservedReadCu != null)
                    if ($util.Long)
                        (message.reservedReadCu = $util.Long.fromValue(object.reservedReadCu)).unsigned = false;
                    else if (typeof object.reservedReadCu === "string")
                        message.reservedReadCu = parseInt(object.reservedReadCu, 10);
                    else if (typeof object.reservedReadCu === "number")
                        message.reservedReadCu = object.reservedReadCu;
                    else if (typeof object.reservedReadCu === "object")
                        message.reservedReadCu = new $util.LongBits(object.reservedReadCu.low >>> 0, object.reservedReadCu.high >>> 0).toNumber();
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a MeteringInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.MeteringInfo
             * @static
             * @param {search.proto.MeteringInfo} message MeteringInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MeteringInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.storageSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.storageSize = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.rowCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.rowCount = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.reservedReadCu = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.reservedReadCu = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                }
                if (message.storageSize != null && message.hasOwnProperty("storageSize"))
                    if (typeof message.storageSize === "number")
                        object.storageSize = options.longs === String ? String(message.storageSize) : message.storageSize;
                    else
                        object.storageSize = options.longs === String ? $util.Long.prototype.toString.call(message.storageSize) : options.longs === Number ? new $util.LongBits(message.storageSize.low >>> 0, message.storageSize.high >>> 0).toNumber() : message.storageSize;
                if (message.rowCount != null && message.hasOwnProperty("rowCount"))
                    if (typeof message.rowCount === "number")
                        object.rowCount = options.longs === String ? String(message.rowCount) : message.rowCount;
                    else
                        object.rowCount = options.longs === String ? $util.Long.prototype.toString.call(message.rowCount) : options.longs === Number ? new $util.LongBits(message.rowCount.low >>> 0, message.rowCount.high >>> 0).toNumber() : message.rowCount;
                if (message.reservedReadCu != null && message.hasOwnProperty("reservedReadCu"))
                    if (typeof message.reservedReadCu === "number")
                        object.reservedReadCu = options.longs === String ? String(message.reservedReadCu) : message.reservedReadCu;
                    else
                        object.reservedReadCu = options.longs === String ? $util.Long.prototype.toString.call(message.reservedReadCu) : options.longs === Number ? new $util.LongBits(message.reservedReadCu.low >>> 0, message.reservedReadCu.high >>> 0).toNumber() : message.reservedReadCu;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                return object;
            };

            /**
             * Converts this MeteringInfo to JSON.
             * @function toJSON
             * @memberof search.proto.MeteringInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MeteringInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MeteringInfo;
        })();

        proto.DescribeSearchIndexRequest = (function() {

            /**
             * Properties of a DescribeSearchIndexRequest.
             * @memberof search.proto
             * @interface IDescribeSearchIndexRequest
             * @property {string|null} [tableName] DescribeSearchIndexRequest tableName
             * @property {string|null} [indexName] DescribeSearchIndexRequest indexName
             */

            /**
             * Constructs a new DescribeSearchIndexRequest.
             * @memberof search.proto
             * @classdesc Represents a DescribeSearchIndexRequest.
             * @implements IDescribeSearchIndexRequest
             * @constructor
             * @param {search.proto.IDescribeSearchIndexRequest=} [properties] Properties to set
             */
            function DescribeSearchIndexRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DescribeSearchIndexRequest tableName.
             * @member {string} tableName
             * @memberof search.proto.DescribeSearchIndexRequest
             * @instance
             */
            DescribeSearchIndexRequest.prototype.tableName = "";

            /**
             * DescribeSearchIndexRequest indexName.
             * @member {string} indexName
             * @memberof search.proto.DescribeSearchIndexRequest
             * @instance
             */
            DescribeSearchIndexRequest.prototype.indexName = "";

            /**
             * Creates a new DescribeSearchIndexRequest instance using the specified properties.
             * @function create
             * @memberof search.proto.DescribeSearchIndexRequest
             * @static
             * @param {search.proto.IDescribeSearchIndexRequest=} [properties] Properties to set
             * @returns {search.proto.DescribeSearchIndexRequest} DescribeSearchIndexRequest instance
             */
            DescribeSearchIndexRequest.create = function create(properties) {
                return new DescribeSearchIndexRequest(properties);
            };

            /**
             * Encodes the specified DescribeSearchIndexRequest message. Does not implicitly {@link search.proto.DescribeSearchIndexRequest.verify|verify} messages.
             * @function encode
             * @memberof search.proto.DescribeSearchIndexRequest
             * @static
             * @param {search.proto.IDescribeSearchIndexRequest} message DescribeSearchIndexRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeSearchIndexRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tableName != null && Object.hasOwnProperty.call(message, "tableName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.tableName);
                if (message.indexName != null && Object.hasOwnProperty.call(message, "indexName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.indexName);
                return writer;
            };

            /**
             * Encodes the specified DescribeSearchIndexRequest message, length delimited. Does not implicitly {@link search.proto.DescribeSearchIndexRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.DescribeSearchIndexRequest
             * @static
             * @param {search.proto.IDescribeSearchIndexRequest} message DescribeSearchIndexRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeSearchIndexRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DescribeSearchIndexRequest message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.DescribeSearchIndexRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.DescribeSearchIndexRequest} DescribeSearchIndexRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeSearchIndexRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.DescribeSearchIndexRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tableName = reader.string();
                        break;
                    case 2:
                        message.indexName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DescribeSearchIndexRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.DescribeSearchIndexRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.DescribeSearchIndexRequest} DescribeSearchIndexRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeSearchIndexRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DescribeSearchIndexRequest message.
             * @function verify
             * @memberof search.proto.DescribeSearchIndexRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DescribeSearchIndexRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tableName != null && message.hasOwnProperty("tableName"))
                    if (!$util.isString(message.tableName))
                        return "tableName: string expected";
                if (message.indexName != null && message.hasOwnProperty("indexName"))
                    if (!$util.isString(message.indexName))
                        return "indexName: string expected";
                return null;
            };

            /**
             * Creates a DescribeSearchIndexRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.DescribeSearchIndexRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.DescribeSearchIndexRequest} DescribeSearchIndexRequest
             */
            DescribeSearchIndexRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.DescribeSearchIndexRequest)
                    return object;
                var message = new $root.search.proto.DescribeSearchIndexRequest();
                if (object.tableName != null)
                    message.tableName = String(object.tableName);
                if (object.indexName != null)
                    message.indexName = String(object.indexName);
                return message;
            };

            /**
             * Creates a plain object from a DescribeSearchIndexRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.DescribeSearchIndexRequest
             * @static
             * @param {search.proto.DescribeSearchIndexRequest} message DescribeSearchIndexRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescribeSearchIndexRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.tableName = "";
                    object.indexName = "";
                }
                if (message.tableName != null && message.hasOwnProperty("tableName"))
                    object.tableName = message.tableName;
                if (message.indexName != null && message.hasOwnProperty("indexName"))
                    object.indexName = message.indexName;
                return object;
            };

            /**
             * Converts this DescribeSearchIndexRequest to JSON.
             * @function toJSON
             * @memberof search.proto.DescribeSearchIndexRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DescribeSearchIndexRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DescribeSearchIndexRequest;
        })();

        proto.DescribeSearchIndexResponse = (function() {

            /**
             * Properties of a DescribeSearchIndexResponse.
             * @memberof search.proto
             * @interface IDescribeSearchIndexResponse
             * @property {search.proto.IIndexSchema|null} [schema] DescribeSearchIndexResponse schema
             * @property {search.proto.ISyncStat|null} [syncStat] DescribeSearchIndexResponse syncStat
             * @property {search.proto.IMeteringInfo|null} [meteringInfo] DescribeSearchIndexResponse meteringInfo
             * @property {string|null} [brotherIndexName] DescribeSearchIndexResponse brotherIndexName
             * @property {number|Long|null} [createTime] DescribeSearchIndexResponse createTime
             * @property {number|null} [timeToLive] DescribeSearchIndexResponse timeToLive
             * @property {search.proto.IIndexStatus|null} [indexStatus] DescribeSearchIndexResponse indexStatus
             */

            /**
             * Constructs a new DescribeSearchIndexResponse.
             * @memberof search.proto
             * @classdesc Represents a DescribeSearchIndexResponse.
             * @implements IDescribeSearchIndexResponse
             * @constructor
             * @param {search.proto.IDescribeSearchIndexResponse=} [properties] Properties to set
             */
            function DescribeSearchIndexResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DescribeSearchIndexResponse schema.
             * @member {search.proto.IIndexSchema|null|undefined} schema
             * @memberof search.proto.DescribeSearchIndexResponse
             * @instance
             */
            DescribeSearchIndexResponse.prototype.schema = null;

            /**
             * DescribeSearchIndexResponse syncStat.
             * @member {search.proto.ISyncStat|null|undefined} syncStat
             * @memberof search.proto.DescribeSearchIndexResponse
             * @instance
             */
            DescribeSearchIndexResponse.prototype.syncStat = null;

            /**
             * DescribeSearchIndexResponse meteringInfo.
             * @member {search.proto.IMeteringInfo|null|undefined} meteringInfo
             * @memberof search.proto.DescribeSearchIndexResponse
             * @instance
             */
            DescribeSearchIndexResponse.prototype.meteringInfo = null;

            /**
             * DescribeSearchIndexResponse brotherIndexName.
             * @member {string} brotherIndexName
             * @memberof search.proto.DescribeSearchIndexResponse
             * @instance
             */
            DescribeSearchIndexResponse.prototype.brotherIndexName = "";

            /**
             * DescribeSearchIndexResponse createTime.
             * @member {number|Long} createTime
             * @memberof search.proto.DescribeSearchIndexResponse
             * @instance
             */
            DescribeSearchIndexResponse.prototype.createTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * DescribeSearchIndexResponse timeToLive.
             * @member {number} timeToLive
             * @memberof search.proto.DescribeSearchIndexResponse
             * @instance
             */
            DescribeSearchIndexResponse.prototype.timeToLive = 0;

            /**
             * DescribeSearchIndexResponse indexStatus.
             * @member {search.proto.IIndexStatus|null|undefined} indexStatus
             * @memberof search.proto.DescribeSearchIndexResponse
             * @instance
             */
            DescribeSearchIndexResponse.prototype.indexStatus = null;

            /**
             * Creates a new DescribeSearchIndexResponse instance using the specified properties.
             * @function create
             * @memberof search.proto.DescribeSearchIndexResponse
             * @static
             * @param {search.proto.IDescribeSearchIndexResponse=} [properties] Properties to set
             * @returns {search.proto.DescribeSearchIndexResponse} DescribeSearchIndexResponse instance
             */
            DescribeSearchIndexResponse.create = function create(properties) {
                return new DescribeSearchIndexResponse(properties);
            };

            /**
             * Encodes the specified DescribeSearchIndexResponse message. Does not implicitly {@link search.proto.DescribeSearchIndexResponse.verify|verify} messages.
             * @function encode
             * @memberof search.proto.DescribeSearchIndexResponse
             * @static
             * @param {search.proto.IDescribeSearchIndexResponse} message DescribeSearchIndexResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeSearchIndexResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.schema != null && Object.hasOwnProperty.call(message, "schema"))
                    $root.search.proto.IndexSchema.encode(message.schema, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.syncStat != null && Object.hasOwnProperty.call(message, "syncStat"))
                    $root.search.proto.SyncStat.encode(message.syncStat, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.meteringInfo != null && Object.hasOwnProperty.call(message, "meteringInfo"))
                    $root.search.proto.MeteringInfo.encode(message.meteringInfo, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.brotherIndexName != null && Object.hasOwnProperty.call(message, "brotherIndexName"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.brotherIndexName);
                if (message.createTime != null && Object.hasOwnProperty.call(message, "createTime"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int64(message.createTime);
                if (message.timeToLive != null && Object.hasOwnProperty.call(message, "timeToLive"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.timeToLive);
                if (message.indexStatus != null && Object.hasOwnProperty.call(message, "indexStatus"))
                    $root.search.proto.IndexStatus.encode(message.indexStatus, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DescribeSearchIndexResponse message, length delimited. Does not implicitly {@link search.proto.DescribeSearchIndexResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.DescribeSearchIndexResponse
             * @static
             * @param {search.proto.IDescribeSearchIndexResponse} message DescribeSearchIndexResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeSearchIndexResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DescribeSearchIndexResponse message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.DescribeSearchIndexResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.DescribeSearchIndexResponse} DescribeSearchIndexResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeSearchIndexResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.DescribeSearchIndexResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.schema = $root.search.proto.IndexSchema.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.syncStat = $root.search.proto.SyncStat.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.meteringInfo = $root.search.proto.MeteringInfo.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.brotherIndexName = reader.string();
                        break;
                    case 6:
                        message.createTime = reader.int64();
                        break;
                    case 7:
                        message.timeToLive = reader.int32();
                        break;
                    case 8:
                        message.indexStatus = $root.search.proto.IndexStatus.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DescribeSearchIndexResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.DescribeSearchIndexResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.DescribeSearchIndexResponse} DescribeSearchIndexResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeSearchIndexResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DescribeSearchIndexResponse message.
             * @function verify
             * @memberof search.proto.DescribeSearchIndexResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DescribeSearchIndexResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.schema != null && message.hasOwnProperty("schema")) {
                    var error = $root.search.proto.IndexSchema.verify(message.schema);
                    if (error)
                        return "schema." + error;
                }
                if (message.syncStat != null && message.hasOwnProperty("syncStat")) {
                    var error = $root.search.proto.SyncStat.verify(message.syncStat);
                    if (error)
                        return "syncStat." + error;
                }
                if (message.meteringInfo != null && message.hasOwnProperty("meteringInfo")) {
                    var error = $root.search.proto.MeteringInfo.verify(message.meteringInfo);
                    if (error)
                        return "meteringInfo." + error;
                }
                if (message.brotherIndexName != null && message.hasOwnProperty("brotherIndexName"))
                    if (!$util.isString(message.brotherIndexName))
                        return "brotherIndexName: string expected";
                if (message.createTime != null && message.hasOwnProperty("createTime"))
                    if (!$util.isInteger(message.createTime) && !(message.createTime && $util.isInteger(message.createTime.low) && $util.isInteger(message.createTime.high)))
                        return "createTime: integer|Long expected";
                if (message.timeToLive != null && message.hasOwnProperty("timeToLive"))
                    if (!$util.isInteger(message.timeToLive))
                        return "timeToLive: integer expected";
                if (message.indexStatus != null && message.hasOwnProperty("indexStatus")) {
                    var error = $root.search.proto.IndexStatus.verify(message.indexStatus);
                    if (error)
                        return "indexStatus." + error;
                }
                return null;
            };

            /**
             * Creates a DescribeSearchIndexResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.DescribeSearchIndexResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.DescribeSearchIndexResponse} DescribeSearchIndexResponse
             */
            DescribeSearchIndexResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.DescribeSearchIndexResponse)
                    return object;
                var message = new $root.search.proto.DescribeSearchIndexResponse();
                if (object.schema != null) {
                    if (typeof object.schema !== "object")
                        throw TypeError(".search.proto.DescribeSearchIndexResponse.schema: object expected");
                    message.schema = $root.search.proto.IndexSchema.fromObject(object.schema);
                }
                if (object.syncStat != null) {
                    if (typeof object.syncStat !== "object")
                        throw TypeError(".search.proto.DescribeSearchIndexResponse.syncStat: object expected");
                    message.syncStat = $root.search.proto.SyncStat.fromObject(object.syncStat);
                }
                if (object.meteringInfo != null) {
                    if (typeof object.meteringInfo !== "object")
                        throw TypeError(".search.proto.DescribeSearchIndexResponse.meteringInfo: object expected");
                    message.meteringInfo = $root.search.proto.MeteringInfo.fromObject(object.meteringInfo);
                }
                if (object.brotherIndexName != null)
                    message.brotherIndexName = String(object.brotherIndexName);
                if (object.createTime != null)
                    if ($util.Long)
                        (message.createTime = $util.Long.fromValue(object.createTime)).unsigned = false;
                    else if (typeof object.createTime === "string")
                        message.createTime = parseInt(object.createTime, 10);
                    else if (typeof object.createTime === "number")
                        message.createTime = object.createTime;
                    else if (typeof object.createTime === "object")
                        message.createTime = new $util.LongBits(object.createTime.low >>> 0, object.createTime.high >>> 0).toNumber();
                if (object.timeToLive != null)
                    message.timeToLive = object.timeToLive | 0;
                if (object.indexStatus != null) {
                    if (typeof object.indexStatus !== "object")
                        throw TypeError(".search.proto.DescribeSearchIndexResponse.indexStatus: object expected");
                    message.indexStatus = $root.search.proto.IndexStatus.fromObject(object.indexStatus);
                }
                return message;
            };

            /**
             * Creates a plain object from a DescribeSearchIndexResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.DescribeSearchIndexResponse
             * @static
             * @param {search.proto.DescribeSearchIndexResponse} message DescribeSearchIndexResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescribeSearchIndexResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.schema = null;
                    object.syncStat = null;
                    object.meteringInfo = null;
                    object.brotherIndexName = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.createTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.createTime = options.longs === String ? "0" : 0;
                    object.timeToLive = 0;
                    object.indexStatus = null;
                }
                if (message.schema != null && message.hasOwnProperty("schema"))
                    object.schema = $root.search.proto.IndexSchema.toObject(message.schema, options);
                if (message.syncStat != null && message.hasOwnProperty("syncStat"))
                    object.syncStat = $root.search.proto.SyncStat.toObject(message.syncStat, options);
                if (message.meteringInfo != null && message.hasOwnProperty("meteringInfo"))
                    object.meteringInfo = $root.search.proto.MeteringInfo.toObject(message.meteringInfo, options);
                if (message.brotherIndexName != null && message.hasOwnProperty("brotherIndexName"))
                    object.brotherIndexName = message.brotherIndexName;
                if (message.createTime != null && message.hasOwnProperty("createTime"))
                    if (typeof message.createTime === "number")
                        object.createTime = options.longs === String ? String(message.createTime) : message.createTime;
                    else
                        object.createTime = options.longs === String ? $util.Long.prototype.toString.call(message.createTime) : options.longs === Number ? new $util.LongBits(message.createTime.low >>> 0, message.createTime.high >>> 0).toNumber() : message.createTime;
                if (message.timeToLive != null && message.hasOwnProperty("timeToLive"))
                    object.timeToLive = message.timeToLive;
                if (message.indexStatus != null && message.hasOwnProperty("indexStatus"))
                    object.indexStatus = $root.search.proto.IndexStatus.toObject(message.indexStatus, options);
                return object;
            };

            /**
             * Converts this DescribeSearchIndexResponse to JSON.
             * @function toJSON
             * @memberof search.proto.DescribeSearchIndexResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DescribeSearchIndexResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DescribeSearchIndexResponse;
        })();

        proto.IndexStatus = (function() {

            /**
             * Properties of an IndexStatus.
             * @memberof search.proto
             * @interface IIndexStatus
             * @property {search.proto.IndexStatusEnum|null} [status] IndexStatus status
             * @property {string|null} [statusDescription] IndexStatus statusDescription
             */

            /**
             * Constructs a new IndexStatus.
             * @memberof search.proto
             * @classdesc Represents an IndexStatus.
             * @implements IIndexStatus
             * @constructor
             * @param {search.proto.IIndexStatus=} [properties] Properties to set
             */
            function IndexStatus(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * IndexStatus status.
             * @member {search.proto.IndexStatusEnum} status
             * @memberof search.proto.IndexStatus
             * @instance
             */
            IndexStatus.prototype.status = 1;

            /**
             * IndexStatus statusDescription.
             * @member {string} statusDescription
             * @memberof search.proto.IndexStatus
             * @instance
             */
            IndexStatus.prototype.statusDescription = "";

            /**
             * Creates a new IndexStatus instance using the specified properties.
             * @function create
             * @memberof search.proto.IndexStatus
             * @static
             * @param {search.proto.IIndexStatus=} [properties] Properties to set
             * @returns {search.proto.IndexStatus} IndexStatus instance
             */
            IndexStatus.create = function create(properties) {
                return new IndexStatus(properties);
            };

            /**
             * Encodes the specified IndexStatus message. Does not implicitly {@link search.proto.IndexStatus.verify|verify} messages.
             * @function encode
             * @memberof search.proto.IndexStatus
             * @static
             * @param {search.proto.IIndexStatus} message IndexStatus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IndexStatus.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                if (message.statusDescription != null && Object.hasOwnProperty.call(message, "statusDescription"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.statusDescription);
                return writer;
            };

            /**
             * Encodes the specified IndexStatus message, length delimited. Does not implicitly {@link search.proto.IndexStatus.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.IndexStatus
             * @static
             * @param {search.proto.IIndexStatus} message IndexStatus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IndexStatus.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an IndexStatus message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.IndexStatus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.IndexStatus} IndexStatus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IndexStatus.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.IndexStatus();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.status = reader.int32();
                        break;
                    case 2:
                        message.statusDescription = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an IndexStatus message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.IndexStatus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.IndexStatus} IndexStatus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IndexStatus.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an IndexStatus message.
             * @function verify
             * @memberof search.proto.IndexStatus
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            IndexStatus.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.status != null && message.hasOwnProperty("status"))
                    switch (message.status) {
                    default:
                        return "status: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.statusDescription != null && message.hasOwnProperty("statusDescription"))
                    if (!$util.isString(message.statusDescription))
                        return "statusDescription: string expected";
                return null;
            };

            /**
             * Creates an IndexStatus message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.IndexStatus
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.IndexStatus} IndexStatus
             */
            IndexStatus.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.IndexStatus)
                    return object;
                var message = new $root.search.proto.IndexStatus();
                switch (object.status) {
                case "PENDING":
                case 1:
                    message.status = 1;
                    break;
                case "FAILED":
                case 2:
                    message.status = 2;
                    break;
                case "RUNNING":
                case 3:
                    message.status = 3;
                    break;
                }
                if (object.statusDescription != null)
                    message.statusDescription = String(object.statusDescription);
                return message;
            };

            /**
             * Creates a plain object from an IndexStatus message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.IndexStatus
             * @static
             * @param {search.proto.IndexStatus} message IndexStatus
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            IndexStatus.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.status = options.enums === String ? "PENDING" : 1;
                    object.statusDescription = "";
                }
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = options.enums === String ? $root.search.proto.IndexStatusEnum[message.status] : message.status;
                if (message.statusDescription != null && message.hasOwnProperty("statusDescription"))
                    object.statusDescription = message.statusDescription;
                return object;
            };

            /**
             * Converts this IndexStatus to JSON.
             * @function toJSON
             * @memberof search.proto.IndexStatus
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            IndexStatus.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return IndexStatus;
        })();

        /**
         * IndexStatusEnum enum.
         * @name search.proto.IndexStatusEnum
         * @enum {number}
         * @property {number} PENDING=1 PENDING value
         * @property {number} FAILED=2 FAILED value
         * @property {number} RUNNING=3 RUNNING value
         */
        proto.IndexStatusEnum = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "PENDING"] = 1;
            values[valuesById[2] = "FAILED"] = 2;
            values[valuesById[3] = "RUNNING"] = 3;
            return values;
        })();

        proto.ComputeSplitsRequest = (function() {

            /**
             * Properties of a ComputeSplitsRequest.
             * @memberof search.proto
             * @interface IComputeSplitsRequest
             * @property {string|null} [tableName] ComputeSplitsRequest tableName
             * @property {search.proto.ISearchIndexSplitsOptions|null} [searchIndexSplitsOptions] ComputeSplitsRequest searchIndexSplitsOptions
             */

            /**
             * Constructs a new ComputeSplitsRequest.
             * @memberof search.proto
             * @classdesc Represents a ComputeSplitsRequest.
             * @implements IComputeSplitsRequest
             * @constructor
             * @param {search.proto.IComputeSplitsRequest=} [properties] Properties to set
             */
            function ComputeSplitsRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ComputeSplitsRequest tableName.
             * @member {string} tableName
             * @memberof search.proto.ComputeSplitsRequest
             * @instance
             */
            ComputeSplitsRequest.prototype.tableName = "";

            /**
             * ComputeSplitsRequest searchIndexSplitsOptions.
             * @member {search.proto.ISearchIndexSplitsOptions|null|undefined} searchIndexSplitsOptions
             * @memberof search.proto.ComputeSplitsRequest
             * @instance
             */
            ComputeSplitsRequest.prototype.searchIndexSplitsOptions = null;

            /**
             * Creates a new ComputeSplitsRequest instance using the specified properties.
             * @function create
             * @memberof search.proto.ComputeSplitsRequest
             * @static
             * @param {search.proto.IComputeSplitsRequest=} [properties] Properties to set
             * @returns {search.proto.ComputeSplitsRequest} ComputeSplitsRequest instance
             */
            ComputeSplitsRequest.create = function create(properties) {
                return new ComputeSplitsRequest(properties);
            };

            /**
             * Encodes the specified ComputeSplitsRequest message. Does not implicitly {@link search.proto.ComputeSplitsRequest.verify|verify} messages.
             * @function encode
             * @memberof search.proto.ComputeSplitsRequest
             * @static
             * @param {search.proto.IComputeSplitsRequest} message ComputeSplitsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ComputeSplitsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tableName != null && Object.hasOwnProperty.call(message, "tableName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.tableName);
                if (message.searchIndexSplitsOptions != null && Object.hasOwnProperty.call(message, "searchIndexSplitsOptions"))
                    $root.search.proto.SearchIndexSplitsOptions.encode(message.searchIndexSplitsOptions, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ComputeSplitsRequest message, length delimited. Does not implicitly {@link search.proto.ComputeSplitsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.ComputeSplitsRequest
             * @static
             * @param {search.proto.IComputeSplitsRequest} message ComputeSplitsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ComputeSplitsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ComputeSplitsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.ComputeSplitsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.ComputeSplitsRequest} ComputeSplitsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ComputeSplitsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.ComputeSplitsRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tableName = reader.string();
                        break;
                    case 2:
                        message.searchIndexSplitsOptions = $root.search.proto.SearchIndexSplitsOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ComputeSplitsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.ComputeSplitsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.ComputeSplitsRequest} ComputeSplitsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ComputeSplitsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ComputeSplitsRequest message.
             * @function verify
             * @memberof search.proto.ComputeSplitsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ComputeSplitsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tableName != null && message.hasOwnProperty("tableName"))
                    if (!$util.isString(message.tableName))
                        return "tableName: string expected";
                if (message.searchIndexSplitsOptions != null && message.hasOwnProperty("searchIndexSplitsOptions")) {
                    var error = $root.search.proto.SearchIndexSplitsOptions.verify(message.searchIndexSplitsOptions);
                    if (error)
                        return "searchIndexSplitsOptions." + error;
                }
                return null;
            };

            /**
             * Creates a ComputeSplitsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.ComputeSplitsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.ComputeSplitsRequest} ComputeSplitsRequest
             */
            ComputeSplitsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.ComputeSplitsRequest)
                    return object;
                var message = new $root.search.proto.ComputeSplitsRequest();
                if (object.tableName != null)
                    message.tableName = String(object.tableName);
                if (object.searchIndexSplitsOptions != null) {
                    if (typeof object.searchIndexSplitsOptions !== "object")
                        throw TypeError(".search.proto.ComputeSplitsRequest.searchIndexSplitsOptions: object expected");
                    message.searchIndexSplitsOptions = $root.search.proto.SearchIndexSplitsOptions.fromObject(object.searchIndexSplitsOptions);
                }
                return message;
            };

            /**
             * Creates a plain object from a ComputeSplitsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.ComputeSplitsRequest
             * @static
             * @param {search.proto.ComputeSplitsRequest} message ComputeSplitsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ComputeSplitsRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.tableName = "";
                    object.searchIndexSplitsOptions = null;
                }
                if (message.tableName != null && message.hasOwnProperty("tableName"))
                    object.tableName = message.tableName;
                if (message.searchIndexSplitsOptions != null && message.hasOwnProperty("searchIndexSplitsOptions"))
                    object.searchIndexSplitsOptions = $root.search.proto.SearchIndexSplitsOptions.toObject(message.searchIndexSplitsOptions, options);
                return object;
            };

            /**
             * Converts this ComputeSplitsRequest to JSON.
             * @function toJSON
             * @memberof search.proto.ComputeSplitsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ComputeSplitsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ComputeSplitsRequest;
        })();

        proto.SearchIndexSplitsOptions = (function() {

            /**
             * Properties of a SearchIndexSplitsOptions.
             * @memberof search.proto
             * @interface ISearchIndexSplitsOptions
             * @property {string|null} [indexName] SearchIndexSplitsOptions indexName
             */

            /**
             * Constructs a new SearchIndexSplitsOptions.
             * @memberof search.proto
             * @classdesc Represents a SearchIndexSplitsOptions.
             * @implements ISearchIndexSplitsOptions
             * @constructor
             * @param {search.proto.ISearchIndexSplitsOptions=} [properties] Properties to set
             */
            function SearchIndexSplitsOptions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SearchIndexSplitsOptions indexName.
             * @member {string} indexName
             * @memberof search.proto.SearchIndexSplitsOptions
             * @instance
             */
            SearchIndexSplitsOptions.prototype.indexName = "";

            /**
             * Creates a new SearchIndexSplitsOptions instance using the specified properties.
             * @function create
             * @memberof search.proto.SearchIndexSplitsOptions
             * @static
             * @param {search.proto.ISearchIndexSplitsOptions=} [properties] Properties to set
             * @returns {search.proto.SearchIndexSplitsOptions} SearchIndexSplitsOptions instance
             */
            SearchIndexSplitsOptions.create = function create(properties) {
                return new SearchIndexSplitsOptions(properties);
            };

            /**
             * Encodes the specified SearchIndexSplitsOptions message. Does not implicitly {@link search.proto.SearchIndexSplitsOptions.verify|verify} messages.
             * @function encode
             * @memberof search.proto.SearchIndexSplitsOptions
             * @static
             * @param {search.proto.ISearchIndexSplitsOptions} message SearchIndexSplitsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SearchIndexSplitsOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.indexName != null && Object.hasOwnProperty.call(message, "indexName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.indexName);
                return writer;
            };

            /**
             * Encodes the specified SearchIndexSplitsOptions message, length delimited. Does not implicitly {@link search.proto.SearchIndexSplitsOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.SearchIndexSplitsOptions
             * @static
             * @param {search.proto.ISearchIndexSplitsOptions} message SearchIndexSplitsOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SearchIndexSplitsOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SearchIndexSplitsOptions message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.SearchIndexSplitsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.SearchIndexSplitsOptions} SearchIndexSplitsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SearchIndexSplitsOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.SearchIndexSplitsOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.indexName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SearchIndexSplitsOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.SearchIndexSplitsOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.SearchIndexSplitsOptions} SearchIndexSplitsOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SearchIndexSplitsOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SearchIndexSplitsOptions message.
             * @function verify
             * @memberof search.proto.SearchIndexSplitsOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SearchIndexSplitsOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.indexName != null && message.hasOwnProperty("indexName"))
                    if (!$util.isString(message.indexName))
                        return "indexName: string expected";
                return null;
            };

            /**
             * Creates a SearchIndexSplitsOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.SearchIndexSplitsOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.SearchIndexSplitsOptions} SearchIndexSplitsOptions
             */
            SearchIndexSplitsOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.SearchIndexSplitsOptions)
                    return object;
                var message = new $root.search.proto.SearchIndexSplitsOptions();
                if (object.indexName != null)
                    message.indexName = String(object.indexName);
                return message;
            };

            /**
             * Creates a plain object from a SearchIndexSplitsOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.SearchIndexSplitsOptions
             * @static
             * @param {search.proto.SearchIndexSplitsOptions} message SearchIndexSplitsOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SearchIndexSplitsOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.indexName = "";
                if (message.indexName != null && message.hasOwnProperty("indexName"))
                    object.indexName = message.indexName;
                return object;
            };

            /**
             * Converts this SearchIndexSplitsOptions to JSON.
             * @function toJSON
             * @memberof search.proto.SearchIndexSplitsOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SearchIndexSplitsOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SearchIndexSplitsOptions;
        })();

        proto.ComputeSplitsResponse = (function() {

            /**
             * Properties of a ComputeSplitsResponse.
             * @memberof search.proto
             * @interface IComputeSplitsResponse
             * @property {Uint8Array|null} [sessionId] ComputeSplitsResponse sessionId
             * @property {number|null} [splitsSize] ComputeSplitsResponse splitsSize
             */

            /**
             * Constructs a new ComputeSplitsResponse.
             * @memberof search.proto
             * @classdesc Represents a ComputeSplitsResponse.
             * @implements IComputeSplitsResponse
             * @constructor
             * @param {search.proto.IComputeSplitsResponse=} [properties] Properties to set
             */
            function ComputeSplitsResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ComputeSplitsResponse sessionId.
             * @member {Uint8Array} sessionId
             * @memberof search.proto.ComputeSplitsResponse
             * @instance
             */
            ComputeSplitsResponse.prototype.sessionId = $util.newBuffer([]);

            /**
             * ComputeSplitsResponse splitsSize.
             * @member {number} splitsSize
             * @memberof search.proto.ComputeSplitsResponse
             * @instance
             */
            ComputeSplitsResponse.prototype.splitsSize = 0;

            /**
             * Creates a new ComputeSplitsResponse instance using the specified properties.
             * @function create
             * @memberof search.proto.ComputeSplitsResponse
             * @static
             * @param {search.proto.IComputeSplitsResponse=} [properties] Properties to set
             * @returns {search.proto.ComputeSplitsResponse} ComputeSplitsResponse instance
             */
            ComputeSplitsResponse.create = function create(properties) {
                return new ComputeSplitsResponse(properties);
            };

            /**
             * Encodes the specified ComputeSplitsResponse message. Does not implicitly {@link search.proto.ComputeSplitsResponse.verify|verify} messages.
             * @function encode
             * @memberof search.proto.ComputeSplitsResponse
             * @static
             * @param {search.proto.IComputeSplitsResponse} message ComputeSplitsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ComputeSplitsResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sessionId != null && Object.hasOwnProperty.call(message, "sessionId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.sessionId);
                if (message.splitsSize != null && Object.hasOwnProperty.call(message, "splitsSize"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.splitsSize);
                return writer;
            };

            /**
             * Encodes the specified ComputeSplitsResponse message, length delimited. Does not implicitly {@link search.proto.ComputeSplitsResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.ComputeSplitsResponse
             * @static
             * @param {search.proto.IComputeSplitsResponse} message ComputeSplitsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ComputeSplitsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ComputeSplitsResponse message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.ComputeSplitsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.ComputeSplitsResponse} ComputeSplitsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ComputeSplitsResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.ComputeSplitsResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sessionId = reader.bytes();
                        break;
                    case 2:
                        message.splitsSize = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ComputeSplitsResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.ComputeSplitsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.ComputeSplitsResponse} ComputeSplitsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ComputeSplitsResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ComputeSplitsResponse message.
             * @function verify
             * @memberof search.proto.ComputeSplitsResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ComputeSplitsResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    if (!(message.sessionId && typeof message.sessionId.length === "number" || $util.isString(message.sessionId)))
                        return "sessionId: buffer expected";
                if (message.splitsSize != null && message.hasOwnProperty("splitsSize"))
                    if (!$util.isInteger(message.splitsSize))
                        return "splitsSize: integer expected";
                return null;
            };

            /**
             * Creates a ComputeSplitsResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.ComputeSplitsResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.ComputeSplitsResponse} ComputeSplitsResponse
             */
            ComputeSplitsResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.ComputeSplitsResponse)
                    return object;
                var message = new $root.search.proto.ComputeSplitsResponse();
                if (object.sessionId != null)
                    if (typeof object.sessionId === "string")
                        $util.base64.decode(object.sessionId, message.sessionId = $util.newBuffer($util.base64.length(object.sessionId)), 0);
                    else if (object.sessionId.length)
                        message.sessionId = object.sessionId;
                if (object.splitsSize != null)
                    message.splitsSize = object.splitsSize | 0;
                return message;
            };

            /**
             * Creates a plain object from a ComputeSplitsResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.ComputeSplitsResponse
             * @static
             * @param {search.proto.ComputeSplitsResponse} message ComputeSplitsResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ComputeSplitsResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.sessionId = "";
                    else {
                        object.sessionId = [];
                        if (options.bytes !== Array)
                            object.sessionId = $util.newBuffer(object.sessionId);
                    }
                    object.splitsSize = 0;
                }
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    object.sessionId = options.bytes === String ? $util.base64.encode(message.sessionId, 0, message.sessionId.length) : options.bytes === Array ? Array.prototype.slice.call(message.sessionId) : message.sessionId;
                if (message.splitsSize != null && message.hasOwnProperty("splitsSize"))
                    object.splitsSize = message.splitsSize;
                return object;
            };

            /**
             * Converts this ComputeSplitsResponse to JSON.
             * @function toJSON
             * @memberof search.proto.ComputeSplitsResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ComputeSplitsResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ComputeSplitsResponse;
        })();

        proto.ScanQuery = (function() {

            /**
             * Properties of a ScanQuery.
             * @memberof search.proto
             * @interface IScanQuery
             * @property {search.proto.IQuery|null} [query] ScanQuery query
             * @property {number|null} [limit] ScanQuery limit
             * @property {number|null} [aliveTime] ScanQuery aliveTime
             * @property {Uint8Array|null} [token] ScanQuery token
             * @property {number|null} [currentParallelId] ScanQuery currentParallelId
             * @property {number|null} [maxParallel] ScanQuery maxParallel
             */

            /**
             * Constructs a new ScanQuery.
             * @memberof search.proto
             * @classdesc Represents a ScanQuery.
             * @implements IScanQuery
             * @constructor
             * @param {search.proto.IScanQuery=} [properties] Properties to set
             */
            function ScanQuery(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ScanQuery query.
             * @member {search.proto.IQuery|null|undefined} query
             * @memberof search.proto.ScanQuery
             * @instance
             */
            ScanQuery.prototype.query = null;

            /**
             * ScanQuery limit.
             * @member {number} limit
             * @memberof search.proto.ScanQuery
             * @instance
             */
            ScanQuery.prototype.limit = 0;

            /**
             * ScanQuery aliveTime.
             * @member {number} aliveTime
             * @memberof search.proto.ScanQuery
             * @instance
             */
            ScanQuery.prototype.aliveTime = 0;

            /**
             * ScanQuery token.
             * @member {Uint8Array} token
             * @memberof search.proto.ScanQuery
             * @instance
             */
            ScanQuery.prototype.token = $util.newBuffer([]);

            /**
             * ScanQuery currentParallelId.
             * @member {number} currentParallelId
             * @memberof search.proto.ScanQuery
             * @instance
             */
            ScanQuery.prototype.currentParallelId = 0;

            /**
             * ScanQuery maxParallel.
             * @member {number} maxParallel
             * @memberof search.proto.ScanQuery
             * @instance
             */
            ScanQuery.prototype.maxParallel = 0;

            /**
             * Creates a new ScanQuery instance using the specified properties.
             * @function create
             * @memberof search.proto.ScanQuery
             * @static
             * @param {search.proto.IScanQuery=} [properties] Properties to set
             * @returns {search.proto.ScanQuery} ScanQuery instance
             */
            ScanQuery.create = function create(properties) {
                return new ScanQuery(properties);
            };

            /**
             * Encodes the specified ScanQuery message. Does not implicitly {@link search.proto.ScanQuery.verify|verify} messages.
             * @function encode
             * @memberof search.proto.ScanQuery
             * @static
             * @param {search.proto.IScanQuery} message ScanQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ScanQuery.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.query != null && Object.hasOwnProperty.call(message, "query"))
                    $root.search.proto.Query.encode(message.query, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.limit != null && Object.hasOwnProperty.call(message, "limit"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.limit);
                if (message.aliveTime != null && Object.hasOwnProperty.call(message, "aliveTime"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.aliveTime);
                if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.token);
                if (message.currentParallelId != null && Object.hasOwnProperty.call(message, "currentParallelId"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.currentParallelId);
                if (message.maxParallel != null && Object.hasOwnProperty.call(message, "maxParallel"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.maxParallel);
                return writer;
            };

            /**
             * Encodes the specified ScanQuery message, length delimited. Does not implicitly {@link search.proto.ScanQuery.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.ScanQuery
             * @static
             * @param {search.proto.IScanQuery} message ScanQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ScanQuery.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ScanQuery message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.ScanQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.ScanQuery} ScanQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ScanQuery.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.ScanQuery();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.query = $root.search.proto.Query.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.limit = reader.int32();
                        break;
                    case 3:
                        message.aliveTime = reader.int32();
                        break;
                    case 4:
                        message.token = reader.bytes();
                        break;
                    case 5:
                        message.currentParallelId = reader.int32();
                        break;
                    case 6:
                        message.maxParallel = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ScanQuery message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.ScanQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.ScanQuery} ScanQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ScanQuery.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ScanQuery message.
             * @function verify
             * @memberof search.proto.ScanQuery
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ScanQuery.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.query != null && message.hasOwnProperty("query")) {
                    var error = $root.search.proto.Query.verify(message.query);
                    if (error)
                        return "query." + error;
                }
                if (message.limit != null && message.hasOwnProperty("limit"))
                    if (!$util.isInteger(message.limit))
                        return "limit: integer expected";
                if (message.aliveTime != null && message.hasOwnProperty("aliveTime"))
                    if (!$util.isInteger(message.aliveTime))
                        return "aliveTime: integer expected";
                if (message.token != null && message.hasOwnProperty("token"))
                    if (!(message.token && typeof message.token.length === "number" || $util.isString(message.token)))
                        return "token: buffer expected";
                if (message.currentParallelId != null && message.hasOwnProperty("currentParallelId"))
                    if (!$util.isInteger(message.currentParallelId))
                        return "currentParallelId: integer expected";
                if (message.maxParallel != null && message.hasOwnProperty("maxParallel"))
                    if (!$util.isInteger(message.maxParallel))
                        return "maxParallel: integer expected";
                return null;
            };

            /**
             * Creates a ScanQuery message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.ScanQuery
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.ScanQuery} ScanQuery
             */
            ScanQuery.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.ScanQuery)
                    return object;
                var message = new $root.search.proto.ScanQuery();
                if (object.query != null) {
                    if (typeof object.query !== "object")
                        throw TypeError(".search.proto.ScanQuery.query: object expected");
                    message.query = $root.search.proto.Query.fromObject(object.query);
                }
                if (object.limit != null)
                    message.limit = object.limit | 0;
                if (object.aliveTime != null)
                    message.aliveTime = object.aliveTime | 0;
                if (object.token != null)
                    if (typeof object.token === "string")
                        $util.base64.decode(object.token, message.token = $util.newBuffer($util.base64.length(object.token)), 0);
                    else if (object.token.length)
                        message.token = object.token;
                if (object.currentParallelId != null)
                    message.currentParallelId = object.currentParallelId | 0;
                if (object.maxParallel != null)
                    message.maxParallel = object.maxParallel | 0;
                return message;
            };

            /**
             * Creates a plain object from a ScanQuery message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.ScanQuery
             * @static
             * @param {search.proto.ScanQuery} message ScanQuery
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ScanQuery.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.query = null;
                    object.limit = 0;
                    object.aliveTime = 0;
                    if (options.bytes === String)
                        object.token = "";
                    else {
                        object.token = [];
                        if (options.bytes !== Array)
                            object.token = $util.newBuffer(object.token);
                    }
                    object.currentParallelId = 0;
                    object.maxParallel = 0;
                }
                if (message.query != null && message.hasOwnProperty("query"))
                    object.query = $root.search.proto.Query.toObject(message.query, options);
                if (message.limit != null && message.hasOwnProperty("limit"))
                    object.limit = message.limit;
                if (message.aliveTime != null && message.hasOwnProperty("aliveTime"))
                    object.aliveTime = message.aliveTime;
                if (message.token != null && message.hasOwnProperty("token"))
                    object.token = options.bytes === String ? $util.base64.encode(message.token, 0, message.token.length) : options.bytes === Array ? Array.prototype.slice.call(message.token) : message.token;
                if (message.currentParallelId != null && message.hasOwnProperty("currentParallelId"))
                    object.currentParallelId = message.currentParallelId;
                if (message.maxParallel != null && message.hasOwnProperty("maxParallel"))
                    object.maxParallel = message.maxParallel;
                return object;
            };

            /**
             * Converts this ScanQuery to JSON.
             * @function toJSON
             * @memberof search.proto.ScanQuery
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ScanQuery.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ScanQuery;
        })();

        proto.ParallelScanRequest = (function() {

            /**
             * Properties of a ParallelScanRequest.
             * @memberof search.proto
             * @interface IParallelScanRequest
             * @property {string|null} [tableName] ParallelScanRequest tableName
             * @property {string|null} [indexName] ParallelScanRequest indexName
             * @property {search.proto.IColumnsToGet|null} [columnsToGet] ParallelScanRequest columnsToGet
             * @property {Uint8Array|null} [sessionId] ParallelScanRequest sessionId
             * @property {search.proto.IScanQuery|null} [scanQuery] ParallelScanRequest scanQuery
             * @property {number|null} [timeoutMs] ParallelScanRequest timeoutMs
             */

            /**
             * Constructs a new ParallelScanRequest.
             * @memberof search.proto
             * @classdesc Represents a ParallelScanRequest.
             * @implements IParallelScanRequest
             * @constructor
             * @param {search.proto.IParallelScanRequest=} [properties] Properties to set
             */
            function ParallelScanRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ParallelScanRequest tableName.
             * @member {string} tableName
             * @memberof search.proto.ParallelScanRequest
             * @instance
             */
            ParallelScanRequest.prototype.tableName = "";

            /**
             * ParallelScanRequest indexName.
             * @member {string} indexName
             * @memberof search.proto.ParallelScanRequest
             * @instance
             */
            ParallelScanRequest.prototype.indexName = "";

            /**
             * ParallelScanRequest columnsToGet.
             * @member {search.proto.IColumnsToGet|null|undefined} columnsToGet
             * @memberof search.proto.ParallelScanRequest
             * @instance
             */
            ParallelScanRequest.prototype.columnsToGet = null;

            /**
             * ParallelScanRequest sessionId.
             * @member {Uint8Array} sessionId
             * @memberof search.proto.ParallelScanRequest
             * @instance
             */
            ParallelScanRequest.prototype.sessionId = $util.newBuffer([]);

            /**
             * ParallelScanRequest scanQuery.
             * @member {search.proto.IScanQuery|null|undefined} scanQuery
             * @memberof search.proto.ParallelScanRequest
             * @instance
             */
            ParallelScanRequest.prototype.scanQuery = null;

            /**
             * ParallelScanRequest timeoutMs.
             * @member {number} timeoutMs
             * @memberof search.proto.ParallelScanRequest
             * @instance
             */
            ParallelScanRequest.prototype.timeoutMs = 0;

            /**
             * Creates a new ParallelScanRequest instance using the specified properties.
             * @function create
             * @memberof search.proto.ParallelScanRequest
             * @static
             * @param {search.proto.IParallelScanRequest=} [properties] Properties to set
             * @returns {search.proto.ParallelScanRequest} ParallelScanRequest instance
             */
            ParallelScanRequest.create = function create(properties) {
                return new ParallelScanRequest(properties);
            };

            /**
             * Encodes the specified ParallelScanRequest message. Does not implicitly {@link search.proto.ParallelScanRequest.verify|verify} messages.
             * @function encode
             * @memberof search.proto.ParallelScanRequest
             * @static
             * @param {search.proto.IParallelScanRequest} message ParallelScanRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ParallelScanRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tableName != null && Object.hasOwnProperty.call(message, "tableName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.tableName);
                if (message.indexName != null && Object.hasOwnProperty.call(message, "indexName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.indexName);
                if (message.columnsToGet != null && Object.hasOwnProperty.call(message, "columnsToGet"))
                    $root.search.proto.ColumnsToGet.encode(message.columnsToGet, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.sessionId != null && Object.hasOwnProperty.call(message, "sessionId"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.sessionId);
                if (message.scanQuery != null && Object.hasOwnProperty.call(message, "scanQuery"))
                    $root.search.proto.ScanQuery.encode(message.scanQuery, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.timeoutMs != null && Object.hasOwnProperty.call(message, "timeoutMs"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.timeoutMs);
                return writer;
            };

            /**
             * Encodes the specified ParallelScanRequest message, length delimited. Does not implicitly {@link search.proto.ParallelScanRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.ParallelScanRequest
             * @static
             * @param {search.proto.IParallelScanRequest} message ParallelScanRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ParallelScanRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ParallelScanRequest message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.ParallelScanRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.ParallelScanRequest} ParallelScanRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ParallelScanRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.ParallelScanRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tableName = reader.string();
                        break;
                    case 2:
                        message.indexName = reader.string();
                        break;
                    case 3:
                        message.columnsToGet = $root.search.proto.ColumnsToGet.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.sessionId = reader.bytes();
                        break;
                    case 5:
                        message.scanQuery = $root.search.proto.ScanQuery.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.timeoutMs = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ParallelScanRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.ParallelScanRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.ParallelScanRequest} ParallelScanRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ParallelScanRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ParallelScanRequest message.
             * @function verify
             * @memberof search.proto.ParallelScanRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ParallelScanRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tableName != null && message.hasOwnProperty("tableName"))
                    if (!$util.isString(message.tableName))
                        return "tableName: string expected";
                if (message.indexName != null && message.hasOwnProperty("indexName"))
                    if (!$util.isString(message.indexName))
                        return "indexName: string expected";
                if (message.columnsToGet != null && message.hasOwnProperty("columnsToGet")) {
                    var error = $root.search.proto.ColumnsToGet.verify(message.columnsToGet);
                    if (error)
                        return "columnsToGet." + error;
                }
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    if (!(message.sessionId && typeof message.sessionId.length === "number" || $util.isString(message.sessionId)))
                        return "sessionId: buffer expected";
                if (message.scanQuery != null && message.hasOwnProperty("scanQuery")) {
                    var error = $root.search.proto.ScanQuery.verify(message.scanQuery);
                    if (error)
                        return "scanQuery." + error;
                }
                if (message.timeoutMs != null && message.hasOwnProperty("timeoutMs"))
                    if (!$util.isInteger(message.timeoutMs))
                        return "timeoutMs: integer expected";
                return null;
            };

            /**
             * Creates a ParallelScanRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.ParallelScanRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.ParallelScanRequest} ParallelScanRequest
             */
            ParallelScanRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.ParallelScanRequest)
                    return object;
                var message = new $root.search.proto.ParallelScanRequest();
                if (object.tableName != null)
                    message.tableName = String(object.tableName);
                if (object.indexName != null)
                    message.indexName = String(object.indexName);
                if (object.columnsToGet != null) {
                    if (typeof object.columnsToGet !== "object")
                        throw TypeError(".search.proto.ParallelScanRequest.columnsToGet: object expected");
                    message.columnsToGet = $root.search.proto.ColumnsToGet.fromObject(object.columnsToGet);
                }
                if (object.sessionId != null)
                    if (typeof object.sessionId === "string")
                        $util.base64.decode(object.sessionId, message.sessionId = $util.newBuffer($util.base64.length(object.sessionId)), 0);
                    else if (object.sessionId.length)
                        message.sessionId = object.sessionId;
                if (object.scanQuery != null) {
                    if (typeof object.scanQuery !== "object")
                        throw TypeError(".search.proto.ParallelScanRequest.scanQuery: object expected");
                    message.scanQuery = $root.search.proto.ScanQuery.fromObject(object.scanQuery);
                }
                if (object.timeoutMs != null)
                    message.timeoutMs = object.timeoutMs | 0;
                return message;
            };

            /**
             * Creates a plain object from a ParallelScanRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.ParallelScanRequest
             * @static
             * @param {search.proto.ParallelScanRequest} message ParallelScanRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ParallelScanRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.tableName = "";
                    object.indexName = "";
                    object.columnsToGet = null;
                    if (options.bytes === String)
                        object.sessionId = "";
                    else {
                        object.sessionId = [];
                        if (options.bytes !== Array)
                            object.sessionId = $util.newBuffer(object.sessionId);
                    }
                    object.scanQuery = null;
                    object.timeoutMs = 0;
                }
                if (message.tableName != null && message.hasOwnProperty("tableName"))
                    object.tableName = message.tableName;
                if (message.indexName != null && message.hasOwnProperty("indexName"))
                    object.indexName = message.indexName;
                if (message.columnsToGet != null && message.hasOwnProperty("columnsToGet"))
                    object.columnsToGet = $root.search.proto.ColumnsToGet.toObject(message.columnsToGet, options);
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    object.sessionId = options.bytes === String ? $util.base64.encode(message.sessionId, 0, message.sessionId.length) : options.bytes === Array ? Array.prototype.slice.call(message.sessionId) : message.sessionId;
                if (message.scanQuery != null && message.hasOwnProperty("scanQuery"))
                    object.scanQuery = $root.search.proto.ScanQuery.toObject(message.scanQuery, options);
                if (message.timeoutMs != null && message.hasOwnProperty("timeoutMs"))
                    object.timeoutMs = message.timeoutMs;
                return object;
            };

            /**
             * Converts this ParallelScanRequest to JSON.
             * @function toJSON
             * @memberof search.proto.ParallelScanRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ParallelScanRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ParallelScanRequest;
        })();

        proto.ParallelScanResponse = (function() {

            /**
             * Properties of a ParallelScanResponse.
             * @memberof search.proto
             * @interface IParallelScanResponse
             * @property {Array.<Uint8Array>|null} [rows] ParallelScanResponse rows
             * @property {Uint8Array|null} [nextToken] ParallelScanResponse nextToken
             */

            /**
             * Constructs a new ParallelScanResponse.
             * @memberof search.proto
             * @classdesc Represents a ParallelScanResponse.
             * @implements IParallelScanResponse
             * @constructor
             * @param {search.proto.IParallelScanResponse=} [properties] Properties to set
             */
            function ParallelScanResponse(properties) {
                this.rows = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ParallelScanResponse rows.
             * @member {Array.<Uint8Array>} rows
             * @memberof search.proto.ParallelScanResponse
             * @instance
             */
            ParallelScanResponse.prototype.rows = $util.emptyArray;

            /**
             * ParallelScanResponse nextToken.
             * @member {Uint8Array} nextToken
             * @memberof search.proto.ParallelScanResponse
             * @instance
             */
            ParallelScanResponse.prototype.nextToken = $util.newBuffer([]);

            /**
             * Creates a new ParallelScanResponse instance using the specified properties.
             * @function create
             * @memberof search.proto.ParallelScanResponse
             * @static
             * @param {search.proto.IParallelScanResponse=} [properties] Properties to set
             * @returns {search.proto.ParallelScanResponse} ParallelScanResponse instance
             */
            ParallelScanResponse.create = function create(properties) {
                return new ParallelScanResponse(properties);
            };

            /**
             * Encodes the specified ParallelScanResponse message. Does not implicitly {@link search.proto.ParallelScanResponse.verify|verify} messages.
             * @function encode
             * @memberof search.proto.ParallelScanResponse
             * @static
             * @param {search.proto.IParallelScanResponse} message ParallelScanResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ParallelScanResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.rows != null && message.rows.length)
                    for (var i = 0; i < message.rows.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.rows[i]);
                if (message.nextToken != null && Object.hasOwnProperty.call(message, "nextToken"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.nextToken);
                return writer;
            };

            /**
             * Encodes the specified ParallelScanResponse message, length delimited. Does not implicitly {@link search.proto.ParallelScanResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof search.proto.ParallelScanResponse
             * @static
             * @param {search.proto.IParallelScanResponse} message ParallelScanResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ParallelScanResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ParallelScanResponse message from the specified reader or buffer.
             * @function decode
             * @memberof search.proto.ParallelScanResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {search.proto.ParallelScanResponse} ParallelScanResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ParallelScanResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.search.proto.ParallelScanResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.rows && message.rows.length))
                            message.rows = [];
                        message.rows.push(reader.bytes());
                        break;
                    case 2:
                        message.nextToken = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ParallelScanResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof search.proto.ParallelScanResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {search.proto.ParallelScanResponse} ParallelScanResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ParallelScanResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ParallelScanResponse message.
             * @function verify
             * @memberof search.proto.ParallelScanResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ParallelScanResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.rows != null && message.hasOwnProperty("rows")) {
                    if (!Array.isArray(message.rows))
                        return "rows: array expected";
                    for (var i = 0; i < message.rows.length; ++i)
                        if (!(message.rows[i] && typeof message.rows[i].length === "number" || $util.isString(message.rows[i])))
                            return "rows: buffer[] expected";
                }
                if (message.nextToken != null && message.hasOwnProperty("nextToken"))
                    if (!(message.nextToken && typeof message.nextToken.length === "number" || $util.isString(message.nextToken)))
                        return "nextToken: buffer expected";
                return null;
            };

            /**
             * Creates a ParallelScanResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof search.proto.ParallelScanResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {search.proto.ParallelScanResponse} ParallelScanResponse
             */
            ParallelScanResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.search.proto.ParallelScanResponse)
                    return object;
                var message = new $root.search.proto.ParallelScanResponse();
                if (object.rows) {
                    if (!Array.isArray(object.rows))
                        throw TypeError(".search.proto.ParallelScanResponse.rows: array expected");
                    message.rows = [];
                    for (var i = 0; i < object.rows.length; ++i)
                        if (typeof object.rows[i] === "string")
                            $util.base64.decode(object.rows[i], message.rows[i] = $util.newBuffer($util.base64.length(object.rows[i])), 0);
                        else if (object.rows[i].length)
                            message.rows[i] = object.rows[i];
                }
                if (object.nextToken != null)
                    if (typeof object.nextToken === "string")
                        $util.base64.decode(object.nextToken, message.nextToken = $util.newBuffer($util.base64.length(object.nextToken)), 0);
                    else if (object.nextToken.length)
                        message.nextToken = object.nextToken;
                return message;
            };

            /**
             * Creates a plain object from a ParallelScanResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof search.proto.ParallelScanResponse
             * @static
             * @param {search.proto.ParallelScanResponse} message ParallelScanResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ParallelScanResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.rows = [];
                if (options.defaults)
                    if (options.bytes === String)
                        object.nextToken = "";
                    else {
                        object.nextToken = [];
                        if (options.bytes !== Array)
                            object.nextToken = $util.newBuffer(object.nextToken);
                    }
                if (message.rows && message.rows.length) {
                    object.rows = [];
                    for (var j = 0; j < message.rows.length; ++j)
                        object.rows[j] = options.bytes === String ? $util.base64.encode(message.rows[j], 0, message.rows[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.rows[j]) : message.rows[j];
                }
                if (message.nextToken != null && message.hasOwnProperty("nextToken"))
                    object.nextToken = options.bytes === String ? $util.base64.encode(message.nextToken, 0, message.nextToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.nextToken) : message.nextToken;
                return object;
            };

            /**
             * Converts this ParallelScanResponse to JSON.
             * @function toJSON
             * @memberof search.proto.ParallelScanResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ParallelScanResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ParallelScanResponse;
        })();

        return proto;
    })();

    return search;
})();

module.exports = $root;
